#include <3ds.h>
#include <citro3d.h>

#include <sys/dirent.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <errno.h>
#include <stdarg.h>
#include <unistd.h>
#include <inttypes.h>

#include "lodepng.h"

// These headers are generated by the build process
#include "vshader_shbin.h"
//#include "textshader_shbin.h"

#include "bike_png.h"
#include "qrcode_png.h"

#define VERSION "0.2.4"

#define TICK ""
#define CLEAR_COLOR 0x000000FF

#define MOVE_UP 1
#define MOVE_DOWN 2
#define MOVE_LEFT 3
#define MOVE_RIGHT 4
#define TYPE_DEATH 5

#define NORTHEAST 1
#define SOUTHEAST 2
#define SOUTHWEST 3
#define NORTHWEST 4

#define ESC(x) "\x1b[" #x
#define RED     "!.r"
#define GREEN   "!.g"
#define YELLOW  "!.y"
#define DARKYELLOW  "!.j"
#define BLUE    "!.b"
#define MAGENTA "!.m"
#define CYAN    "!.c"
#define ORANGE  "!.o"
#define DARKGREEN "!.d"
#define PINK "!.p"
#define WHITE "!.w"
#define BLACK "!.z"
#define RAINBOW "!.u"

// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO)

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGBA8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

#define NUM_SPRITES 10
#define numBots 2

#define SAMPLERATE 22050
#define SAMPLESPERBUF (SAMPLERATE / 30)
#define BYTESPERSAMPLE 4
#define TEXT_VTX_ARRAY_COUNT (4*1024)

typedef struct { float position[3]; float texcoord[2]; } textVertex_s;

static C3D_Tex* glyphSheets;
static textVertex_s* textVtxArray;
static int textVtxArrayPos = 0;

u64 TICKS_PER_SEC = 268123480;
u64 TICKS_PER_MS = 268123;
bool movingApple = false;
int currentBots = numBots;
bool plotting[numBots] = {false,false};
int epsilon = 1;
int oldBotSpeed = 45;
u32 highScore = 0;
u64 flash = 0;
bool ignoreDeath = true;
char consoleBuffer[30][100];
u32 colors[10] = { 0x000cff00, 0x00e4ff00, 0x00004eff, 0x00fc00ff, 0x0000fff0, 0x0025722c, 0x00ff9600, 0x00ff7f82, 0x00ffffff, 0x00000000 };
u64 waitForFinish = 0;
bool uds_enabled = false;
bool readyToStart = false;
bool debugging = false;
int numOptions = 11;
bool erased[11] = {false,false,false,false,false,false,false,false,false,false,false};
bool options[11] = {false,false,false,false,false,false,false,false,false,false,false};
char optionNames[11][50] = {"Boundaries kill", "Tron mode", "Disable Diagonals", "Disable A", "Disable B", "Disable Y", "Enable R", "No apple", "Apples double length", "Disappear on death", "Occasional holes"};
char loading[8][5] = {"","","","","","","",""};
static DVLB_s* vshader_dvlb;
static shaderProgram_s program;
static int uLoc_projection;
static C3D_Mtx projection;

//static DVLB_s* textshader_dvlb;
//static shaderProgram_s textprogram;
static C3D_Mtx textprojection;

bool autoPilot = false;
bool debugHold = false;
int hole = 0;
int totalSpace = 0;
int lastDead = 0;
char mystring[200];
bool cheats = false;
bool forfeit = false;
float oldpx = 0;
float oldpy = 0;
int diag = 0;
circlePosition oldCPos;
touchPosition touch;
int wakeup = false;
int myNode = 0;
bool CATASTROPHIC_FAILURE = false;
bool inGame = false;
u16 src_NetworkNodeID;
udsBindContext bindctx;
u64 errorQuit = 0;
bool clearFlag = true;
char myName[50];
char overwriteName[50];
int quit = -1;
u32 dead;
u32 dead2;
bool addedToGame = true;
u64 lastSent = 0;
u64 UDSSent = 0;
circlePosition cpos;

bool replay = true;
bool connectionEstablished = false;
udsConnectionStatus constatus;

bool qrcode = false;
int oldDiag = 0;
u32 nextMove = 0;
u32 oldMove = 0;
bool usedSpecial[numBots];
u32 death = 0;
int myNum = 0;
int growthRate = 40;
int growth[10] = {40,40,40,40,40,40,40,40,40,40};

u32 pathPos[10] = {0,0,0,0,0,0,0,0,0,0};
u32 currentPath[10] = {1,1,1,1,1,1,1,1,1,1};

bool ready[10] = {false, false, false, false, false, false, false, false, false, false};

int bikeSpeed = (2 << 8);
static u32 HSL2RGB(float h, float sl, float l)
{
    float v;
    float r,g,b;

    r = l;   // default to gray
    g = l;
    b = l;
    v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);
    if (v > 0)
    {
          float m;
          float sv;
          int sextant;
          float fract, vsf, mid1, mid2;

          m = l + l - v;
          sv = (v - m ) / v;
          h *= 6.0;
          sextant = (int)h;
          fract = h - sextant;
          vsf = v * sv * fract;
          mid1 = m + vsf;
          mid2 = v - vsf;
          switch (sextant)
          {
                case 0:
                      r = v;
                      g = mid1;
                      b = m;
                      break;
                case 1:
                      r = mid2;
                      g = v;
                      b = m;
                      break;
                case 2:
                      r = m;
                      g = v;
                      b = mid1;
                      break;
                case 3:
                      r = m;
                      g = mid2;
                      b = v;
                      break;
                case 4:
                      r = mid1;
                      g = m;
                      b = v;
                      break;
                case 5:
                      r = v;
                      g = m;
                      b = mid2;
                      break;
          }
    }
    u32 out = 0;
    out |= (int)(r * 255.0f);
    out |= (int)(g * 255.0f) << 8;
    out |= (int)(b * 255.0f) << 16;
    out |= 0xff000000;
    return out;
}
void fill_buffer(void* audioBuffer, size_t offset, size_t size, int frequency) {
	u32* dest = (u32*) audioBuffer;

	for (int i = 0; i < size; i++) {
		// This is a simple sine wave, with a frequency of `frequency` Hz, and an amplitude 30% of maximum.
		s16 sample = 0.3 * 0x7FFF * sin(frequency * (2 * M_PI) * (offset + i) / SAMPLERATE);

		// Stereo samples are interleaved: left and right channels.
		dest[i] = (sample << 16) | (sample & 0xffff);
	}

	DSP_FlushDataCache(audioBuffer, size);
}
//simple sprite struct
typedef struct {
	int x,y;			// screen co-ordinates 
	int dx, dy;			// velocity
	int image;
	int speed;
	int length;
	bool dead;
	int node;
	int diag;
	bool forwards;
	u8 hole;
	char username[50];
}Sprite;

typedef struct path_s {
	int x, y;
	struct path_s * next;
}Path;
Path path[200 * 120][NUM_SPRITES];

//autopilot and ai
u64 giveUpTimer[numBots] = {0,0};
Path *openSet[numBots];
Path cameFrom[numBots][401][241];
Path totalPath[numBots][401 * 241];
int totalPathN[numBots] = {0,0};
int openSetN[numBots] = {0,0};
Path *closedSet[numBots];
int closedSetN[numBots] = {0,0};
int gscore[numBots][401][241];
int fscore[numBots][401][241];

typedef struct {
	int x, y;
}Apple;

typedef struct {
	Sprite sprite;
	u64 timestamp;
	int sender;
}Message;

u64 lastApple = 0;

u64 lastRainbow = 0;
float rainbow = 0.0f;

int actual_bikes = 1;
Message sentMsg;
u64 lastScore;
u64 lastChange;
u64 lastSprite;
u64 lastDeadmsg;
u64 lastHighscore;
u64 lastScreenScore;
bool replyScreenScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool receivedScreenScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyDead[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyHighscore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyChange[10] = {0,0,0,0,0,0,0,0,0,0};
bool replySprite[10] = {0,0,0,0,0,0,0,0,0,0};

udsNodeInfo tmpnode;
Result ret=0;


u32 gameOver = 0;
Apple apple;
Message msg;
udsConnectionType conntype;

int num_bikes = 1;
Sprite sprites[NUM_SPRITES];

u32 con_type = 0;


C3D_RenderTarget* target;
C3D_RenderTarget* target2;


u64 frameTicks[10];

int score[10] = {0,0,0,0,0,0,0,0,0,0};
int oldscore[10];

int joinedNum = 0;
int oldbikes;

u8* frameBuf;
static float printy = 10.0;
static float printx = 10.0;
int optionsToInt() {
    int ret = 0;
    int tmp;
    for (int i = 0; i < numOptions; i++) {
        tmp = options[i];
        ret |= tmp << (i);
    }
    return ret;
}
static void clearString() {
	memset(mystring,0,sizeof(mystring));
}
void setOptions(unsigned int n) {
	for (unsigned int i = 0; i != numOptions; ++i)
	{
	  options[i] = n & 1;
	  n /= 2;
	}
}

int numPlayers() {
	if (actual_bikes > 1) return actual_bikes;
	return actual_bikes + currentBots - 1;
}
int toBot(int s) {
	if (autoPilot && s == myNum) return 0;
	if (s >= currentBots) return 0;
	return s;
}
int getBot(int s) {
	if (s == 0) return myNum;
	if (s >= currentBots) return currentBots - 1;
	return s;
}

static void screen_get_string_size_internal(float* width, float* height, const char* text, float scaleX, float scaleY, bool oneLine, bool wrap, float wrapX) {
    float w = 0;
    float h = 0;
    float lineWidth = 0;

    if(text != NULL) {
        h = scaleY * fontGetInfo()->lineFeed;

        const uint8_t* p = (const uint8_t*) text;
        const uint8_t* lastAlign = p;
        u32 code = 0;
        ssize_t units = -1;
        while(*p && (units = decode_utf8(&code, p)) != -1 && code > 0) {
            p += units;

            if(code == '\n' || (wrap && lineWidth + scaleX * fontGetCharWidthInfo(fontGlyphIndexFromCodePoint(code))->charWidth >= wrapX)) {
                lastAlign = p;

                if(lineWidth > w) {
                    w = lineWidth;
                }

                lineWidth = 0;

                if(oneLine) {
                    break;
                }

                h += scaleY * fontGetInfo()->lineFeed;
            }

            if(code != '\n') {
                u32 num = 1;
                if(code == '\t') {
                    code = ' ';
                    num = 4 - (p - units - lastAlign) % 4;

                    lastAlign = p;
                }

                lineWidth += (scaleX * fontGetCharWidthInfo(fontGlyphIndexFromCodePoint(code))->charWidth) * num;
            }
        }
    }

    if(width) {
        *width = lineWidth > w ? lineWidth : w;
    }

    if(height) {
        *height = h;
    }
}
void screen_get_string_size_wrap(float* width, float* height, const char* text, float scaleX, float scaleY, float wrapX) {
    screen_get_string_size_internal(width, height, text, scaleX, scaleY, false, true, wrapX);
}
static void setTextColor(u32 color)
{
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_RGB, GPU_CONSTANT, 0, 0);
	C3D_TexEnvSrc(env, C3D_Alpha, GPU_TEXTURE0, GPU_CONSTANT, 0);
	C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
	C3D_TexEnvFunc(env, C3D_RGB, GPU_REPLACE);
	C3D_TexEnvFunc(env, C3D_Alpha, GPU_MODULATE);
	C3D_TexEnvColor(env, color);
}

static void addTextVertex(float vx, float vy, float tx, float ty)
{
	textVertex_s* vtx = &textVtxArray[textVtxArrayPos++];
	vtx->position[0] = vx;
	vtx->position[1] = vy;
	vtx->position[2] = 0.5f;
	vtx->texcoord[0] = tx;
	vtx->texcoord[1] = ty;
}
static void renderText(float x, float y, float scaleX, float scaleY, bool baseline, const char* text)
{
	ssize_t  units;
	uint32_t code;

	// Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);
	BufInfo_Add(bufInfo, textVtxArray, sizeof(textVertex_s), 2, 0x10);

	const uint8_t* p = (const uint8_t*)text;
	float firstX = x;
	u32 flags = GLYPH_POS_CALC_VTXCOORD | (baseline ? GLYPH_POS_AT_BASELINE : 0);
	int lastSheet = -1;
	do
	{
		if (!*p) break;
		units = decode_utf8(&code, p);
		if (units == -1)
			break;
		p += units;
		if (code == '\n')
		{
			x = firstX;
			y += scaleY*fontGetInfo()->lineFeed;
		}
		else if (code > 0)
		{
			int glyphIdx = fontGlyphIndexFromCodePoint(code);
			fontGlyphPos_s data;
			fontCalcGlyphPos(&data, glyphIdx, flags, scaleX, scaleY);

			// Bind the correct texture sheet
			if (data.sheetIndex != lastSheet)
			{
				lastSheet = data.sheetIndex;
				C3D_TexBind(0, &glyphSheets[lastSheet]);
			}

			int arrayIndex = textVtxArrayPos;
			if ((arrayIndex+4) >= TEXT_VTX_ARRAY_COUNT)
				break; // We can't render more characters

			// Add the vertices to the array
			addTextVertex(x+data.vtxcoord.left,  y+data.vtxcoord.bottom, data.texcoord.left,  data.texcoord.bottom);
			addTextVertex(x+data.vtxcoord.right, y+data.vtxcoord.bottom, data.texcoord.right, data.texcoord.bottom);
			addTextVertex(x+data.vtxcoord.left,  y+data.vtxcoord.top,    data.texcoord.left,  data.texcoord.top);
			addTextVertex(x+data.vtxcoord.right, y+data.vtxcoord.top,    data.texcoord.right, data.texcoord.top);

			// Draw the glyph
			C3D_DrawArrays(GPU_TRIANGLE_STRIP, arrayIndex, 4);

			x += data.xAdvance;

		}
	} while (code > 0);
}
static void rText(float x, float y, float scaleX, float scaleY, bool baseline, const char* text) {
	setTextColor(0xffffffff); 
	char out[100];
	char sub[100];
	memset(out,0,sizeof(out));
	strncpy(out,text,sizeof(out));
	float height;
	float width;
	int i = 0;
	while (strstr(out,"!.") != NULL && i < 40) {
		i++;
		char *result = strstr(out,"!.");
		int position = result - out + 3;
		int substringLength = strlen(out) - position;
		out[position - 3] = 0;
		renderText(x,y,.5f,.5f,true,out);
		screen_get_string_size_wrap(&width, &height, out, 0.5f, 0.5f, 320);
		x += width;
		if (out[position - 1] == 'r') setTextColor(0xff0000ff);
		else if(out[position - 1] == 'g') setTextColor(colors[0] | 0xff000000);
		else if(out[position - 1] == 'y') setTextColor(0xff00ffe4);
		else if(out[position - 1] == 'b') setTextColor(0xffff4e00);
		else if(out[position - 1] == 'm') setTextColor(0xffff00fc);
		else if(out[position - 1] == 'c') setTextColor(0xfff0ff00);
		else if(out[position - 1] == 'd') setTextColor(0xff2c7225);
		else if(out[position - 1] == 'o') setTextColor(0xff0096ff);
		else if(out[position - 1] == 'p') setTextColor(0xff827fff);
		else if(out[position - 1] == 'w') setTextColor(0xffffffff);
		else if(out[position - 1] == 'z') setTextColor(0xff000000);
		else if(out[position - 1] == 'j') setTextColor(0xff008275);
		else if(out[position - 1] == 'u') setTextColor(HSL2RGB(rainbow,0.5,0.5));
		memset(sub,0,sizeof(sub));
		snprintf(sub,sizeof(sub),"%.*s",substringLength,out + position);
		result = strstr(sub,"!.");
		if (result != NULL) position = result - sub;
		else position = sizeof(sub);
		memset(out,0,sizeof(out));
		snprintf(out,sizeof(out),"%.*s",sizeof(sub) - position,sub + position);
		sub[position] = 0;
		//sprintf("%.*s",substringLength,out + position);
		renderText(x, y, .5f, .5f, true, sub);
		screen_get_string_size_wrap(&width, &height, sub, 0.5f, 0.5f, 320);
		x += width;
	}
	renderText(x, y, .5f, .5f, true, out);
}
int consolei = 0;
void myprintf(const char *format, ...) {
	if (strstr(format,"[") != NULL && format[0] == '\x1b') {
		char sub[100];
		memset(sub,0,sizeof(sub));
		char *result = strstr(format,"[");
		int position = result - format + 1;
		int substringLength = strlen(format) - position;
		snprintf(sub,sizeof(sub),"%.*s",substringLength,format + position);
		if (strstr(sub,";") != NULL) {
			char num[20];
			result = strstr(sub,";");
			position = result - sub;
			if (position > 2) return;
			memset(num,0,sizeof(num));
			snprintf(num,sizeof(num),"%.*s",position,sub);
			int n;
			sscanf(num,"%d",&n);
			if (n > 15 || n < 0) return;
			if (strstr(sub,"H") == NULL) return;
			result = strstr(sub,"H");
			position = result - sub + 1;
			memset(consoleBuffer[n],0,sizeof(consoleBuffer[n]));
			snprintf(consoleBuffer[n],sizeof(consoleBuffer[n]),"%.*s",strlen(sub) - position,sub + position);
			if (n > consolei && n < 14) consolei = n + 1;
			else if (n == consolei && n < 15) consolei++;
			return;
		} else return;
	}
	if (consolei >= 15) {
		for (int i = 0; i < 15; i++) {
			strncpy(consoleBuffer[i],consoleBuffer[i+1],sizeof(consoleBuffer[i]) - 1);
		}
		consolei = 15;
	}
	snprintf(consoleBuffer[consolei], sizeof(consoleBuffer[consolei]), "%s", format);
	if (consolei < 15) consolei += 1;
	return;
}
Path current[2];
void util_free_path_utf8(FS_Path* path) {
    free((void*) path->data);
    free(path);
}
FS_Path* util_make_path_utf8(const char* path) {
    size_t len = strlen(path);

    u16* utf16 = (u16*) calloc(len + 1, sizeof(u16));
    if(utf16 == NULL) {
        return NULL;
    }

    ssize_t utf16Len = utf8_to_utf16(utf16, (const uint8_t*) path, len);

    FS_Path* fsPath = (FS_Path*) calloc(1, sizeof(FS_Path));
    if(fsPath == NULL) {
        free(utf16);
        return NULL;
    }

    fsPath->type = PATH_UTF16;
    fsPath->size = (utf16Len + 1) * sizeof(u16);
    fsPath->data = utf16;

    return fsPath;
}
Result importUsername() {
	char pathBuf[64];
	snprintf(pathBuf, 64, "/snakes.dat");

	Result res = 0;

	FS_Path* fsPath = util_make_path_utf8(pathBuf);
	if(fsPath != NULL) {
	    char name[50];
	    u32 score = 0;

	    Handle fileHandle = 0;
	    if(R_SUCCEEDED(res = FSUSER_OpenFileDirectly(&fileHandle, ARCHIVE_SDMC, fsMakePath(PATH_EMPTY, ""), *fsPath, FS_OPEN_READ, 0))) {
	        u32 bytesRead = 0;
	        res = FSFILE_Read(fileHandle, &bytesRead, 0, name, sizeof(name));
	        if (bytesRead > 0) {
		        clearString();
		        /*snprintf(mystring,sizeof(mystring),"size: %d",bytesRead);
		        myprintf(mystring);*/
		        snprintf(overwriteName,sizeof(overwriteName),"%s",name);
	    	}
	    	res = FSFILE_Read(fileHandle, &bytesRead, sizeof(name), &score, sizeof(score));
	        if (bytesRead > 0) {
	        	snprintf(mystring,sizeof(mystring),"Current Highscore: %" PRIu32,score);
	        	myprintf(mystring);
	        	highScore = score;
	        }
	        FSFILE_Close(fileHandle);
	    }

	    util_free_path_utf8(fsPath);

	    if(R_SUCCEEDED(res)) {
	    	if (strlen(overwriteName) > 0) {
		    	clearString();
		    	snprintf(mystring,sizeof(mystring),"Welcome, %s",overwriteName);
		    	myprintf(mystring);
	    	}
	    } else {
	    	//myprintf("Creating save file...");
	    	FILE *fp;
	    	fp = fopen("sdmc:/snakes.dat", "wb");
	    	fclose(fp);
	    }
	} else {
		//myprintf("Creating save file...");
    	FILE *fp;
    	fp = fopen("sdmc:/snakes.dat", "wb");
    	fclose(fp);
	    res = -1;
	}

	return res;
}
Result writeUsername() {
	char pathBuf[64];
	snprintf(pathBuf, 64, "/snakes.dat");

	Result res = 0;

	FS_Path* fsPath = util_make_path_utf8(pathBuf);
	if(fsPath != NULL) {

	    Handle fileHandle = 0;
	    if(R_SUCCEEDED(res = FSUSER_OpenFileDirectly(&fileHandle, ARCHIVE_SDMC, fsMakePath(PATH_EMPTY, ""), *fsPath, FS_OPEN_WRITE, 0))) {
	        u32 bytesRead = 0;
	        res = FSFILE_Write(fileHandle, &bytesRead, 0, overwriteName, sizeof(overwriteName), 0);

	        res = FSFILE_Write(fileHandle, &bytesRead, sizeof(overwriteName), &highScore, sizeof(highScore), 0);
	        FSFILE_Close(fileHandle);
	    }

	    util_free_path_utf8(fsPath);

	    if(R_SUCCEEDED(res)) {
	        if (debugging) myprintf("Successfully saved usename.");
	    } else {
	    	if (debugging) myprintf("Couldn't write to file.");
	    }
	} else {
		if (debugging) myprintf("Something went wrong saving username.");
	    res = -1;
	}

	return res;
}
static C3D_Tex spritesheet_tex;
static C3D_Tex qrcode_tex;
void keepXConsole() {
	if (svcGetSystemTick() - lastRainbow > TICKS_PER_MS * 30) { lastRainbow = svcGetSystemTick(); rainbow += 0.01; if (rainbow > 1) rainbow = 0.0f; }
	printy = 10.0;
	setTextColor(0xffffffff); 
	float height;
	float width;
	textVtxArrayPos = 0;
	char out[100];
	char sub[100];
	memset(out,0,sizeof(out));
	for (int i = 0; i <= consolei; i++) {
		printx = 0.0;
		if (strlen(consoleBuffer[i]) > 0) {
			strncpy(out,consoleBuffer[i],sizeof(out));
			int i = 0;
			while (strstr(out,"!.") != NULL && i < 40) {
				i++;
				char *result = strstr(out,"!.");
				int position = result - out + 3;
				int substringLength = strlen(out) - position;
				out[position - 3] = 0;
				renderText(printx,printy,.5f,.5f,true,out);
				screen_get_string_size_wrap(&width, &height, out, 0.5f, 0.5f, 320);
				printx += width;
				if (out[position - 1] == 'r') setTextColor(0xff0000ff);
				else if(out[position - 1] == 'g') setTextColor(colors[0] | 0xff000000);
				else if(out[position - 1] == 'y') setTextColor(0xff00ffe4);
				else if(out[position - 1] == 'b') setTextColor(0xffff4e00);
				else if(out[position - 1] == 'm') setTextColor(0xffff00fc);
				else if(out[position - 1] == 'c') setTextColor(0xfff0ff00);
				else if(out[position - 1] == 'd') setTextColor(0xff2c7225);
				else if(out[position - 1] == 'o') setTextColor(0xff0096ff);
				else if(out[position - 1] == 'p') setTextColor(0xff827fff);
				else if(out[position - 1] == 'w') setTextColor(0xffffffff);
				else if(out[position - 1] == 'z') setTextColor(0xff000000);
				else if(out[position - 1] == 'j') setTextColor(0xff008275);
				else if(out[position - 1] == 'u') setTextColor(HSL2RGB(rainbow,0.5,0.5));
				memset(sub,0,sizeof(sub));
				snprintf(sub,sizeof(sub),"%.*s",substringLength,out + position);
				result = strstr(sub,"!.");
				if (result != NULL) position = result - sub;
				else position = sizeof(sub);
				memset(out,0,sizeof(out));
				snprintf(out,sizeof(out),"%.*s",sizeof(sub) - position,sub + position);
				sub[position] = 0;
				//sprintf("%.*s",substringLength,out + position);
				renderText(printx, printy, .5f, .5f, true, sub);
				screen_get_string_size_wrap(&width, &height, sub, 0.5f, 0.5f, 320);
				printx += width;
			}
			renderText(printx, printy, .5f, .5f, true, out);
		}
		screen_get_string_size_wrap(NULL, &height, ".", 0.5f, 0.5f, 320);
		printy += height;
		if (printy > 320) break;
	}
}
void keepSConsole() {
	keepXConsole();
}
void keepConsole() {
	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
	C3D_FrameDrawOn(target2);
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &textprojection);
	keepXConsole();
	C3D_FrameEnd(0);
}
int getImg(int img) {
	if (sprites[img].hole) return 9;
	return img;
}
int getAndDecImg(int img) {
	if (sprites[img].hole) { sprites[img].hole--; if (sprites[img].hole) return 9; }
	return img;
}
void myconsoleClear() {
	consolei = 0;
	memset(consoleBuffer,0,sizeof(consoleBuffer[0][0]) * 60 * 30);
	return;
}
int getLength(int num) {
	if (currentPath[num] < pathPos[num]) return ((200 * 120) - pathPos[num]) + currentPath[num];
	else return currentPath[num] - pathPos[num];
}

struct { float left, right, top, bottom; } images[12] = {
	{0.5f, 0.625f, 0.0f, 0.125f}, //bikes
	{0.625f, 0.75f, 0.0f, 0.125f},
	{0.75f, 0.875f, 0.0f, 0.125f},
	{0.875f, 1.0f, 0.0f, 0.125f},
	{0.5f, 0.625f, 0.125f, 0.25f},
	{0.625f, 0.75f, 0.125f, 0.25f},
	{0.75f, 0.875f, 0.125f, 0.25f},
	{0.875f, 1.0f, 0.125f, 0.25f},
	{0.5f, 0.75f, 0.25f, 0.5f}, //apple
	{0.75f, 1.0f, 0.25f, 0.5f}, //erase
	{0.0f, 0.5f, 0.0f, 0.5f}, //splash screen
	{0.0f, 1.0f, 0.0f, 1.0f}, //qrcode
};
char textColors[10][12] = {GREEN, YELLOW, BLUE, MAGENTA, CYAN, DARKGREEN, ORANGE, PINK, RAINBOW, WHITE};
char colorNames[10][12] = {"Green", "Yellow", "Blue", "Magenta", "Cyan", "Dark Green", "Orange", "Pink", "Rainbow", "Black"};

u32 getNextColor(int x, int y) { // Thank you WolfVak for the code!
	if (x > 400) x = 0;
	else if(x < 0) x = 400;
	if (y > 240) y = 0;
	else if (y < 0) y = 240;
	for (int i = 0; i < numPlayers(); i++) {
		if (sprites[i].dead) continue;
		if (abs(x - (sprites[i].x >> 8)) < 2 && abs(y - (sprites[i].y >> 8)) < 2) return colors[i];
	}
	u32 offset = ((x * 240) - y + 239) * 3;
	return (u32) (frameBuf[offset] | frameBuf[offset + 1]  << 8 | frameBuf[offset  + 2] << 16);
}
u32 getColor(int x, int y) { // Thank you WolfVak for the code!
	if (x > 400) x = 0;
	else if(x < 0) x = 400;
	if (y > 240) y = 0;
	else if (y < 0) y = 240;
	u32 offset = ((x * 240) - y + 239) * 3;
	return (u32) (frameBuf[offset] | frameBuf[offset + 1]  << 8 | frameBuf[offset  + 2] << 16);
}
void writeColor(int x, int y, u32 color) {
	if (x > 400) x = 0;
	else if(x < 0) x = 398;
	if (y > 240) y = 0;
	else if (y < 0) y = 238;
	u32 offset = ((x * 240) - y + 239) * 3;
	frameBuf[offset] = color;
	frameBuf[offset + 1] = color >> 8;
	frameBuf[offset + 2] = color >> 16;
}
void showMemoryError() {
	myprintf("Error: ran out of memory...");
	while (aptMainLoop()) {
		keepConsole();
		hidScanInput();
		if (hidKeysDown() & KEY_START) {
			CATASTROPHIC_FAILURE = true;
			return;
		}
	}
}
void addClosedSet(int x, int y, int s) {
	Path * newNode;
	newNode = malloc(sizeof(Path));
	if (newNode == NULL) {
		showMemoryError();
		return;
	}
	newNode->x = x;
	newNode->y = y;
	if (closedSetN[s] > 0) newNode->next = closedSet[s];
	else newNode->next = NULL;
	closedSet[s] = newNode;
    closedSetN[s]++;
}
void clearClosedSet(int s) {
	if (closedSetN[s] == 0) return;
    Path * c;
    Path * temp;
    c = closedSet[s];
    if (c == NULL) return;
    while (c->next != NULL) {
    	temp = c;
        c = c->next;
        temp->next = NULL;
        free(temp);
    }
    free(c);
    closedSet[s] = NULL;
    closedSetN[s] = 0;
}
void remClosedSet(int x, int y, int s) {
	if (closedSetN[s] <= 0) return;
    Path * c;
    Path * prev = NULL;
    c = closedSet[s];
    if (c == NULL) return;
    if (c->x == x && c->y == y) {
    	Path * temp;
        temp = c->next;
        free(c);
        closedSet[s] = temp;
        closedSetN[s]--;
        return;
    }
    while (c->next != NULL) {
        prev = c;
        c = c->next;
        if (c->x == x && c->y == y) break;
    }
    if (c->x != x || c->y != y) return;
    if (prev == NULL) return;
    prev->next = c->next;
    free(c);
    c = NULL;
    closedSetN[s]--;
}
bool openSetNotEmpty(int s) {
	return openSetN[s] != 0;
}
int sanitizeX(int x) {
	if (x < 2) return 396;
	if (x > 396) return 2;
	return x;
	/*if (x > 398) return 0;
	else if (x < 0) return 398;
	return x;*/
}
int sanitizeY(int y) {
	if (y < 2) return 236;
	if (y > 236) return 2;
	return y;
	/*if (y > 238) return 0;
	else if (y < 0) return 238;
	return y;*/
}
bool inClosedSet(int x, int y, int s) {
	Path * c = closedSet[s];
    while (c != NULL) {
    	if (c->x == x && c->y == y) return true;
		c = c->next;
    }
	return false;
}
bool inOpenSet(int x, int y, int s) {
	Path * c = openSet[s];
    while (c != NULL) {
    	if (c->x == x && c->y == y) return true;
		c = c->next;
    }
	return false;
}
void addOpenSet(int x, int y, int s) {
	Path * newNode;
	newNode = malloc(sizeof(Path));
	if (newNode == NULL) {
		showMemoryError();
		return;
	}
	newNode->x = x;
	newNode->y = y;
	if (openSetN[s] > 0) newNode->next = openSet[s];
	else newNode->next = NULL;
	openSet[s] = newNode;
    openSetN[s]++;
}
void clearOpenSet(int s) {
	if (openSetN[s] == 0) return;
    Path * c;
    Path * temp;
    c = openSet[s];
    if (c == NULL) return;
    while (c->next != NULL) {
    	temp = c;
        c = c->next;
        temp->next = NULL;
        free(temp);
    }
    free(c);
    openSet[s] = NULL;
    openSetN[s] = 0;
}
void remOpenSet(int x, int y, int s) {
	if (openSetN[s] <= 0) return;
    Path * c;
    Path * prev = NULL;
    c = openSet[s];
    if (c == NULL) return;
    if (c->x == x && c->y == y) {
    	Path * temp;
        temp = c->next;
        free(c);
        openSet[s] = temp;
        openSetN[s]--;
        return;
    }
    while (c->next != NULL) {
        prev = c;
        c = c->next;
        if (c->x == x && c->y == y) break;
    }
    if (c->x != x || c->y != y) return;
    if (prev == NULL) return;
    prev->next = c->next;
    c->next = NULL;
    free(c);
    c = NULL;
    openSetN[s]--;
}
int getDist(int x, int y, int dx, int dy) {
	if (!options[0]) {
		/*if (dx % 2 != x % 2) {
			if (abs(dx - 1 - x) < abs(dx + 1 - x)) dx -= 1;
			else dx += 1;
		}
		if (dy % 2 != y % 2) {
			if (abs(dy - 1 - y) < abs(dy + 1 - y)) dy -= 1;
			else dy += 1;
		}*/
		int smallestx = abs(dx - x);
		int smallesty = abs(dy - y);
		if (398 - dx + x < smallestx) smallestx = 398 - dx + x - 2;
		else if (398 - x + dx < smallestx) smallestx = 398 - x + dx;
		if (238 - dy + y < smallesty) smallesty = 238 - dy + y - 2;
		else if (238 - y + dy < smallesty) smallesty = 238 - y + dy;
		return smallestx + smallesty;
	}
	return abs(dx - x) + abs(dy - y);
}
void addNode(int x, int y, int nx, int ny, int myGScore, int s) {
	int ac = getBot(s);
	gscore[s][nx][ny] = myGScore;
	fscore[s][nx][ny] = myGScore + getDist(nx,ny,sprites[ac].x >> 8,sprites[ac].y >> 8) * epsilon;
}
void addNodeToApple(int x, int y, int nx, int ny, int myGScore, int s) {
	cameFrom[s][nx][ny].x = x;
	cameFrom[s][nx][ny].y = y;
	gscore[s][nx][ny] = myGScore;
	fscore[s][nx][ny] = myGScore + getDist(nx,ny,apple.x >> 8,apple.y >> 8) * epsilon;
}
void continueAddNodeToApple(int x, int y, int nx, int ny, int myGScore, int s) {
	cameFrom[s][nx][ny].x = x;
	cameFrom[s][nx][ny].y = y;
	gscore[s][nx][ny] = myGScore;
	fscore[s][nx][ny] = myGScore + getDist(nx,ny,apple.x >> 8,apple.y >> 8) * epsilon;
}
bool directions[4] = {false,false,false,false};
int getDirectionY(int i, int s) {
	if (i == 0) return sanitizeY(current[s].y - 2);
	else if (i == 1) return sanitizeY(current[s].y + 2);
	return sanitizeY(current[s].y);
}
int getDirectionX(int i, int s) {
	if (i == 2) return sanitizeX(current[s].x - 2);
	else if (i == 3) return sanitizeX(current[s].x + 2);
	return sanitizeX(current[s].x);
}
int getDirectionYTo(int i, int y, int s) {
	if (i == 0) return sanitizeY(y - 2);
	else if (i == 1) return sanitizeY(y + 2);
	else if (i == 2) return sanitizeY(y + 2);
	else if (i == 3) return sanitizeY(y - 2);
	else if (i == 4) return sanitizeY(y - 2);
	else if (i == 5) return sanitizeY(y + 2);
	return sanitizeY(y);
}
int getDirectionXTo(int i, int x, int s) {
	if (i <= 1) return sanitizeX(x - 2);
	else if (i == 2) return sanitizeX(x + 2);
	else if (i == 3) return sanitizeX(x + 2);
	else if (i <= 5) return sanitizeX(x);
	else if (i == 6) return sanitizeX(x - 2);
	else if (i == 7) return sanitizeX(x + 2);
	return sanitizeX(x);
}
int getDirection(int s) {
	int ac = getBot(s);
	int r = 0;
	int smallest = INT_MAX;
	for (int i = 0; i < 4; i++) {
		if (directions[i] && getDist(getDirectionX(i,s), getDirectionY(i,s),sprites[ac].x >> 8, sprites[ac].y >> 8) * epsilon < smallest) {
			smallest = getDist(getDirectionX(i,s),getDirectionY(i,s),sprites[ac].x >> 8, sprites[ac].y >> 8) * epsilon;
			r = i;
		}
	}
	return r;
}
int getDirectionToApple(int s) {
	int r = 0;
	int smallest = INT_MAX;
	for (int i = 0; i < 4; i++) {
		if (directions[i] && getDist(getDirectionX(i,s), getDirectionY(i,s),apple.x >> 8, apple.y >> 8) * epsilon < smallest) {
			smallest = getDist(getDirectionX(i,s),getDirectionY(i,s),apple.x >> 8, apple.y >> 8) * epsilon;
			r = i;
		}
	}
	return r;
}
void setCurrentF(int s) {
	int smallest = INT_MAX;
	if (openSetN[s] <= 0) {
		current[s].x = 0;
		current[s].y = 0;
		return;
	}
	Path * c = openSet[s];
	while (c != NULL) {
		if (fscore[s][c->x][c->y] != 1 && fscore[s][c->x][c->y] < smallest) {
			smallest = fscore[s][c->x][c->y];
			current[s].x = c->x;
			current[s].y = c->y;
		}
		c = c->next;
	}
}
/*void setCurrentF2() {
	int smallest = INT_MAX;
	for (int i = 0; i < openSetN[s]; i++) {
		if (fscore[openSet[i].x][openSet[i].y] != 1 && fscore[openSet[i].x][openSet[i].y] < smallest) {
			smallest = fscore[openSet[i].x][openSet[i].y];
			current[s].x = openSet[i].x;
			current[s].y = openSet[i].y;
		}
	}
}*/
bool haveDirection() {
	for (int i = 0; i < 4; i++) {
		if (directions[i]) return true;
	}
	return false;
}
static int UDSSend(Message msg) {
	if (!uds_enabled || debugHold || num_bikes <= 1) return 0;
	msg.sender = myNum;
	//if (debugging) { snprintf(mystring,sizeof(mystring),"sending speed: %d image: %d diag: %d",msg.sprite.speed,msg.sprite.image,msg.sprite.diag); myprintf(mystring); }
	if (msg.sprite.image == myNum && msg.sprite.speed == 77) { msg.timestamp = lastScore; }
	else if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.sprite.node == myNode) { msg.timestamp = lastSprite; msg.sender = myNode; }
	else if (msg.sprite.speed == 2020 && myNum == 0) msg.timestamp = lastDeadmsg;
	else if (msg.sprite.speed == 5050 && myNum == msg.sprite.image) msg.timestamp = lastScreenScore;
	else if (msg.sprite.image == myNum && msg.sprite.speed == 66) { msg.timestamp = lastChange; }
	else if (msg.sprite.image == myNum) { msg.timestamp = lastSprite; }
	sentMsg = msg;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		ret = udsSendTo(UDS_BROADCAST_NETWORKNODEID, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			snprintf(mystring,sizeof(mystring),"Error: UDSSend() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			CATASTROPHIC_FAILURE = true;
			return 1;
		}
	}
	return 0;
}
int getMoveableRange(int s) {
	if (s >= numPlayers()) return 40;
	clearClosedSet(s);
	clearOpenSet(s);
	memset(gscore[s],1,sizeof(gscore[0][0][0]) * 401 * 241);
	memset(fscore[s],1,sizeof(fscore[0][0][0]) * 401 * 241);
	int x = sprites[s].x >> 8;
	int y = sprites[s].y >> 8;
	addOpenSet(x,y,s);
	gscore[s][x][y] = 0;
	fscore[s][x][y] = getDist(x,y,sprites[s].x >> 8,sprites[s].y >> 8);
	int i = 0;
	while (openSetNotEmpty(s) && i < 80) {
		if (closedSetN[s] > 80) return 40;
		if (openSetN[s] > 80) return 40;
		hidScanInput();
		if (hidKeysDown() & KEY_START) break;
		//keepConsole();
		i++;
		setCurrentF(s);
		/*C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			writeColor(current[s].x,current[s].y,colors[4]);
		C3D_FrameEnd(0);*/
		if (abs((apple.x >> 8) - current[s].x) < 3 && abs((apple.y >> 8) - current[s].y) < 3) {
			return 40;
		}
		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection()  && m < 4) {
			m++;
			int d = getDirection(s);
			/*snprintf(mystring,sizeof(mystring),"dist: %d",getDist(getDirectionX(d,s),getDirectionY(d,s),sprites[s].x >> 8, sprites[s].y >> 8));
			myprintf(mystring);*/
			if (!getColor(getDirectionX(d,s),getDirectionY(d,s)) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
				}
				directions[d] = false;
			}
			directions[d] = false;
		}

	}
	return closedSetN[s] / 2;
}
void getMoveableRangeApple(int s) {
	if (s >= numPlayers()) return;
	u64 startPath = svcGetSystemTick();
	clearClosedSet(s);
	clearOpenSet(s);
	memset(gscore[s],1,sizeof(gscore[0][0][0]) * 401 * 241);
	memset(fscore[s],1,sizeof(fscore[0][0][0]) * 401 * 241);
	int x = sprites[s].x >> 8;
	int y = sprites[s].y >> 8;
	addOpenSet(x,y,s);
	gscore[s][x][y] = 0;
	fscore[s][x][y] = getDist(x,y,sprites[s].x >> 8,sprites[s].y >> 8);
	int i = 0;
	while (openSetNotEmpty(s) && i < 400) {
		if ((svcGetSystemTick() - startPath) / TICKS_PER_MS / (sprites[s].speed / 3)) {
			if (closedSetN[s] >= 0) {
				apple.x = ((rand() % (400 - 64)) + 30) << 8;
				apple.y = ((rand() % (240 - 64)) + 30) << 8;
				while (getColor(apple.x >> 8, apple.y >> 8) || getColor((apple.x >> 8) + 1, (apple.y >> 8) + 1)) {
					apple.x = ((rand() % (400 - 64)) + 30) << 8;
					apple.y = ((rand() % (240 - 64)) + 30) << 8;
				}
				return;
			}
			apple.x = closedSet[s]->x << 8;
			apple.y = closedSet[s]->y << 8;
			return;
		}
		if (closedSetN[s] > 400) { 
			apple.x = closedSet[s]->x << 8;
			apple.y = closedSet[s]->y << 8;
			return;
		}
		if (openSetN[s] > 400) {
			if (closedSetN[s] <= 0) {
				apple.x = ((rand() % (400 - 64)) + 30) << 8;
				apple.y = ((rand() % (240 - 64)) + 30) << 8;
				while (getColor(apple.x >> 8, apple.y >> 8) || getColor((apple.x >> 8) + 1, (apple.y >> 8) + 1)) {
					apple.x = ((rand() % (400 - 64)) + 30) << 8;
					apple.y = ((rand() % (240 - 64)) + 30) << 8;
				}
				return;
			}
			apple.x = closedSet[s]->x << 8;
			apple.y = closedSet[s]->y << 8;
			return;
		}
		hidScanInput();
		if (hidKeysDown() & KEY_START) {
			if (closedSet[s] == NULL) {
				apple.x = ((rand() % (400 - 64)) + 30) << 8;
				apple.y = ((rand() % (240 - 64)) + 30) << 8;
				while (getColor(apple.x >> 8, apple.y >> 8) || getColor((apple.x >> 8) + 1, (apple.y >> 8) + 1)) {
					apple.x = ((rand() % (400 - 64)) + 30) << 8;
					apple.y = ((rand() % (240 - 64)) + 30) << 8;
				}
				return;
			}
			apple.x = closedSet[s]->x << 8;
			apple.y = closedSet[s]->y << 8;
			return;
		}
		//keepConsole();
		i++;
		setCurrentF(s);

		/*C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			writeColor(current[s].x,current[s].y,colors[4]);
		C3D_FrameEnd(0);*/

		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection() && m < 4) {
			m++;
			int d = getDirection(s);
			/*snprintf(mystring,sizeof(mystring),"dist: %d",getDist(getDirectionX(d,s),getDirectionY(d,s),sprites[s].x >> 8, sprites[s].y >> 8));
			myprintf(mystring);*/
			if (!getColor(getDirectionX(d,s),getDirectionY(d,s)) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
				}
				directions[d] = false;
			}
			directions[d] = false;
		}

	}
	if (closedSet[s] == NULL) {
		apple.x = ((rand() % (400 - 64)) + 30) << 8;
		apple.y = ((rand() % (240 - 64)) + 30) << 8;
		while (getColor(apple.x >> 8, apple.y >> 8) || getColor((apple.x >> 8) + 1, (apple.y >> 8) + 1)) {
			apple.x = ((rand() % (400 - 64)) + 30) << 8;
			apple.y = ((rand() % (240 - 64)) + 30) << 8;
		}
		return;
	}
	apple.x = closedSet[s]->x << 8;
	apple.y = closedSet[s]->y << 8;
	return;
}
bool noCameFrom(int x, int y, int s) {
	return (!cameFrom[s][x][y].x && !cameFrom[s][x][y].y);
}
bool isCameFrom(int x, int y, int s) {
	return (cameFrom[s][x][y].x || cameFrom[s][x][y].y);
}
void showCameFrom(int s) {
	snprintf(mystring,sizeof(mystring),"%d: totalpathn: %d closedSetN: %d openSetN: %d",s,totalPathN[s],closedSetN[s],openSetN[s]);
	myprintf(mystring);
	float px = 0;
	float py = 0;
	float oldpx = 0;
	float oldpy = 0;
	int dpx = (int)px;
	int dpy = (int)py;
	while (aptMainLoop()) {
		hidScanInput();
		hidTouchRead(&touch);

		if (hidKeysDown() & KEY_SELECT) break;
		px = (float)touch.px / 312.0f;
		py = (float)touch.py / 235.0f;
		px *= 400.0f;
		py *= 240.0f;
		dpx = (int)px;
		dpy = (int)py;
		keepConsole();
		if (totalPathN[s] < 500) for (int m = totalPathN[s]; m >= 0; m--) {
			writeColor(totalPath[s][m].x,totalPath[s][m].y,colors[8]);
		}
		if (px && py) {
			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
				C3D_FrameDrawOn(target);
				C3D_TexBind(0, &spritesheet_tex);
				C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
				if (noCameFrom(dpx,dpy,s)) {
					if (isCameFrom(sanitizeX(dpx + 1),dpy,s)) dpx += 1;
					else if (isCameFrom(dpx,sanitizeY(dpy + 1),s)) dpy += 1;
					else if (isCameFrom(sanitizeX(dpx + 1),sanitizeY(dpy + 1),s)) { dpx += 1; dpy += 1; }
				}
				writeColor(dpx, dpy, colors[8]);
				writeColor(current[s].x,current[s].y,colors[8]);
				int tx = current[s].x;
				int otx;
				int ty = current[s].y;
				while (tx != 0 || ty != 0) {
					writeColor(tx,ty,colors[8]);
					otx = tx;
					tx = cameFrom[s][tx][ty].x;
					ty = cameFrom[s][otx][ty].y;
				}
				int i = 0; int tempx;
				while (isCameFrom(dpx,dpy,s) && i < 100) {
					i++;
					writeColor(cameFrom[s][dpx][dpy].x,cameFrom[s][dpx][dpy].y,colors[8]);
					writeColor(sanitizeX(cameFrom[s][dpx][dpy].x + 1),cameFrom[s][dpx][dpy].y,colors[8]);
					writeColor(sanitizeX(cameFrom[s][dpx][dpy].x + 1),sanitizeY(cameFrom[s][dpx][dpy].y + 1),colors[8]);
					writeColor(cameFrom[s][dpx][dpy].x,sanitizeY(cameFrom[s][dpx][dpy].y + 1),colors[8]);
					tempx = dpx;
					dpx = cameFrom[s][dpx][dpy].x;
					dpy = cameFrom[s][tempx][dpy].y;
				}
			C3D_FrameEnd(0);
			oldpx = px;
			oldpy = py;
		} else if (oldpx && oldpy) { //player has dropped the apple
			oldpx = 0;
			oldpy = 0;
		}
	}
}
void getFarthestCurrent(int s) {
	int ac = getBot(s);
	Path *c = closedSet[s];
	int pdis = 0;
	int myx = sprites[ac].x >> 8;
	int myy = sprites[ac].y >> 8;
	while (c != NULL) {
		if (getDist(myx,myy,c->x,c->y) > pdis) {
			bool flag = true;
			if (getColor(c->x,c->y)) { c = c->next; continue; }
			for (int i = 4; i < 8; i++) {
				if (getColor(getDirectionXTo(i,c->x,s),getDirectionYTo(i,c->y,s))) flag = false;
			}
			if (!flag) { c = c->next; continue; }
			current[s].x = c->x;
			current[s].y = c->y;
			pdis = getDist(myx,myy,c->x,c->y);
		}
		c = c->next;
	}
}
void plotMovement(int s) {
	int ac = getBot(s);
	if (totalPathN[s] > 10) return;
	if (s >= numPlayers()) {
		plotting[s] = false;
		totalPathN[s] = 0;
		return;
	}
	int tempx;
	int tempy;
	totalPathN[s] = 0;
	while ((cameFrom[s][current[s].x][current[s].y].x || cameFrom[s][current[s].x][current[s].y].y) && totalPathN[s] < 1000) {
		tempx = cameFrom[s][current[s].x][current[s].y].x;
		tempy = cameFrom[s][current[s].x][current[s].y].y;
		totalPath[s][totalPathN[s]].x = current[s].x;
		totalPath[s][totalPathN[s]].y = current[s].y;
		totalPathN[s]++;
		if (tempx == sprites[ac].x >> 8 && tempy == sprites[ac].y >> 8) break;
		current[s].x = tempx;
		current[s].y = tempy;
	}
}
/*void setCloseCurrent() {
	int i = 0;
	while (isAPlaceIMoved(closedSet[i].x,closedSet[i].y)) {
		i++;
	}
	current[s].x = closedSet[i].x;
	current[s].y = closedSet[i].y;
}*/
bool pathfindToApple(int s) {
	if (s >= numPlayers()) return false;
	int ac = getBot(s);
	u64 startPathFind = svcGetSystemTick();
	clearClosedSet(s);
	clearOpenSet(s);
	memset(gscore[s],1,sizeof(gscore[0][0][0]) * 401 * 241);
	memset(fscore[s],1,sizeof(fscore[0][0][0]) * 401 * 241);
	int x = apple.x >> 8;
	int y = apple.y >> 8;
	addOpenSet(x,y,s);
	gscore[s][x][y] = 0;
	fscore[s][x][y] = getDist(x,y,sprites[ac].x >> 8,sprites[ac].y >> 8) * epsilon;
	if (getDist(x,y,sprites[ac].x >> 8,sprites[ac].y >> 8) * epsilon < 4) return true;
	int i = 0;
	while (openSetNotEmpty(s) && i < 240 * 400) {
		if ((svcGetSystemTick() - startPathFind) / TICKS_PER_MS / (sprites[ac].speed / 3)) return false;
		if (closedSetN[s] >= 240 * 400) return false;
		if (openSetN[s] >= 240 * 400) return false;
		/*hidScanInput();
		u32 kDown = hidKeysDown();
		u32 kUp = hidKeysUp();
		if (kDown & KEY_START) return false;
		if (kDown & KEY_A && !options[3]) {
			sprites[myNum].speed = 15;
		}
		if (kUp & KEY_A && !options[3]) {
			sprites[myNum].speed = 45;
		}
		if (kDown & KEY_B && !options[4]) {
			sprites[myNum].speed = 90;
		}
		if (kUp & KEY_B && !options[4]) {
			sprites[myNum].speed = 45;
		}*/
		//keepConsole();
		i++;
		setCurrentF(s);

		/*C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			writeColor(current[s].x,current[s].y,colors[6]);
		C3D_FrameEnd(0);*/
		if (abs((sprites[ac].x >> 8) - current[s].x) <= 2 && abs((sprites[ac].y >> 8) - current[s].y) <= 2) {
			return true;
		}

		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection() && m < 4) {
			m++;
			int d = getDirection(s);
			/*snprintf(mystring,sizeof(mystring),"dist: %d",getDist(getDirectionX(d,s),getDirectionY(d,s),sprites[s].x >> 8, sprites[s].y >> 8));
			myprintf(mystring);*/
			if (!getColor(getDirectionX(d,s),getDirectionY(d,s)) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) { addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s); }
				}
				directions[d] = false;
			}
			directions[d] = false;
		}

	}
	return false;
}
void showPathToApple(int s) {
	giveUpTimer[s] = (u64)0;
	plotting[s] = false;
	int ac = getBot(s);
	if (ac >= numPlayers()) {
		plotting[s] = false;
		totalPathN[s] = 0;
		return;
	}
	sprites[ac].speed = 45;
	int tempx;
	int tempy;
	plotting[s] = false;
	totalPathN[s] = 0;
	while ((cameFrom[s][current[s].x][current[s].y].x || cameFrom[s][current[s].x][current[s].y].y) && totalPathN[s] < 240 * 400) {
		tempx = cameFrom[s][current[s].x][current[s].y].x;
		tempy = cameFrom[s][current[s].x][current[s].y].y;
		totalPath[s][totalPathN[s]].x = current[s].x;
		totalPath[s][totalPathN[s]].y = current[s].y;
		/*hidScanInput();
		u32 kDown = hidKeysDown();
		if (kDown & KEY_START) break;
		if (kDown & KEY_L) { autoPilot = false; break; }*/
		totalPathN[s]++;
		if (tempx == sprites[ac].x >> 8 && tempy == sprites[ac].y >> 8) break;
		current[s].x = tempx;
		current[s].y = tempy;
	}
	if (totalPathN[s] >= 120 * 200 - 1) {
		/*snprintf(mystring,sizeof(mystring),"wtf.. %d",isGone);
		myprintf(mystring);*/
		totalPathN[s] = 0;
		plotting[s] = false;
	}
	/*snprintf(mystring,sizeof(mystring),"totalPathN: %d",totalPathN);
	myprintf(mystring);*/
	/*while (aptMainLoop()) {
		keepConsole();
		hidScanInput();
		if (hidKeysDown() & KEY_A) break;
		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			int i = totalPathN;
			for (; i >= 0; i--) {
				if (i == totalPathN) writeColor(totalPath[i].x + 1,totalPath[i].y,colors[8]);
				else writeColor(totalPath[i].x + 1,totalPath[i].y,colors[0]);
			}
		C3D_FrameEnd(0);
	}*/
}
bool everyoneElseIsDead(int n) {
	for (int i = 0; i < numPlayers(); i++) {
		if (i != n && !sprites[i].dead) return false;
	}
	return true;
}
int getAlive() {
	//int k = 0;
	/*for (int i = 0; i < actual_bikes; i++) {
		if (sprites[i].dead || getMoveableRange(i) < 40) k++;
	}
	if (k >= actual_bikes - 1) return -1;*/
	if (everyoneElseIsDead(myNum)) return myNum;
	int r = (rand() % actual_bikes);
	//while (sprites[r].dead) r = rand() % actual_bikes;
	if (r >= actual_bikes) return myNum;
	return r;
}
void relocateApple() {
	myprintf("relocateApple()");
	keepConsole();
	apple.x = ((rand() % (400 - 64)) + 30) << 8;
	apple.y = ((rand() % (240 - 64)) + 30) << 8;
	while (getColor(apple.x >> 8, apple.y >> 8) || getColor((apple.x >> 8) + 1, (apple.y >> 8) + 1)) {
		apple.x = ((rand() % (400 - 64)) + 30) << 8;
		apple.y = ((rand() % (240 - 64)) + 30) << 8;
		while ((apple.x >> 8) % 2 || (apple.y >> 8) % 2) {
			apple.x = ((rand() % (400 - 64)) + 30) << 8;
			apple.y = ((rand() % (240 - 64)) + 30) << 8;
		}
	}
	//int n = getAlive();
	/*if (n >= 0) if (!pathfindToApple(n)) {
		getMoveableRangeApple(n);
	}*/
	for (int b = 0; b < numBots; b++) {
		int ax = apple.x >> 8;
		int ay = apple.y >> 8;
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		ax = sanitizeX(ax + 1);
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		ay = sanitizeY(ay + 1);
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		if (cameFrom[b][apple.x >> 8][ay].x && cameFrom[b][apple.x >> 8][ay].y) {
			current[b].x = apple.x >> 8;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		totalPathN[b] = 0;
		plotting[b] = false;
	}
}
//---------------------------------------------------------------------------------
void drawSprite( int x, int y, int width, int height, int image ) {
//---------------------------------------------------------------------------------
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, GPU_PRIMARY_COLOR, GPU_PRIMARY_COLOR);
    C3D_TexEnvOp(env, C3D_Both, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR);
    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
	u32 color = getColor(x,y);
	if (image < 10 && width < 100 && height < 100) if (image != 9 && color != colors[8] && color) return;
	if (strstr(sprites[image].username,"!.u") != NULL) setTextColor(HSL2RGB(rainbow,0.5,0.5));
	float left = images[image].left;
	float right = images[image].right;
	float top = images[image].top;
	float bottom = images[image].bottom;

	/*if (image < 8) {
		for (int j = 0; j < numBots; j++) {
			for (int i = totalPathN[j] - 1; i >= 0; i--) {
				if (abs(totalPath[j][i].x - (sprites[getBot(j)].x << 8)) < 2 && abs(totalPath[j][i].y - (sprites[getBot(j)].y << 8)) < 2) { myprintf("skipped."); continue; }
				if (abs(x - totalPath[j][i].x) < 2 && abs(y - totalPath[j][i].y) < 2) {
					setTextColor(0xff0000ff);
					snprintf(mystring,sizeof(mystring),"!.ryep %llu!.w",(u64)svcGetSystemTick());
					myprintf(mystring);

					current[j].x = 0;
					current[j].y = 0;
					plotting[j] = false;
					totalPathN[j] = 0;
					break;
				}
			}
		}
	}*/
	// Draw a textured quad directly
	C3D_ImmDrawBegin(GPU_TRIANGLES);
		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( left, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);


	C3D_ImmDrawEnd();

}

void overwriteSprite( int x, int y, int width, int height, int image ) {
//---------------------------------------------------------------------------------
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, GPU_PRIMARY_COLOR, GPU_PRIMARY_COLOR);
    C3D_TexEnvOp(env, C3D_Both, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR);
    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
	float left = images[image].left;
	float right = images[image].right;
	float top = images[image].top;
	float bottom = images[image].bottom;

	/*if (image < 8) {
		for (int j = 0; j < numBots; j++) {
			for (int i = totalPathN[j] - 1; i >= 0; i--) {
				if (abs(totalPath[j][i].x - (sprites[getBot(j)].x << 8)) < 2 && abs(totalPath[j][i].y - (sprites[getBot(j)].y << 8)) < 2) { myprintf("skipped."); continue; }
				if (abs(x - totalPath[j][i].x) < 2 && abs(y - totalPath[j][i].y) < 2) {
					setTextColor(0xff0000ff);
					snprintf(mystring,sizeof(mystring),"!.ryep %llu!.w",(u64)svcGetSystemTick());
					myprintf(mystring);
					current[j].x = 0;
					current[j].y = 0;
					plotting[j] = false;
					totalPathN[j] = 0;
					break;
				}
			}
		}
	}*/
	if (strstr(sprites[image].username,"!.u") != NULL) setTextColor(HSL2RGB(rainbow,0.5,0.5));
	// Draw a textured quad directly
	C3D_ImmDrawBegin(GPU_TRIANGLES);
		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( left, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);


	C3D_ImmDrawEnd();

}
static void changeApple() {
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 9);
	relocateApple();
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 66;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
}
static void moveApple() {
	int oldx = apple.x;
	int oldy = apple.y;
	relocateApple();
	drawSprite(oldx >> 8, oldy >> 8, 2, 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 77;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
	for (int b = 0; b < numBots; b++) {
		usedSpecial[b] = false;
	}
}
static void updateApple(int x, int y) {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx >> 8, oldy >> 8, 2 , 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	for (int b = 0; b < numBots; b++) {
		int ax = apple.x >> 8;
		int ay = apple.y >> 8;
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		ax = sanitizeX(ax + 1);
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		ay = sanitizeY(ay + 1);
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		if (cameFrom[b][apple.x >> 8][ay].x && cameFrom[b][apple.x >> 8][ay].y) {
			current[b].x = apple.x >> 8;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		totalPathN[b] = 0;
		plotting[b] = false;
	}
}
bool checkPath(int s) {
	int max = totalPathN[s] - 5;
	if (max < 0) max = 0;
	for (int i = totalPathN[s] - 1; i > max; i--) {
		if (!totalPath[s][i].x && !totalPath[s][i].y) continue;
		if (abs(totalPath[s][i].x - (sprites[getBot(s)].x << 8)) < 2 && abs(totalPath[s][i].y - (sprites[getBot(s)].y << 8)) < 2) { myprintf("skipped."); continue; }
		if (getColor(totalPath[s][i].x,totalPath[s][i].y)) {
			/*setTextColor(0xff0000ff);
			snprintf(mystring,sizeof(mystring),"!.ryep %llu!.w",(u64)svcGetSystemTick());
			myprintf(mystring);*/

			current[s].x = 0;
			current[s].y = 0;
			plotting[s] = false;
			totalPathN[s] = 0;
			return true;
		}
	}
	return false;
}
void showPlotMovement(int s) {
	snprintf(mystring,sizeof(mystring),"free memory: %zu",mallinfo().fordblks);
	myprintf(mystring);
	if (sprites[getBot(s)].dead) return;
	if (openSetN[s] == 0) {
		if (!usedSpecial[s]) {
			usedSpecial[s] = true;
			movingApple = true;
		} else {
			/*snprintf(mystring,sizeof(mystring),"giveuptimer: %llu < %llu",svcGetSystemTick() - giveUpTimer[s],(u64)(TICKS_PER_SEC * 30));
			myprintf(mystring);*/
			if (giveUpTimer[s] == (u64)0) {
				giveUpTimer[s] = svcGetSystemTick();
			} else if ((u64)(svcGetSystemTick() - giveUpTimer[s]) > (u64)(TICKS_PER_SEC * 30)) {
				sprites[s].dead = true;
			}
		}
	}
	plotting[s] = true;
	if (totalPathN[s] > 10) return;
	int ac = getBot(s);
	/*myprintf("calculating...");*/
	getFarthestCurrent(s);
	int tempx;
	int tempy;
	totalPathN[s] = 0;
	u64 timeUp = svcGetSystemTick();
	while ((cameFrom[s][current[s].x][current[s].y].x || cameFrom[s][current[s].x][current[s].y].y) && totalPathN[s] < 240 * 400 && svcGetSystemTick() - timeUp < TICKS_PER_SEC) {
		tempx = cameFrom[s][current[s].x][current[s].y].x;
		tempy = cameFrom[s][current[s].x][current[s].y].y;
		if (getNextColor(tempx,tempy) && tempx != sprites[ac].x >> 8 && tempy != sprites[ac].y >> 8)  {
			//myprintf("grrr");
			plotting[s] = false;
			totalPathN[s] = 0;
			return;
		}
		totalPath[s][totalPathN[s]].x = current[s].x;
		totalPath[s][totalPathN[s]].y = current[s].y;
		/*hidScanInput();
		u32 kDown = hidKeysDown();
		if (kDown & KEY_START) break;
		if (kDown & KEY_L) { autoPilot = false; break; }
		if (debugging) {
			keepConsole();

			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
				C3D_FrameDrawOn(target);
				C3D_TexBind(0, &spritesheet_tex);
				C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
				writeColor(current[s].x + 1,current[s].y + 1,colors[8]);
			C3D_FrameEnd(0);
		}*/
		totalPathN[s]++;
		if (tempx == sprites[ac].x >> 8 && tempy == sprites[ac].y >> 8) break;
		current[s].x = tempx;
		current[s].y = tempy;
	}
	if (totalPathN[s] >= 120 * 200 - 1) {
		//bool isGone = (current[s].x == 0 && current[s].y == 0);
		/*snprintf(mystring,sizeof(mystring),"wtf.. %d",isGone);
		myprintf(mystring);*/
	}
	/*snprintf(mystring,sizeof(mystring),"totalpathn: %d",totalPathN);
	myprintf(mystring);*/
}

u64 firstTimeDiff() {
	u64 smallest = frameTicks[0] + ((u64)sprites[0].speed * (u64)TICKS_PER_MS);
	for (int i = 1; i < numPlayers(); i++) {
		if (frameTicks[i] + ((u64)sprites[i].speed * (u64)TICKS_PER_MS) < smallest) {
			smallest = frameTicks[i] + ((u64)sprites[i].speed * (u64)TICKS_PER_MS);
		}
	}
	return (u64)(smallest - svcGetSystemTick());
}
u64 timeDiff(int num) {
	return (u64)(((svcGetSystemTick() - frameTicks[num]) / TICKS_PER_MS) / sprites[num].speed);
}
int livingBots() {
	int r = 0;
	for (int b = 1; b < currentBots; b++) {
		if (!sprites[b].dead) r++;
	}
	if (autoPilot && !sprites[myNum].dead) r++;
	if (r <= 0) return 1;
	return r;
}
void continuePlotting(int s) {
	//myprintf("!.bcontinuePlotting()");
	int ac = getBot(s);
	if (sprites[ac].dead) return;
	u64 startThinking = svcGetSystemTick();
	plotting[s] = true;
	if (!options[4]) sprites[ac].speed = 90;
	int x = sprites[ac].x >> 8;
	int y = sprites[ac].y >> 8;
	/*cameFrom[x][y].x = 1;
	cameFrom[x][y].y = 1;*/
	int i = 0;
	u64 thinkingTime = 12 * TICKS_PER_MS;
	thinkingTime /= livingBots();
	while (openSetNotEmpty(s) && i < 400) {
		i++;
		if (svcGetSystemTick() - startThinking > thinkingTime) {
			if (!options[4]) sprites[ac].speed = 90;
			showPlotMovement(s);
			return;
		}
		if (closedSetN[s] >= 240 * 400) {
			if (!options[4]) sprites[ac].speed = 90; 
			showPlotMovement(s);
			return;
		}
		if (openSetN[s] >= 240 * 400) {
			if (!options[4]) sprites[ac].speed = 90;
			showPlotMovement(s);
			return;
		}
		setCurrentF(s);
		if (abs((apple.x >> 8) - current[s].x) < 3 && abs((apple.y >> 8) - current[s].y) < 3) {
			sprites[ac].speed = 45;
			showPathToApple(s);
			return;
		}
		/*hidScanInput();
		u32 kDown = hidKeysDown();
		if (kDown & KEY_START) { 
			sprites[s].speed = 90;
			showPlotMovement(s);
			return;
		}
		if (kDown & KEY_L) {
			autoPilot = false;
			return;
		}*/
		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection() && m < 4) {
			m++;
			int d = getDirectionToApple(s);
			/*snprintf(mystring,sizeof(mystring),"d: %d",d);
			myprintf(mystring);
			keepConsole();*/
			if (((!getColor(getDirectionX(d,s),getDirectionY(d,s)) && !getColor(sanitizeX(getDirectionX(d,s) + 1),sanitizeY(getDirectionY(d,s) + 1)) && !(x == getDirectionX(d,s) && y == getDirectionY(d,s)))) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8] || getColor(sanitizeX(getDirectionX(d,s) + 1),sanitizeY(getDirectionY(d,s) + 1)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					/*bool cflag = false;
					for (int a = 0; a < numPlayers(); a++) {
						if (a == s) continue;
						if (abs(getDirectionX(d,s) - ((sprites[a].x + sprites[a].dx) >> 8)) < 2 && abs(getDirectionY(d,s) - ((sprites[a].y + sprites[a].dy) >> 8)) < 2) {
							//addClosedSet(getDirectionX(d,s),getDirectionY(d,s),s);
							myprintf("...");
							cflag = true;
							break;
						}
					}
					if (cflag) { directions[d] = false; continue; }*/
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							continueAddNodeToApple(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) continueAddNodeToApple(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
				}
				directions[d] = false;
			}
			directions[d] = false;
		}
	}
	if (!options[4]) sprites[ac].speed = 90;
	showPlotMovement(s);
	return;
}
void plotCourse(int s) {
	int ac = getBot(s);
	if (sprites[ac].dead) return;
	plotting[s] = false;
	clearClosedSet(s);
	clearOpenSet(s);
	memset(cameFrom[s],0,sizeof(cameFrom[0][0][0]) * 401 * 241);
	memset(totalPath[s],0,sizeof(totalPath[0][0]) * 401 * 241);
	memset(gscore[s],1,sizeof(gscore[0][0][0]) * 401 * 241);
	memset(fscore[s],1,sizeof(fscore[0][0][0]) * 401 * 241);
	int x = sprites[ac].x >> 8;
	int y = sprites[ac].y >> 8;
	addOpenSet(x,y,s);
	gscore[s][x][y] = 2;
	fscore[s][x][y] = getDist(x,y,apple.x >> 8,apple.y >> 8) * epsilon;
	if (s >= numPlayers()) { plotMovement(s); return; }
	//if (getDist(x,y,apple.x >> 8,apple.y >> 8) * epsilon < 4) { plotMovement(s); return; }
	//myprintf("!.yplotCourse()");
	int i = 0;
	u64 startThinking = svcGetSystemTick();
	u64 thinkingTime = 15 * TICKS_PER_MS;
	thinkingTime /= livingBots();
	current[s].x = x;
	current[s].y = y;
	while (openSetNotEmpty(s) && i < 240 * 400) {
		i++;
		if (svcGetSystemTick() - startThinking > thinkingTime) {
			if (!options[4]) sprites[ac].speed = 90;
			showPlotMovement(s);
			return;
		}
		if (closedSetN[s] >= 200 * 240) { 
			if (!options[4]) sprites[ac].speed = 90;
			showPlotMovement(s);
			return;
		}
		if (openSetN[s] >= 200 * 240) {
			if (!options[4]) sprites[ac].speed = 90;
			showPlotMovement(s);
			return;
		}
		setCurrentF(s);
		if (abs((apple.x >> 8) - current[s].x) < 3 && abs((apple.y >> 8) - current[s].y) < 3) {
			sprites[ac].speed = 45;
			showPathToApple(s);
			return;
		}
		/*hidScanInput();
		if (hidKeysDown() & KEY_START) { 
			sprites[s].speed = 90;
			showPlotMovement(s);
			return;
		}*/
		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection() && m < 4) {
			m++;
			int d = getDirectionToApple(s);
			/*snprintf(mystring,sizeof(mystring),"d: %d",d);
			myprintf(mystring);
			keepConsole();*/
			if (((!getColor(getDirectionX(d,s),getDirectionY(d,s)) && !getColor(sanitizeX(getDirectionX(d,s) + 1),sanitizeY(getDirectionY(d,s) + 1)) && !(x == getDirectionX(d,s) && y == getDirectionY(d,s)))) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8] || getColor(sanitizeX(getDirectionX(d,s) + 1),sanitizeY(getDirectionY(d,s) + 1)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					/*bool cflag = false;
					for (int a = 0; a < numPlayers(); a++) {
						if (a == s) continue;
						if (abs(getDirectionX(d,s) - ((sprites[a].x + sprites[a].dx) >> 8)) < 2 && abs(getDirectionY(d,s) - ((sprites[a].y + sprites[a].dy) >> 8)) < 2) {
							//addClosedSet(getDirectionX(d,s),getDirectionY(d,s),s);
							//myprintf("...");
							cflag = true;
							break;
						}
					}
					if (cflag) { directions[d] = false; continue; }*/
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							addNodeToApple(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) addNodeToApple(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
				}
				directions[d] = false;
			}
			directions[d] = false;
		}
		if (openSetN[s] == 0) break;
	}
	if (!options[4]) sprites[ac].speed = 90;
	showPlotMovement(s);
	return;
}
static void setApple(int player, int x, int y) {
	if (abs(player) > num_bikes) return;
	if (autoPilot) {
		totalPathN[0] = 0;
		plotCourse(0);
	}
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx >> 8, oldy >> 8, 2 , 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	//score[player]++;
	if (options[8]) growth[player] += sprites[player].length;
	else growth[player] += growthRate;

	if (sprites[player].length >= 120 * 200 - 1) sprites[player].length = 120 * 200 - 1;
	//sprites[player].length += growthRate;
	for (int b = 0; b < numBots; b++) {
		usedSpecial[b] = false;
	}
}
void eraseLine(int n) {
	if (erased[n]) return;
	erased[n] = true;
	int i = pathPos[n];
	int k = 0;
	while (i != currentPath[n]) {
		hidScanInput();
		if (hidKeysDown() & KEY_START) return;
		overwriteSprite(path[i][n].x >> 8, path[i][n].y >> 8, 2, 2, 9);
		k++;
		if (k > 40) {
			k = 0;
			C3D_FrameEnd(0);
			gfxFlushBuffers();
			gfxSwapBuffers();
			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
		}
		i++;
		if (i >= 120 * 200) i = 0;
	}
	overwriteSprite(path[i][n].x >> 8, path[i][n].y >> 8, 2, 2, 9);
}
static int lagMult() {
	if (num_bikes <= 4) return 1;
	int r = (num_bikes - 4) / 2;
	return r > 0 ? r : 1;
}
static void UDSResend(bool replied[], Message msg) {
	if (!uds_enabled || num_bikes <= 1) return;
	msg.sender = myNum;
	sentMsg = msg;
	ret=0;
	if (msg.sprite.speed == 77) msg.timestamp = lastScore;
	else if (msg.sprite.speed == 66) msg.timestamp = lastChange;
	else if (msg.sprite.speed == 2020) msg.timestamp = lastDeadmsg;
	else if (msg.sprite.speed == 5050) msg.timestamp = lastScreenScore;
	else msg.timestamp = lastSprite;
	if(conntype!=UDSCONTYPE_Spectator)
	{
		/*if (debugging) {
			char replies[10];
			clearString(); snprintf(mystring,sizeof(mystring),"replies: ");
			for (int i = 0; i < num_bikes; i++) {
				if (i == myNum) snprintf(replies,sizeof(replies),"-");
				else snprintf(replies,sizeof(replies),"%d",replied[i]);
				strcat(mystring,replies);
			}
			myprintf(mystring);
		}*/
		for (int i = 0; i < num_bikes; i++) {
			if (!replied[i] && i != myNum && sprites[i].node) {
				//if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"resending to... %d: %d",i,sprites[i].node); myprintf(mystring); snprintf(mystring,sizeof(mystring),"sending img: %d speed: %d node: %d",msg.sprite.image,msg.sprite.speed,msg.sprite.node); myprintf(mystring); }
				ret = udsSendTo(sprites[i].node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
				if (UDS_CHECK_SENDTO_FATALERROR(ret))
				{
					if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"Error: UDSResend() returned 0x%08x.",(unsigned int)ret); myprintf(mystring); }
				}
			}
		}
	}
}

static bool allReplied(bool replied[]) {
	for (int i = 0; i < num_bikes; i++) {
		if (!replied[i] && i != myNum) return false;
	}
	return true;
}
static int UDSDirect(int node, Message msg) {
	if (!uds_enabled || num_bikes <= 1) return 0;
	msg.sender = myNum;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		//if (debugging) { snprintf(mystring,sizeof(mystring),"direct to %d: img: %d speed: %d",node,msg.sprite.image,msg.sprite.speed); myprintf(mystring); }
		ret = udsSendTo(node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			snprintf(mystring,sizeof(mystring),"Error: UDSDirect() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			CATASTROPHIC_FAILURE = true;
			return 1;
		}
	}
	return 0;
}
bool itsATie() {
	int s = score[0];
	int winner = 0;
	for (int i = 0; i < numPlayers(); i++) {
		if (score[i] > s) { s = score[i]; winner = i; }
	}
	for (int i = 0; i < numPlayers(); i++) {
		if (score[i] == s && i != winner) return true;
	}
	return false;
}
int getHighestScore() {
	int highestScore = 0;
	if (itsATie()) return 0;
	int r = 0;
	for (int i = 0; i < numPlayers(); i++) {
		if (score[i] > highestScore) {
			highestScore = score[i];
			r = i;
		}
	}
	return r;
}
int theHighest() {
	int r = 0;
	for (int i = 0; i < numPlayers(); i++) {
		if (r < score[i]) r = score[i];
	}
	return r;
}
bool allReady() {
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) return false;
	}
	return true;
}
int notReadies() {
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) r++;
	}
	return r;
}
int getKiller(u32 color) {
	for (int i = 0; i < NUM_SPRITES; i++) {
		if (color == colors[i]) return i;
	}
	for (int i = 0; i < NUM_SPRITES; i++) {
		if (strstr(sprites[i].username,"!.u") != NULL) return i;
	}
	return 0;
}
bool hasCommonY(int num) {
	if ((sprites[num].y >> 8) % 2 || (sprites[num].x >> 8) % 2) return true;
	if ((sprites[num].y >> 8) < 2 || (sprites[num].y >> 8) > 396) return true;
	if (abs((sprites[num].y >> 8) - (apple.y >> 8)) < 3) return true;
	for (int i = 0; i < num; i++) {
		if (abs((sprites[i].y >> 8) - (sprites[num].y >> 8)) < 3) return true;
	}
	return false;
}
static void setSprites() {
	for (int b = 0; b < numBots; b++) {
		usedSpecial[b] = false;
		giveUpTimer[b] = (u64)0;
	}
	memset(path, 0, sizeof(path[0][0]) * 120 * 200 * NUM_SPRITES);
	apple.x = ((rand() % (400 - 64)) + 30) << 8;
	apple.y = ((rand() % (240 - 64)) + 30) << 8;
	while ((apple.x >> 8) % 2 || (apple.y >> 8) % 2) {
		apple.x = ((rand() % (400 - 64)) + 30) << 8;
		apple.y = ((rand() % (240 - 64)) + 30) << 8;
	}
	for(int i = 0; i < NUM_SPRITES; i++) {
		//random place and speed
		sprites[i].x = ((rand() % (400 - 64)) + 30) << 8;
		sprites[i].y = ((rand() % (240 - 64)) + 30) << 8;
		while (hasCommonY(i)) {
			sprites[i].x = ((rand() % (400 - 64)) + 30) << 8;
			sprites[i].y =((rand() % (240 - 64)) + 30) << 8;
		}
		sprites[i].hole = 0;
		sprites[i].dx = (2<<8);
		sprites[i].dy = 0;
		sprites[i].image = i;
		sprites[i].speed = 45;
		sprites[i].dead = false;
		sprites[i].diag = 0;
		sprites[i].forwards = true;


		if (i > currentBots) memset(sprites[i].username,0,sizeof(sprites[i].username));
		else if (i != 0) snprintf(sprites[i].username,sizeof(sprites[i].username),"Saad");
		path[0][i].x = sprites[i].x;
		path[0][i].y = sprites[i].y;

		if (!options[1]) sprites[i].length = 40;
		else sprites[i].length = 120 * 200 - 1;
		growth[i] = 0;
		currentPath[i] = 120 * 200 - 20;
		pathPos[i] = 120 * 200 - 21;

		if(rand() & 1)
			sprites[i].dx = -sprites[i].dx;
		if(rand() & 1)
			sprites[i].dy = -sprites[i].dy;
		if(options[0]) {
			if ((sprites[i].x >> 8) < 100) sprites[i].dx = abs(sprites[i].dx);
			if ((sprites[i].x >> 8) > 300 && sprites[i].dx) sprites[i].dx = abs(sprites[i].dx) * -1;
		}
	}
	if (options[7]) {
		apple.x = 500 << 8;
		apple.y = 500 << 8;
	}
}
void print_constatus()
{
	ret=0;
	u32 pos;
	

	//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
	ret = udsGetConnectionStatus(&constatus);
	if(R_FAILED(ret))
	{
		myprintf("udsGetConnectionStatus() returned 0x%08x.", (unsigned int)ret);
		CATASTROPHIC_FAILURE = true;
		return;
	}
	else
	{
		if (debugging) {
			myprintf("constatus:\nstatus=0x%x", (unsigned int)constatus.status);
			myprintf("1=0x%x", (unsigned int)constatus.unk_x4);
			myprintf("cur_NetworkNodeID=0x%x", (unsigned int)constatus.cur_NetworkNodeID);
			myprintf("unk_xa=0x%x", (unsigned int)constatus.unk_xa);
			for(pos=0; pos<(0x20>>2); pos++)myprintf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
			myprintf("\ntotal_nodes=0x%x", (unsigned int)constatus.total_nodes);
			myprintf("max_nodes=0x%x", (unsigned int)constatus.max_nodes);
			myprintf("node_bitmask=0x%x", (unsigned int)constatus.total_nodes);
		}
	}
}
u64 debugLastSent;
u64 debugUDSSent;
//---------------------------------------------------------------------------------
static void sceneInit(void) {
//---------------------------------------------------------------------------------
	for (int i = 0; i < 30; i++) {
		memset(consoleBuffer[i],0,sizeof(consoleBuffer[i]));
	}
	memset(path,0,sizeof(path[0][0]) * 200 * 120 * 3);
	// Load the vertex shader, create a shader program and bind it
	vshader_dvlb = DVLB_ParseFile((u32*)vshader_shbin, vshader_shbin_size);
	shaderProgramInit(&program);
	shaderProgramSetVsh(&program, &vshader_dvlb->DVLE[0]);
	C3D_BindProgram(&program);

	// Get the location of the uniforms
	uLoc_projection = shaderInstanceGetUniformLocation(program.vertexShader, "projection");


	/*textshader_dvlb = DVLB_ParseFile((u32*)textshader_shbin, textshader_shbin_len);
	shaderProgramInit(&textprogram);
	shaderProgramSetVsh(&textprogram, &textshader_dvlb->DVLE[0]);
	C3D_BindProgram(&textprogram);

	// Get the location of the uniforms
	textuLoc_projection = shaderInstanceGetUniformLocation(textprogram.vertexShader, "textprojection");*/

	// Configure attributes for use with the vertex shader
	// Attribute format and element count are ignored in immediate mode
	C3D_AttrInfo* attrInfo = C3D_GetAttrInfo();
	AttrInfo_Init(attrInfo);
	AttrInfo_AddLoader(attrInfo, 0, GPU_FLOAT, 3); // v0=position
	AttrInfo_AddLoader(attrInfo, 1, GPU_FLOAT, 2); // v2=texcoord

	// Compute the projection matrix
	// Note: we're setting top to 240 here so origin is at top left.
	Mtx_OrthoTilt(&projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0, true);


	// Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);

	unsigned char* image;
	unsigned width, height;

	lodepng_decode32(&image, &width, &height, bike_png, bike_png_size);
	u8 *gpusrc = linearAlloc(width*height*4);

	// GX_DisplayTransfer needs input buffer in linear RAM
	u8* src=image; u8 *dst=gpusrc;

	// lodepng outputs big endian rgba so we need to convert
	for(int i = 0; i<width*height; i++) {
		int r = *src++;
		int g = *src++;
		int b = *src++;
		int a = *src++;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, width*height*4);

	// Load the texture and bind it to the first texture unit
	C3D_TexInit(&spritesheet_tex, width, height, GPU_RGBA8);

	// Convert image to 3DS tiled texture format
	GX_DisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(width,height), (u32*)spritesheet_tex.data, GX_BUFFER_DIM(width,height), TEXTURE_TRANSFER_FLAGS);
	gspWaitForPPF();

	C3D_TexSetFilter(&spritesheet_tex, GPU_LINEAR, GPU_NEAREST);
	C3D_TexBind(0, &spritesheet_tex);

	lodepng_decode32(&image, &width, &height, qrcode_png, qrcode_png_size);
	gpusrc = linearAlloc(width*height*4);

	// GX_DisplayTransfer needs input buffer in linear RAM
	src=image; dst=gpusrc;

	// lodepng outputs big endian rgba so we need to convert
	for(int i = 0; i<width*height; i++) {
		int r = *src++;
		int g = *src++;
		int b = *src++;
		int a = *src++;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, width*height*4);

	// Load the texture and bind it to the first texture unit
	C3D_TexInit(&qrcode_tex, width, height, GPU_RGBA8);

	// Convert image to 3DS tiled texture format
	GX_DisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(width,height), (u32*)qrcode_tex.data, GX_BUFFER_DIM(width,height), TEXTURE_TRANSFER_FLAGS);
	gspWaitForPPF();

	C3D_TexSetFilter(&qrcode_tex, GPU_LINEAR, GPU_NEAREST);

	//C3D_TexBind(0, &qrcode_tex);
	free(image);
	linearFree(gpusrc);

	// Configure the first fragment shading substage to just pass through the texture color
	// See https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnv.xml for more insight
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, GPU_PRIMARY_COLOR, GPU_PRIMARY_COLOR);
    C3D_TexEnvOp(env, C3D_Both, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR);
    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
	


	setSprites();
	// Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
	C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);

	Mtx_OrthoTilt(&textprojection, 0.0, 320.0, 240.0, 0.0, 0.0, 1.0, true);
	int i;
	TGLP_s* glyphInfo = fontGetGlyphInfo();
	glyphSheets = malloc(sizeof(C3D_Tex)*glyphInfo->nSheets);
	for (i = 0; i < glyphInfo->nSheets; i ++)
	{
		C3D_Tex* tex = &glyphSheets[i];
		tex->data = fontGetGlyphSheetTex(i);
		tex->fmt = glyphInfo->sheetFmt;
		tex->size = glyphInfo->sheetSize;
		tex->width = glyphInfo->sheetWidth;
		tex->height = glyphInfo->sheetHeight;
		tex->param = GPU_TEXTURE_MAG_FILTER(GPU_LINEAR) | GPU_TEXTURE_MIN_FILTER(GPU_LINEAR)
			| GPU_TEXTURE_WRAP_S(GPU_CLAMP_TO_EDGE) | GPU_TEXTURE_WRAP_T(GPU_CLAMP_TO_EDGE);
	}

	// Create the text vertex array
	textVtxArray = (textVertex_s*)linearAlloc(sizeof(textVertex_s)*TEXT_VTX_ARRAY_COUNT);

	frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);


}
static void reversePath(int n) {
	Path temp;
	int start = pathPos[n];
	int end = currentPath[n];
    while (abs(start - end) > 1)
    {
        temp = path[start][n];   
        path[start][n] = path[end][n];
        path[end][n] = temp;
        start++;
        end--;
        if (start >= 120 * 200) start = 0;
        if (end < 0) end = 120 * 200 - 1;
    }

    /*int tempPath = currentPath[n];
    currentPath[n] = pathPos[n];
    pathPos[n] = tempPath;*/
    int tempPath = currentPath[n];
    sprites[n].x = path[tempPath][n].x;
    sprites[n].y = path[tempPath][n].y;
    int speed = abs(sprites[n].dx);
    if (sprites[n].dy) speed = abs(sprites[n].dy);
    tempPath--;
    if (tempPath < 0) tempPath = 240*400 - 1;
    sprites[n].dx = 0;
    sprites[n].dy = 0;
    if (path[tempPath][n].x == path[currentPath[n]][n].x) {
    	if (path[tempPath][n].y > path[currentPath[n]][n].y) sprites[n].dy = speed * -1;
    	else sprites[n].dy = speed;
    } else {
    	if (path[tempPath][n].x > path[currentPath[n]][n].x) sprites[n].dx = speed * -1;
    	else sprites[n].dx = speed;
    }
}
static void printScore() {
	if (!options[7]) {
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[0;0HScore: ");
		char scores[12];
		for (int i = 0; i < numPlayers(); i++) {
			snprintf(scores,sizeof(scores),"%s%d", textColors[i],score[i]);
			strcat(mystring,scores);
			if (i < numPlayers() - 1) { snprintf(scores,sizeof(scores)," %s- ",WHITE); strcat(mystring,scores); }
		}
		myprintf(mystring);
	} else {
		clearString();
		snprintf(mystring,sizeof(mystring),"\x1b[0;0HAlive: ");
		char living[50];
		for (int i = 0; i < numPlayers(); i++) {
			if (!sprites[i].dead) {
				memset(living,0,sizeof(living));
				snprintf(living,sizeof(living),"%s%s%s",textColors[i],sprites[i].username,WHITE);
				if (strlen(mystring) < 140) {
					strcat(mystring,living);
					if (i < actual_bikes - 1) strcat(mystring,", ");
				}
			}
		}
		myprintf(mystring);
	}
	death = dead;
	if (!death) death = dead2;
	if (sprites[myNum].dead) { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sYou are %sdead%s (%s%s%s)",WHITE,RED,WHITE,textColors[getKiller(death)],sprites[getKiller(death)].username,WHITE); myprintf(mystring); }
	else { 
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sYou are %salive%s! ",WHITE,GREEN,WHITE);
		myprintf(mystring);
	}
	if (!sprites[myNum].dead) {
		if (!options[3]) {
			clearString(); snprintf(mystring,sizeof(mystring),"\x1b[2;0HHold %s%s to move Faster.",RED,WHITE);
			myprintf(mystring);
		}
		if (!options[4]) {
			clearString(); snprintf(mystring,sizeof(mystring),"\x1b[3;0HHold %s%s to move Slower.",YELLOW,WHITE);
			myprintf(mystring);
		}
	} else {
		if (actual_bikes == 1) {
			snprintf(mystring,sizeof(mystring),"\x1b[2;0HPress %s%s to forfeit.",RED,WHITE);
			myprintf(mystring);
			myprintf("\x1b[3;0H");
		}
	}
	if (!options[5]) {
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[4;0HPress %s%s to teleport the apple once.",GREEN,WHITE);
		myprintf(mystring);
	}
	if (options[6]) {
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[5;0HPress  to go in reverse."); myprintf(mystring);
	}
	if (everyoneElseIsDead(myNum)) { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[6;0HGet %d more points!",theHighest() - score[myNum] + 1); myprintf(mystring); }
	int x = 8;
	if (options[6]) x = 9;
	for (int i = actual_bikes; i < numPlayers(); i++) {
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s has joined the game.",x + i - actual_bikes,textColors[i],sprites[i].username,WHITE);
		myprintf(mystring);
	}
	int screenScore = totalSpace;
	if (options[4]) screenScore *= 1.25;
	if (options[5]) screenScore *= 1.25;
	snprintf(mystring,sizeof(mystring),"\x1b[7;0H%sScreen Score: %d",WHITE,screenScore);
	if ((unsigned int)screenScore > highScore) snprintf(mystring,sizeof(mystring),"\x1b[7;0HScreen Score: %s%d",RAINBOW,screenScore);
	myprintf(mystring);
	if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[5;0Hpathpos: %" PRIu32 " currentpath: %" PRIu32,pathPos[myNum],currentPath[myNum]); myprintf(mystring); }
	//myprintf("\x1b[5;0Hdead: 0x%08x, 0x%08x",dead,dead2);
	//myprintf("\x1b[6;0Hnum_bikes: %d, myNum: %d",num_bikes,myNum);
	//myprintf("\x1b[7;0Hgrowth: %d length: %d (%d)",growth[myNum],sprites[myNum].length,getLength(myNum));
	//myprintf("\x1b[8;0HpathPos: %d currentPath: %d",pathPos[myNum],currentPath[myNum]);
}
/*static void drawLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, int img) {
	int w = (dx >> 8) - (sx >> 8);
	int h = (dy >> 8) - (sy >> 8);
	int x = sx;
	int y = sy;
	if (w < 0 || h < 0) { 
		x = dx;
		y = dy;
	}
	w = abs(w);
	h = abs(h);
	//drawSprite(x >> 8, y >> 8, w, h, img);
	if (w <= 2) { h = 2 << 8; w = 0; }
	else { h = 0; w = 2 << 8; }
	while (pathnum != currentPath[img]) {
		drawSprite(path[pathnum][img].x >> 8, path[pathnum][img].y >> 8, 2, 2, 9);
		drawSprite(x >> 8, y >> 8, 2, 2, img);
		path[pathnum][img].x = x;
		x += w;
		path[pathnum][img].y = y;
		y += h;
		pathnum++;
		if (pathnum >= 120 * 200) pathnum = 0;
	}
	path[pathnum][img].x = x;
	path[pathnum][img].y = y;
	drawSprite(x >> 8, y >> 8, 2, 2, img);
}*/
static void fixLength(int img) {
	int oldpathn = pathPos[img];
	int pathn = currentPath[img];
	int i = 0;
	while (getLength(img) <= sprites[img].length + 1 - growth[img] && i < 20) {
		i++;
		overwriteSprite(path[oldpathn][img].x >> 8, path[oldpathn][img].y >> 8, 2, 2, img);
		oldpathn--;
		if (oldpathn < 0) oldpathn = 120 * 200 - 1;
		pathPos[img] = oldpathn;
	}
	currentPath[img] = pathn;
	pathPos[img] = oldpathn;
	sprites[img].x = path[currentPath[img]][img].x;
	sprites[img].y = path[currentPath[img]][img].y;
}
static void finishLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, Sprite msg, int img) {
	if ((sx >> 8) == (dx >> 8) && (sy >> 8) == (dy >> 8)) {
		overwriteSprite(sy,dy,2,2,getImg(img));
		return;
	}
	if (msg.diag && sprites[img].diag) {
		if (sprites[img].diag == SOUTHWEST && msg.diag == NORTHEAST) return;
		else if (sprites[img].diag == SOUTHEAST && msg.diag == NORTHWEST) return;
		else if (sprites[img].diag == NORTHEAST && msg.diag == SOUTHWEST) return;
		else if (sprites[img].diag == NORTHWEST && msg.diag == SOUTHEAST) return;
	}
	int udx = dx >> 8;
	int udy = dy >> 8;
	int x = sx >> 8;
	int y = sy >> 8;
	int w = udx - x;
	int h = udy - y;
	if (abs(w) > 100 || abs(h) > 100) return;



	//drawSprite(x >> 8, y >> 8, w, h, img);
	int pathn = currentPath[img] - 1;
	if (pathn < 0) pathn = 120 * 200 - 1;
	int prevx = path[pathn][img].x >> 8;
	int prevy = path[pathn][img].y >> 8;
	pathn--;
	if (pathn < 0) pathn = 120 * 200 - 1;
	int prevx2 = path[pathn][img].x >> 8;
	int prevy2 = path[pathn][img].y >> 8;
	pathn = currentPath[img];
	int i = 0;
	if (x != udx && y != udy) {
		int tx, ty;
		if (w < 0) tx = -2;
		else tx = 2;
		if (h < 0) ty = -2;
		else ty = 2;
		if ((prevx - prevx2 > 0 && w > 0) || (prevx - prevx2 < 0 && w < 0) || (prevy - prevy2 > 0 && h > 0) || (prevy - prevy2 < 0 && h < 0)) {//draw
			if (x != udx && y != udy && (sprites[img].x + sprites[img].dx) >> 8 != udx && (sprites[img].y + sprites[img].dy) >> 8 != udy) {
				if (msg.diag || sprites[img].diag) { //they are going diagonal or have been going diagonal...
					if (!sprites[img].diag && msg.diag) {
						if (debugging) myprintf("not diag to diag");
						while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x >> 8; y = path[pathn][img].y >> 8; }
						i = 0;
						currentPath[img] = pathn;
						while ((x != udx || y != udy) && i < 20) {
							i++;
							x += tx;
							overwriteSprite(x,y,2,2,img);
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x << 8;
							path[pathn][img].y = y << 8;
							if (x == udx && y == udy) break;
							y += ty;
							overwriteSprite(x,y,2,2,img);
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x << 8;
							path[pathn][img].y = y << 8;
						}
						currentPath[img] = pathn;
					} else if (sprites[img].diag && !msg.diag) {
						if (debugging) myprintf("diag to not diag");
						while (x != udx && y != udy && i < 20) { i++; overwriteSprite(x,y,2,2,9); path[pathn][img].x = 500 << 8; path[pathn][img].y = 500 << 8; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x >> 8; y = path[pathn][img].y >> 8; }
						i = 0;
						currentPath[img] = pathn;
						if (x == udx) while (y != udy && i < 20) { i++; overwriteSprite(x,y,2,2,img); y += ty; pathn++; if (pathn >= 120 * 200) pathn = 0; path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; }
						else if (y == udy) while (x != udx && i < 20) { i++; overwriteSprite(x,y,2,2,img); x += tx; pathn++; if (pathn >= 120 * 200) pathn = 0;  path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; }
						currentPath[img] = pathn;
					}
					else {
						if (debugging) myprintf("diag to diag");
						while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x >> 8; y = path[pathn][img].y >> 8; }
						if (udx - x < 0) tx = -2;
						else tx = 2;
						if (udy - y < 0) ty = -2;
						else ty = 2;
						i = 0;
						currentPath[img] = pathn;
						while ((x != udx || y != udy) && i < 20) {
							i++;
							x += tx;
							overwriteSprite(x,y,2,2,img);
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x << 8;
							path[pathn][img].y = y << 8;
							if (x == udx && y == udy) break;
							y += ty;
							overwriteSprite(x,y,2,2,img);
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x << 8;
							path[pathn][img].y = y << 8;
						}
						currentPath[img] = pathn;
					}
				} else { //They are further than where they were, and are not in line with their previous line.
					if (debugging) myprintf("further than where they were, not in line with previous line");
					if (prevx == prevx2) {
						if (debugging) myprintf("prevx == prevx2");
						while (y != udy && i < 20) { //first branch. draw the y
							i++;
							overwriteSprite(x,y,2,2,img);
							y += ty;
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x << 8;
							path[pathn][img].y = y << 8;
						}
						i = 0;
						while (x != udx && i < 20) { //second branch. draw the x
							i++;
							overwriteSprite(x,y,2,2,img);
							x += tx;
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x << 8;
							path[pathn][img].y = y << 8;
						}
					} else if (prevy == prevy2) {
						if (debugging) myprintf("prevy == prevy2");
						while (x != udx && i < 20) { //first branch. draw the x
							i++;
							overwriteSprite(x,y,2,2,img);
							x += tx;
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x << 8;
							path[pathn][img].y = y << 8;
						}
						i = 0;
						while (y != udy && i < 20) { //second branch. draw the y
							i++;
							overwriteSprite(x,y,2,2,img);
							y += ty;
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x << 8;
							path[pathn][img].y = y << 8;
						}
					}
				}
				currentPath[img] = pathn;
				i = 0;
				sprites[img].x = path[currentPath[img]][img].x;
				sprites[img].y = path[currentPath[img]][img].y;
				return;
			}

		} 
		else { //erase
			if (debugging) myprintf("!!!!");
			if (msg.diag || sprites[img].diag) { //they are going diagonal or have been going diagonal...
				if (!sprites[img].diag && msg.diag) {
					if (debugging) myprintf("slow not diag to diag");
					if (prevx == prevx2) ty *= -1;
					else if (prevy == prevy2) tx *= -1;
					while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x >> 8; y = path[pathn][img].y >> 8; }
					i = 0;
					currentPath[img] = pathn;
					while ((x != udx || y != udy) && i < 20) {
						i++;
						x += tx;
						overwriteSprite(x,y,2,2,img);
						pathn++;
						if (pathn >= 120 * 200) pathn = 0;
						path[pathn][img].x = x << 8;
						path[pathn][img].y = y << 8;
						if (x == udx && y == udy) break;
						y += ty;
						overwriteSprite(x,y,2,2,img);
						pathn++;
						if (pathn >= 120 * 200) pathn = 0;
						path[pathn][img].x = x << 8;
						path[pathn][img].y = y << 8;
					}
					currentPath[img] = pathn;
				} else if (sprites[img].diag && !msg.diag) {
					if (debugging) myprintf("slow diag to not diag");
					while ((x != udx && y != udy) && i < 20) {
						i++;
						overwriteSprite(x,y,2,2,9);
						pathn--;
						if (pathn < 0) pathn = 120 * 200 - 1;
						x = path[pathn][img].x >> 8;
						y = path[pathn][img].y >> 8;
						path[pathn][img].x = 500 << 8;
						path[pathn][img].y = 500 << 8;
					}
					i = 0;
					path[pathn][img].x = x << 8;
					path[pathn][img].y = y << 8;
					if (x == udx) while (y != udy && i < 20) { i++; overwriteSprite(x,y,2,2,img); y += ty; pathn++; if (pathn >= 120 * 200) pathn = 0; path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; }
					else if (y == udy) while (x != udx && i < 20) { i++; overwriteSprite(x,y,2,2,img); x += tx; pathn++; if (pathn >= 120 * 200) pathn = 0; path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; }
					currentPath[img] = pathn;
				}
				else {
					if (debugging) myprintf("slow diag to diag");
					if (msg.diag == SOUTHEAST) {
						tx = 2;
						ty = 2;
					} else if (msg.diag == SOUTHWEST) {
						tx = -2;
						ty = 2;
					} else if (msg.diag == NORTHWEST) {
						tx = -2;
						ty = -2;
					} else if (msg.diag == NORTHEAST) {
						tx = 2;
						ty = -2;
					}
					while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x >> 8; y = path[pathn][img].y >> 8; }
					if (udx - x < 0) tx = -2;
					else tx = 2;
					if (udy - y < 0) ty = -2;
					else ty = 2;
					i = 0;
					currentPath[img] = pathn;
					while ((x != udx || y != udy) && i < 20) {
						i++;
						x += tx;
						overwriteSprite(x,y,2,2,img);
						pathn++;
						if (pathn >= 120 * 200) pathn = 0;
						path[pathn][img].x = x << 8;
						path[pathn][img].y = y << 8;
						if (x == udx && y == udy) break;
						y += ty;
						overwriteSprite(x,y,2,2,img);
						pathn++;
						if (pathn >= 120 * 200) pathn = 0;
						path[pathn][img].x = x << 8;
						path[pathn][img].y = y << 8;
					}
					currentPath[img] = pathn;
				}
			}
			else if (prevx == prevx2) {
				while ((path[pathn][img].y >> 8) != udy && i < 20) { i++; drawSprite(path[pathn][img].x >> 8,path[pathn][img].y >> 8,2,2,9); path[pathn][img].x = 500 << 8; path[pathn][img].y = 500 << 8; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; }
				x = path[pathn][img].x >> 8;
				y = path[pathn][img].y >> 8;
				i = 0;
				overwriteSprite(x,y,2,2,img);
				while ((path[pathn][img].x >> 8) != udx && i < 20) { i++; x += tx; pathn++; overwriteSprite(x,y,2,2,getAndDecImg(img)); path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] >= 120 * 200) currentPath[img] = 0; if (pathn >= 120 * 200) pathn = 0; }
				//if (pathn == currentPath[img]) currentPath[img]++;
				if (currentPath[img] >= 120 * 200) currentPath[img] = 0;
			}
			else if (prevy == prevy2) {
				while ((path[pathn][img].x >> 8) != udx && i < 20) { i++; overwriteSprite(path[pathn][img].x >> 8,path[pathn][img].y >> 8,2,2,9); path[pathn][img].x = 500 << 8; path[pathn][img].y = 500 << 8; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; }
				x = path[pathn][img].x >> 8;
				y = path[pathn][img].y >> 8;
				i = 0;
				drawSprite(x,y,2,2,img);
				while ((path[pathn][img].y >> 8) != udy && i < 20) { i++; y += ty; overwriteSprite(x,y,2,2,getAndDecImg(img)); pathn++; path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] >= 120 * 200) currentPath[img] = 0; if (pathn >= 120 * 200) pathn = 0; }
				//if (pathn == currentPath[img]) currentPath[img]++;
				if (currentPath[img] >= 120 * 200) currentPath[img] = 0;
			} else if (sprites[img].diag) {
				if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"%sYEP%s",RED,WHITE); myprintf(mystring); }
			}
			overwriteSprite(dx,dy,2,2,getAndDecImg(img));
		}
		sprites[img].x = path[currentPath[img]][img].x;
		sprites[img].y = path[currentPath[img]][img].y;
	}


	if (w == 0) { 
		if (h < 0) h = -2; 
		else h = 2; 
		w = 0; 
	}
	else { 
		h = 0; 
		if (w < 0) w = -2; 
		else w = 2; 
	}


	dx = dx >> 8;
	dy = dy >> 8;
	if ((udx - x > 0 && sprites[img].dx >> 8 < 0) || (udx - x < 0 && sprites[img].dx >> 8 > 0) || (udy - y < 0 && sprites[img].dy >> 8 > 0) || (udy - y > 0 && sprites[img].dy >> 8 < 0)) { //Erase overshoot.
		i = 0;
		if (udx == x) { 
			if (abs(udy - y) > 2) {
				while (path[pathn][img].y >> 8 != udy && i < 20) { i++; drawSprite(path[pathn][img].x >> 8, path[pathn][img].y >> 8, 2, 2, 9); path[pathn][img].x = 500 << 8; path[pathn][img].y = 500 << 8; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; } 
				//drawSprite(path[pathn][img].x >> 8, path[pathn][img].y >> 8, 2, 2, 9); 
				i = 0;
				currentPath[img] = pathn; 
				//growth[img] += i;
				int oldpathn = pathPos[img]; //fix the length we removed
				while (getLength(img) <= sprites[img].length + 1 - growth[img] && i < 20) {
					i++;
					overwriteSprite(path[oldpathn][img].x >> 8, path[oldpathn][img].y >> 8, 2, 2, img);
					oldpathn--;
					if (oldpathn < 0) oldpathn = 120 * 200 - 1;
					pathPos[img] = oldpathn;
				}
				overwriteSprite(udx, udy, 2, 2, img);
				sprites[img].x = path[currentPath[img]][img].x;
				sprites[img].y = path[currentPath[img]][img].y;
				return; 
			}
		}
		else if (udy == y) { 
			if (abs(udx - x) > 2) {
				while (path[pathn][img].x >> 8 != udx && i < 20) { i++; drawSprite(path[pathn][img].x >> 8, path[pathn][img].y >> 8, 2, 2, 9); path[pathn][img].x = 500 << 8; path[pathn][img].y = 500 << 8; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; } 
				//drawSprite(path[pathn][img].x >> 8, path[pathn][img].y >> 8, 2, 2, 9); 
				currentPath[img] = pathn; 
				//growth[img] += i; 
				i = 0;
				int oldpathn = pathPos[img]; //fix the length we removed
				while (getLength(img) <= sprites[img].length + 1 - growth[img] && i < 20) {
					i++;
					overwriteSprite(path[oldpathn][img].x >> 8, path[oldpathn][img].y >> 8, 2, 2, img);
					oldpathn--;
					if (oldpathn < 0) oldpathn = 120 * 200 - 1;
					pathPos[img] = oldpathn;
				}
				overwriteSprite(udx, udy, 2, 2, img);
				sprites[img].x = path[currentPath[img]][img].x;
				sprites[img].y = path[currentPath[img]][img].y;
				return; 
			}
		}
	} else { //draw undershoot
		i = 0;
		int oldpathn = pathPos[img];
		if (udx == x) { 
			overwriteSprite(x, y, 2, 2, img); 
			while (y != udy && i < 20) { 
				i++; 
				y += h; 
				overwriteSprite(x, y, 2, 2, img); 
				overwriteSprite(path[oldpathn][img].x >> 8, path[oldpathn][img].y >> 8, 2, 2, 9); 
				pathn++; 
				oldpathn++; 
				if (pathn >= 120 * 200) pathn = 0; 
				if (oldpathn >= 120 * 200) oldpathn = 0; 
				path[pathn][img].x = x << 8;
				path[pathn][img].y = y << 8;
			} 
			pathPos[img] = oldpathn; 
			currentPath[img] = pathn; 
			sprites[img].x = path[currentPath[img]][img].x; 
			sprites[img].y = path[currentPath[img]][img].y; 
		}
		else if (udy == y) { 
			overwriteSprite(x, y, 2, 2, img); 
			while (x != udx && i < 20) { 
				i++; 
				x += w; 
				overwriteSprite(x, y, 2, 2, img); 
				overwriteSprite(path[oldpathn][img].x >> 8, path[oldpathn][img].y >> 8, 2, 2, 9); 
				pathn++; 
				oldpathn++; 
				if (pathn >= 120 * 200) pathn = 0; 
				if (oldpathn >= 120 * 200) oldpathn = 0; 
				path[pathn][img].x = x << 8; 
				path[pathn][img].y = y << 8; 
			} 
			pathPos[img] = oldpathn; 
			currentPath[img] = pathn; 
			sprites[img].x = path[currentPath[img]][img].x; 
			sprites[img].y = path[currentPath[img]][img].y; 
		}
	}
	if (x != udx && y != udy && ((sprites[img].x + sprites[img].dx) >> 8 != udx || (sprites[img].y + sprites[img].dy) >> 8 != udy)) return;
	i = 0;

	if (w != 0 && h != 0) return;
	//Now fill in shortcomings.
	int c = rand() % 9;
	if (udx == prevx && udy == prevy) {
		if (debugging) {
			while (c == img) c = rand() % 9;
			clearString(); snprintf(mystring,sizeof(mystring),"%s%d .. %d%s",textColors[c],udx,udy,WHITE);
			myprintf(mystring);
			drawSprite(sx >> 8,sy >> 8,2,2,c);
			drawSprite(dx, dy, 2, 2, c);
		}
		sprites[img].x = path[currentPath[img]][img].x;
		sprites[img].y = path[currentPath[img]][img].y;
		return;
	}
	if (debugging) {
		while (c == img) c = rand() % 9;
		clearString(); snprintf(mystring,sizeof(mystring),"%sok.%s",textColors[c],WHITE);
		myprintf(mystring);
	}
	//drawSprite(sx,sy,2,2,c);
	if (msg.diag || sprites[img].diag) {
		int tx = 2;
		int ty = 2;
		if (msg.diag == SOUTHEAST) {
			tx = 2;
			ty = 2;
		} else if (msg.diag == SOUTHWEST) {
			tx = -2;
			ty = 2;
		} else if (msg.diag == NORTHWEST) {
			tx = -2;
			ty = -2;
		} else if (msg.diag == NORTHEAST) {
			tx = 2;
			ty = -2;
		}
		while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x >> 8; y = path[pathn][img].y >> 8; }
		if (udx - x < 0) tx = -2;
		else tx = 2;
		if (udy - y < 0) ty = -2;
		else ty = 2;
		i = 0;
		currentPath[img] = pathn;
		while ((x != udx || y != udy) && i < 20) {
			i++;
			x += tx;
			overwriteSprite(x,y,2,2,img);
			pathn++;
			if (pathn >= 120 * 200) pathn = 0;
			path[pathn][img].x = x << 8;
			path[pathn][img].y = y << 8;
			if (x == udx && y == udy) break;
			y += ty;
			overwriteSprite(x,y,2,2,img);
			pathn++;
			if (pathn >= 120 * 200) pathn = 0;
			path[pathn][img].x = x << 8;
			path[pathn][img].y = y << 8;
		}
		currentPath[img] = pathn;
		return;
	}
	while ((x != dx || y != dy) && (i < 4)) {
		i++;	

		path[currentPath[img]][img].y = (y << 8);
		path[currentPath[img]][img].x = (x << 8);
		overwriteSprite(x, y, 2, 2, getAndDecImg(img));
		currentPath[img]++;
		if (currentPath[img] >= 120 * 200) currentPath[img] = 0;
		x += w;
		
		y += h;
		
	}
	path[currentPath[img]][img].y = (y << 8);
	path[currentPath[img]][img].x = (x << 8);
	sprites[img].x = path[currentPath[img]][img].x;
	sprites[img].y = path[currentPath[img]][img].y;
}
static void eraseOvershoot(Sprite sprite) {
	int img = sprite.image;
	int cx = path[currentPath[img]][img].x >> 8;
	int cy = path[currentPath[img]][img].y >> 8;
	int udx = sprite.x >> 8;
	int udy = sprite.y >> 8;
	if (udx == cx && udy == cy) { fixLength(img); return; }
	if ((path[currentPath[img]][img].x + sprites[img].dx) >> 8 == udx && (path[currentPath[img]][img].y + sprites[img].dy) >> 8 == udy) { finishLine(currentPath[img],sprites[img].x,sprites[img].y,sprite.x,sprite.y,sprite,img); fixLength(img); return; }
	if ((udx - cx > 0 && sprite.dx > 0) || (udx - cx < 0 && sprite.dx < 0) || (udy - cy < 0 && sprite.dy < 0) || (udy - cy > 0 && sprite.dy > 0)) { 
		finishLine(currentPath[img],sprites[img].x,sprites[img].y,sprite.x,sprite.y,sprite,img);
		fixLength(img); 
		return;
	}
	if (udx != cx && udy != cy) { finishLine(currentPath[img],sprites[img].x,sprites[img].y,sprite.x,sprite.y,sprite,img); fixLength(img); return; }
	/*snprintf(mystring,sizeof(mystring),"%d %d != %d %d",cx,cy,udx,udy);
	myprintf(mystring);*/
	int pathn = currentPath[img];
	int oldpathn = pathPos[img];
	int i = 0;
	while (((path[pathn][img].x >> 8) != udx || (path[pathn][img].y >> 8) != udy) && pathn != pathPos[img] && i < 40) {
		i++;
		drawSprite(path[pathn][img].x >> 8, path[pathn][img].y >> 8, 2, 2, 9);
		pathn--;
		overwriteSprite(path[oldpathn][img].x >> 8, path[oldpathn][img].y >> 8, 2, 2, img);
		oldpathn--;
		if (pathn < 0) pathn = 120 * 200 - 1;
		if (oldpathn < 0) oldpathn = 120 * 200 - 1;
	}
	currentPath[img] = pathn;
	pathPos[img] = oldpathn;
	i = 0;
	while (getLength(img) <= sprites[img].length + 1 - growth[img] && i < 20) {
		i++;
		overwriteSprite(path[oldpathn][img].x >> 8, path[oldpathn][img].y >> 8, 2, 2, img);
		oldpathn--;
		if (oldpathn < 0) oldpathn = 120 * 200 - 1;
		pathPos[img] = oldpathn;
	}
	currentPath[img] = pathn;
	pathPos[img] = oldpathn;
	sprites[img].x = path[currentPath[img]][img].x;
	sprites[img].y = path[currentPath[img]][img].y;
}
static void gameOptions() {
	myconsoleClear();
	char onOrOff[5];
	char selectedColor[5];
	int selected = 0;
	u32 kDown;
	int load = 0;
	u64 lastLoad = svcGetSystemTick();
	while(aptMainLoop()) {
		keepConsole();
		for (int i = 0; i < numOptions; i++) {
			if (options[i]) snprintf(onOrOff,sizeof(onOrOff),RAINBOW);
			else snprintf(onOrOff,sizeof(onOrOff),BLACK);
			if (selected == i) snprintf(selectedColor,sizeof(selectedColor),YELLOW);
			else snprintf(selectedColor,sizeof(selectedColor),WHITE);
			snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s%s%s",i,onOrOff,loading[load],selectedColor,optionNames[i],WHITE);
			myprintf(mystring);
		}
		if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
		if (load > 7) load = 0;
		hidScanInput();
		kDown = hidKeysDown();
		if (kDown & KEY_DUP || kDown & KEY_CPAD_UP) selected--;
		else if (kDown & KEY_DDOWN || kDown & KEY_CPAD_DOWN) selected++;
		if (selected >= numOptions) selected = 0;
		else if (selected < 0) selected = numOptions - 1;
		if (kDown & KEY_A) {
			if (options[selected]) options[selected] = false;
			else options[selected] = true;
		}
		if (kDown & KEY_START || kDown & KEY_SELECT || kDown & KEY_B) break;
	}
}
//---------------------------------------------------------------------------------
static void moveSprites() {
//---------------------------------------------------------------------------------
	int i;
	for(i = 0; i < numPlayers(); i++) {
		if (sprites[i].dead || !timeDiff(i)) continue;
		frameTicks[i] = svcGetSystemTick();
		int oldxdx = sprites[i].dx;
		int oldydy = sprites[i].dy;
		int bc = toBot(i);
		if ((i > 0 && i != myNum && i < currentBots) || (autoPilot && i == myNum)) {
			if (totalPathN[bc] < 2 && plotting[bc]) showPlotMovement(bc);
			if (totalPathN[bc] > 0) {
				if (sprites[i].x >> 8 == totalPath[bc][totalPathN[bc]].x && sprites[i].y >> 8 == totalPath[bc][totalPathN[bc]].y) totalPathN[bc]--;
				else if (!totalPath[bc][totalPathN[bc]].x && !totalPath[bc][totalPathN[bc]].y) totalPathN[bc]--;
				int myx = totalPath[bc][totalPathN[bc]].x - (sprites[i].x >> 8);
				int myy = totalPath[bc][totalPathN[bc]].y - (sprites[i].y >> 8);
				if (myx == 0 && myy == 0) {
					totalPathN[bc]--;
					myx = totalPath[bc][totalPathN[bc]].x - (sprites[i].x >> 8);
					myy = totalPath[bc][totalPathN[bc]].y - (sprites[i].y >> 8);
				}
				if (myx == 0 || myy == 0) {
					if (myx == 2) {
						sprites[i].dy = 0;
						sprites[i].dx = bikeSpeed;
					} else if (myx == -2) { sprites[i].dy = 0; sprites[i].dx = -1 * bikeSpeed; }
					else if (myy == 2) { sprites[i].dx = 0; sprites[i].dy = bikeSpeed; }
					else if (myy == -2) { sprites[i].dx = 0; sprites[i].dy = -1 * bikeSpeed; }
				}
				else {
					if (abs(myx) != 2 && abs(myy) != 2) { 
						//sprites[i].speed = 90;
						if (abs(myx) >= 390) {
							sprites[i].dy = 0;
							if (sprites[i].x >> 8 <= 2) sprites[i].dx = bikeSpeed * -1;
							else if (sprites[i].x >> 8 >= 398) sprites[i].dx = bikeSpeed;
						} else if (abs(myy) >= 230) {
							if (sprites[i].y >> 8 <= 2) sprites[i].dy = bikeSpeed * -1;
							else if (sprites[i].y >> 8 >= 237) sprites[i].dy = bikeSpeed;
						} else {
							/*snprintf(mystring,sizeof(mystring),"myx: %d myy: %d",myx,myy);
							myprintf(mystring);*/
							plotting[bc] = false;
							totalPathN[bc] = 0;
						}
					}
				}
			}
			/*if (sprites[i].dy == oldydy * -1 || sprites[i].dx == oldxdx * -1) {
				sprites[i].dy = oldydy;
				sprites[i].dx = oldxdx;
			}*/
		}
		if (options[10] && (i == myNum || (i < currentBots && actual_bikes == 1)) && rand() % 80 == 79) {
			sprites[i].hole = (rand() % 3) + 1;
			hole = sprites[i].hole;
			if (i == myNum) {
				msg.sprite = sprites[i];
				lastSprite = svcGetSystemTick();
				UDSSend(msg);
			}
		}
		else if (sprites[i].hole > 0) {
			sprites[i].hole--;
		}
		if (cheats && !autoPilot) {
			int ox = (sprites[myNum].x + sprites[myNum].dx) >> 8;
			int oy = (sprites[myNum].y + sprites[myNum].dy) >> 8;
			if (ox >= 400) ox = 0;
			else if (ox < 0) ox = 396;
			if (oy >= 240) oy = 0;
			else if (oy < 0) oy = 236;
			if (getColor(ox,oy) != colors[8] && getColor(ox,oy)) {
				if (sprites[myNum].dx > 0) nextMove = MOVE_RIGHT;
				else if(sprites[myNum].dx < 0) nextMove = MOVE_LEFT;
				else if (sprites[myNum].dy > 0) nextMove = MOVE_DOWN;
				else if (sprites[myNum].dy < 0) nextMove = MOVE_UP;
				ox = sprites[myNum].x >> 8;
				oy = sprites[myNum].y >> 8;
				int x = ox;
				int y = oy;
				x += 2;
				if (x > 398) x = 0;
				if (!sprites[myNum].dx && getColor(x,y) == 0) {
					sprites[myNum].diag = 0;
					sprites[myNum].dx = 2 << 8;
					sprites[myNum].dy = 0;
					lastSprite = svcGetSystemTick();
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				} 
				x = ox;
				y += 2;
				if (y > 238) y = 0;
				if (!sprites[myNum].dy && getColor(x,y) == 0) {
					sprites[myNum].diag = 0;
					sprites[myNum].dx = 0;
					sprites[myNum].dy = 2 << 8;
					lastSprite = svcGetSystemTick();
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				}
				y = oy;
				x -= 2;
				if (x < 0) x = 396;
				if (!sprites[myNum].dx && getColor(x,y) == 0) {
					sprites[myNum].diag = 0;
					sprites[myNum].dx = -1 * 2 << 8;
					sprites[myNum].dy = 0;
					lastSprite = svcGetSystemTick();
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				}
				x = ox;
				y -= 2;
				if (y < 0) y = 236;
				if (!sprites[myNum].dy && getColor(x,y) == 0) {
					sprites[myNum].diag = 0;
					sprites[myNum].dx = 0;
					sprites[myNum].dy = -1 * 2 << 8;
					lastSprite = svcGetSystemTick();
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				}
			}
		}
		if (i != myNum && sprites[i].diag && !autoPilot) { //auto diagonals for cpad
			if (sprites[i].diag == NORTHEAST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx * -1;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy * -1;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == SOUTHEAST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == SOUTHWEST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx * -1;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy * -1;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == NORTHWEST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy;
					sprites[i].dy = 0;
				}
			}
		}
		if ((i > 0 && i != myNum && i < currentBots) || (autoPilot && i == myNum)) if (plotting[bc]) {
			int dx = sprites[i].dx >> 8;
			int dy = sprites[i].dy >> 8;
			int x, y, h;
			int odx = 0;
			int ody = 0;
			x = sprites[i].x >> 8;
			y = sprites[i].y >> 8;
			h = currentPath[i] - 1;
			//char offsets[20];
			int o = 0;
			while ((dx != odx || dy != ody) && h != pathPos[i] && o < 40) {
				o++;
				h--;
				if (h < 0) h = 120 * 200 - 1;
				odx = dx;
				ody = dy;
				dx = x - (path[h][i].x >> 8);
				dy = y - (path[h][i].y >> 8);
				x = path[h][i].x >> 8;
				y = path[h][i].y >> 8;
			}
			h--;
			if (h < 0) h = 120 * 200 - 1;
			int nexth = h;
			o = 0;
			while (h != currentPath[i] && o < 40) {
				o++;
				x = path[h][i].x >> 8;
				y = path[h][i].y >> 8;
				nexth = h + 1;
				if (nexth >= 120 * 200) nexth = 0;
				dx = (path[nexth][i].x >> 8) - x;
				dy = (path[nexth][i].y >> 8) - y;
				//snprintf(mystring,sizeof(mystring),"%d (%d %d):",currentPath[myNum] - h, dx, dy);
				for (int k = 0; k < 8; k++) {
					if (dx == 0 && getDirectionXTo(k,x,bc) == x) continue;
					if (dy == 0 && getDirectionYTo(k,y,bc) == y) continue;
					if (getDist(getDirectionXTo(k,x,i),getDirectionYTo(k,y,i),sanitizeX(x + dx),sanitizeY(y + dy)) <= 4) if (!getColor(getDirectionXTo(k,x,bc),getDirectionYTo(k,y,bc))) {
						//snprintf(offsets,sizeof(offsets)," %d",i);
						//strcat(mystring,offsets);
						//writeColor(getDirectionXTo(i,x,myNum) + 1,getDirectionYTo(i,y,myNum) + 1,colors[8]);
						cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].x = sanitizeX(getDirectionXTo(k,x,bc) + dx);
						cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].y = sanitizeY(getDirectionYTo(k,y,bc) + dy);		
					}
				}
				//myprintf(mystring);
				h++;
				if (h >= 120 * 200) h = 0;
			}
			x = sprites[i].x >> 8;
			y = sprites[i].y >> 8;
			odx = dx;
			ody = dy;
			dx = sprites[i].dx >> 8;
			dy = sprites[i].dy >> 8;
			/*snprintf(mystring,sizeof(mystring),"dx: %d dy: %d odx: %d ody: %d",dx,dy,odx,ody);
			myprintf(mystring);*/
			if (odx != dx || ody != dy) { //we are taking a turn, so we need to fix the corner's cameFrom.
				if (dx == 0) {
					cameFrom[bc][sanitizeX(x + odx)][sanitizeY(y - dy)].x = sanitizeX(x + odx);
					cameFrom[bc][sanitizeX(x + odx)][sanitizeY(y - dy)].y = y;
				} else if (dy == 0) {
					cameFrom[bc][sanitizeX(x - dx)][sanitizeY(y + ody)].x = x;
					cameFrom[bc][sanitizeX(x - dx)][sanitizeY(y + ody)].y = sanitizeY(y + ody);
				}
			}
			//snprintf(mystring,sizeof(mystring),"%d (%d %d):",currentPath[myNum] - h, dx, dy);
			for (int k = 0; k < 8; k++) {
				if (dx == 0 && getDirectionXTo(k,x,i) == x) continue;
				if (dy == 0 && getDirectionYTo(k,y,i) == y) continue;
				if (getDist(getDirectionXTo(k,x,bc),getDirectionYTo(k,y,bc),sanitizeX(x + dx),sanitizeY(y + dy)) <= 4) if (!getColor(getDirectionXTo(k,x,bc),getDirectionYTo(k,y,bc))) {
					//snprintf(offsets,sizeof(offsets)," %d",i);
					//strcat(mystring,offsets);
					//writeColor(getDirectionXTo(i,x,myNum) + 1,getDirectionYTo(i,y,myNum) + 1,colors[8]);
					cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].x = sanitizeX(getDirectionXTo(k,x,bc) + dx);
					cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].y = sanitizeY(getDirectionYTo(k,y,bc) + dy);		
				}
			}
			//myprintf(mystring);
			//addPlacesIMoved(x,y);
			cameFrom[bc][x][y].x = 0;
			cameFrom[bc][x][y].y = 0;
		}
		sprites[i].x += sprites[i].dx;
		sprites[i].y += sprites[i].dy;
		//if (autoPilot) previousSteps += 2;
		if ((i > 0 && i < currentBots) || (autoPilot && i == myNum)) if (plotting[bc]) {
			int x = sprites[i].x >> 8;
			int y = sprites[i].y >> 8;
			//addPlacesIMoved(x,y);
			cameFrom[bc][x][y].x = 0;
			cameFrom[bc][x][y].y = 0;
			for (int k = 4; k < 8; k++) {
				cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].x = x;
				cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].y = y;
			}
		}
		if (autoPilot) {
			if (oldBotSpeed != sprites[myNum].speed || sprites[myNum].dy != oldydy || sprites[myNum].dx != oldxdx) {
				oldBotSpeed = sprites[myNum].speed;
				msg.sprite = sprites[myNum];
				lastSprite = svcGetSystemTick();
				memset(replySprite,0,sizeof(replySprite[0]) * 10);
				UDSSend(msg);
			}
		}
		//if (sprites[i].x >> 8 != totalPath[totalPathN].x && sprites[i].y >> 8 != totalPath[totalPathN].y) totalPathN--;
		/*bool deadflag = false;
		for (int i = 0; i < actual_bikes; i++) {
			if (i != myNum && !sprites[i].dead && (sprites[i].x >> 8) + (sprites[i].dx >> 8) == (sprites[myNum].x >> 8) && (sprites[i].y >> 8) + (sprites[i].dy >> 8) == (sprites[myNum].y >> 8)) {
				deadflag = true;
				break;
			}
		}
		if (deadflag) {
			sprites[myNum].dead = true;
			msg.sprite = sprites[myNum];
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick();
			UDSSend(msg);
		}*/
		if((sprites[i].x >> 8) < 2) sprites[i].x = 396 << 8; //screen wrap
		else if (sprites[i].x > (396 << 8)) sprites[i].x = 2 << 8;

		if((sprites[i].y >> 8) < 2) sprites[i].y = 236 << 8; //screen wrap
		else if (sprites[i].y > (236 << 8)) sprites[i].y = 2 << 8;

		/*while (getLength(i) > sprites[i].length) { //fix length: erase
			drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
			pathPos[i]++;
		}*/
		if (growth[i]) growth[i]--;
		else if (getLength(i) >= sprites[i].length) { //move tail
			drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
			pathPos[i]++;
		}
		currentPath[i]++;
		if (pathPos[i] >= 200 * 120) pathPos[i] = 0;
		if (currentPath[i] >= 200 * 120) currentPath[i] = 0;
		path[currentPath[i]][i].x = sprites[i].x;
		path[currentPath[i]][i].y = sprites[i].y;
		if (((i > 0 && i < currentBots) || i == myNum) && !sprites[i].dead) { //check my snake getting apple and collisions
			u32 color1 = getColor(sprites[i].x >> 8, sprites[i].y >> 8);
			u32 color2 = getColor((sprites[i].x >> 8) + 1, (sprites[i].y >> 8) + 1);
			if (abs((sprites[i].x >> 8) - (apple.x >> 8)) <= 2 && abs((sprites[i].y >> 8) - (apple.y >> 8)) <= 2) {
				if (svcGetSystemTick() - lastApple > TICKS_PER_MS * 15 * 6 * lagMult()) {
					lastApple = svcGetSystemTick();
					score[i]++;
					if (options[8]) {
						growth[i] += sprites[i].length;
						sprites[i].length *= 2;
					}
					else {
						growth[i] += growthRate;
						sprites[i].length += growthRate;
					}
					if (sprites[i].length >= 120 * 200) sprites[i].length = 120 * 200 - 1;
					if (i == myNum) {
						memset(replyScore,0,sizeof(replyScore[0]) * 10);
						flash = svcGetSystemTick();
						moveApple();
					}
					else { 
						changeApple(); 
						for (int b = 0; b < numBots; b++) {
							usedSpecial[b] = false;
						}
		 			}
					if ((i < currentBots) || (i == myNum && autoPilot)) { plotting[bc] = false; totalPathN[bc] = 0; }
					if (debugging) myprintf("Got apple.");
				}
			}
			else if (getLength(i) < 5) {} //don't die if game just started
			else if ((color1 != colors[8] && color2 != colors[8]) && (color1 > 0 || color2 > 0) && !ignoreDeath) {
				dead = color1;
				dead2 = color2;
				lastDead = i;
				sprites[i].dead = true;
				if (debugging) showCameFrom(i);
				if (i == myNum) {
					msg.sprite = sprites[i];
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					lastSprite = svcGetSystemTick();
					UDSSend(msg); //dead
				}
				if (options[9]) { 
					eraseLine(i); 
					for (int b = 0; b < currentBots; b++) {
						if (!sprites[b].dead) { //a snake died and disappeared, so the bots need to rescan the area.
							totalPathN[b] = 0;
							plotting[b] = false;
						}
					}
				}
			}
			else overwriteSprite(sprites[i].x >> 8, sprites[i].y >> 8, 2, 2, i);
			ignoreDeath = false;
		}
	}
}

static void drawWall(int img) {
	drawSprite(2,2,2,236,img);
	drawSprite(2,2,394,2,img);
	drawSprite(396,2,2,236,img);
	drawSprite(2,236,396,2,img);
}
static void drawPoint(int img) {
	drawSprite(0,0,2,239,img);
	drawSprite(0,0,399,2,img);
	drawSprite(398,0,2,238,img);
	drawSprite(0,238,399,2,img);
}
//---------------------------------------------------------------------------------
static void sceneRender(void) {
//---------------------------------------------------------------------------------
	int i;
	// Update the uniforms
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);

	if (flash != 0) {
		if (svcGetSystemTick() - flash < TICKS_PER_MS * 30 * 7) drawPoint(8);
		else { flash = 0; drawPoint(9); }
		if (options[0]) drawWall(7);
	}
	if (!options[7] && !getColor(apple.x >> 8, apple.y >> 8)) drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	for(i = 0; i < numPlayers(); i++) {
		if (i < numPlayers()) { 
			if (!sprites[i].dead) drawSprite( sprites[i].x >> 8, sprites[i].y >> 8, 2, 2, getImg(i));
			if ((path[currentPath[i]][i].x >> 8) != (sprites[i].x >> 8) || (path[currentPath[i]][i].y >> 8) != (sprites[i].y >> 8)) {
				currentPath[i]++;
				path[currentPath[i]][i].x = sprites[i].x;
				path[currentPath[i]][i].y = sprites[i].y;
			}
		}
		int x = path[pathPos[i]][i].x >> 8;
		int y = path[pathPos[i]][i].y >> 8;
		for (int b = 0; b < currentBots; b++) {
			if (!inOpenSet(x,y,b)) {
				for (int k = 4; k < 8; k++) {
					int nx = getDirectionXTo(k,x,b);
					int ny = getDirectionYTo(k,y,b);
					if (!getColor(nx,ny) && cameFrom[b][nx][ny].x && cameFrom[b][nx][ny].y) {
						addOpenSet(x,y,b);
						cameFrom[b][x][y].x = nx;
						cameFrom[b][x][y].y = ny;
						break;
					}
				}
			}
		}
		drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
	}

}
//---------------------------------------------------------------------------------
static void sceneExit(void) {
//---------------------------------------------------------------------------------

	// Free the shader program
	free(glyphSheets);
	shaderProgramFree(&program);
	DVLB_Free(vshader_dvlb);
	//shaderProgramFree(&textprogram);
	//DVLB_Free(textshader_dvlb);
}
static SwkbdCallbackResult wrongName(void* user, const char** ppMessage, const char* text, size_t textlen)
{

	if(strstr(text,"\x1b["))
	{
		*ppMessage = "Nope.";
		return SWKBD_CALLBACK_CONTINUE;
	}
	if(strstr(text, "!."))
	{
		*ppMessage = "Nice try.";
		return SWKBD_CALLBACK_CONTINUE;
	}
	if (strstr(text, "host"))
	{
		*ppMessage = "Just no.";
		return SWKBD_CALLBACK_CONTINUE;
	}

	return SWKBD_CALLBACK_OK;
}
void setHighscore(u32 score) {
	highScore = score;
	snprintf(mystring,sizeof(mystring),"%sNew High Score: %" PRIu32,RAINBOW,highScore);
	myprintf(mystring);
	msg.sprite = sprites[myNum];
	msg.sprite.speed = 3030;
	msg.sprite.dx = highScore;
	lastHighscore = svcGetSystemTick();
	memset(replyHighscore,0,sizeof(replyHighscore[0]) * 10);
	UDSSend(msg);
	writeUsername();
}
void uds_test()
{
	memset(overwriteName,0,sizeof(overwriteName));
	ret=0;
	con_type=0;


	for (int i = 0; i < NUM_SPRITES; i++) {
		memset(sprites[i].username,0,sizeof(sprites[i].username));
	}
	u8 data_channel = 1;
	udsNetworkStruct networkstruct;
	udsNetworkScanInfo *networks = NULL;
	udsNetworkScanInfo *network = NULL;
	size_t total_networks = 0;

	u32 recv_buffer_size = UDS_DEFAULT_RECVBUFSIZE;
	u32 wlancommID = 0x783a9dab;//Unique ID, change this to your own.
	char *passphrase = "dandewsudssnake.2.2 saadistheman";//Change this passphrase to your own. The input you use for the passphrase doesn't matter since it's a raw buffer.

	conntype = UDSCONTYPE_Client;

	size_t actual_size;
	u32 tmp=0;
	u32 pos;

	u8 appdata[0x14] = {0x69, 0x8a, 0x05, 0x5c};

	char tmpstr[256];

	strncpy((char*)&appdata[4], "Test appdata.", sizeof(appdata)-1);

	//myprintf("Successfully initialized.\n");

	size_t tmpbuf_size = 0x4000;
	u32 *tmpbuf = malloc(tmpbuf_size);
	if(tmpbuf==NULL)
	{
		myprintf("Failed to allocate tmpbuf for beacon data.\n");
		return;
	}
	int hosting = 0;
	int readyToJoin = 0;

	//gspWaitForVBlank();
	//snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sg %sy %sb %sm %sc %sdg %so %sp",GREEN, YELLOW, BLUE, MAGENTA, CYAN, DARKGREEN, ORANGE, PINK);
	//myprintf(mystring);
	sdmcInit();
	clearString(); 
	snprintf(mystring,sizeof(mystring),"Version %s",VERSION);
	myprintf(mystring);
	myprintf("\x1b[2;0HHold  to host"); myprintf("Press  to scan for a host."); myprintf("Press  to change name."); myprintf("Press + to reset high score."); myprintf("Press SELECT for game modes."); myprintf("Press START to exit."); myprintf(" ");
	importUsername();
	bool ignoreB = false;
	while (aptMainLoop()) {
		hidScanInput();
		u32 kDown = hidKeysDown();
		u32 kHeld = hidKeysHeld();
		u32 kUp = hidKeysUp();
 
		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			if (qrcode) C3D_TexBind(0, &qrcode_tex);
			else C3D_TexBind(0, &spritesheet_tex);
			//if (kDown & KEY_L || kHeld & KEY_L) writeColor(10,10,HSL2RGB(rainbow,0.5,0.5));
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			if (qrcode) drawSprite(72,0,240,240,11);
			else drawSprite(72,0,256,256,10);
		C3D_FrameEnd(0);

		keepConsole();



		//myprintf("Version %s\n\nHold A to host\nPress B to scan for a host.\nPress Y to change name.\nPress X for QRCode to latest release.\nPress START to exit.\n",VERSION);
		// Respond to user input
		if (kDown & KEY_START) return;
		if (kDown & KEY_SELECT) { gameOptions(); myconsoleClear(); ignoreB = true; snprintf(mystring,sizeof(mystring),"Version %s",VERSION); myprintf(mystring); myprintf("\x1b[2;0HHold  to host"); myprintf("Press  to scan for a host."); myprintf("Press  to change name."); myprintf("Press + to reset high score."); myprintf("Press SELECT for game modes."); myprintf("Press START to exit."); myprintf(" "); importUsername(); }
		if (kDown & KEY_L) { debugging = true; myprintf("Debugging turned on."); }
		if (kDown & KEY_A) { hosting = 1; break; }
		if (kHeld & KEY_R && kDown & KEY_X) { cheats = true; myprintf("Move the apple with touchscreen!"); snprintf(overwriteName,sizeof(overwriteName),"Cheater"); }
		if (kHeld & KEY_R && kDown & KEY_Y) { highScore = 0; writeUsername(); myprintf("Reset high score."); }
		else if (kDown & KEY_X) qrcode = true;
		else if (kDown & KEY_Y) {
			if (!cheats) {
				static SwkbdState swkbd;
				static char mybuf[50];
				static SwkbdStatusData swkbdStatus;
				static SwkbdLearningData swkbdLearning;
				SwkbdButton button = SWKBD_BUTTON_NONE;
				swkbdInit(&swkbd, SWKBD_TYPE_NORMAL, 3, -1);
				swkbdSetValidation(&swkbd, SWKBD_NOTEMPTY_NOTBLANK, 0, 0);
				swkbdSetFilterCallback(&swkbd, wrongName, NULL);
				swkbdSetInitialText(&swkbd, mybuf);
				swkbdSetHintText(&swkbd, "Please enter your name");
				swkbdSetButton(&swkbd, SWKBD_BUTTON_LEFT, "Cancel", false);
				
				swkbdSetButton(&swkbd, SWKBD_BUTTON_RIGHT, "Done", true);
				swkbdSetFeatures(&swkbd, SWKBD_PREDICTIVE_INPUT);
				SwkbdDictWord words[21];
				swkbdSetDictWord(&words[0], "put table back", "┬──┬ ノ( ゜-゜ノ)");
				swkbdSetDictWord(&words[1], "shrug", "¯\\_(ツ)_/¯");
				swkbdSetDictWord(&words[2], "flip", "(ノ°□°）ノ ~ ┻━┻");
				swkbdSetDictWord(&words[3], "happy", "( ﾟヮﾟ)");
				swkbdSetDictWord(&words[4], "glasses", "(-■_■)");
				swkbdSetDictWord(&words[5], "kiss", "(づ￣ ³￣)づ");
				swkbdSetDictWord(&words[6], "fuck", "凸(-_-)凸");
				swkbdSetDictWord(&words[7], "pig", "（´・ω・ `）");
				swkbdSetDictWord(&words[8], "sun", "");
				swkbdSetDictWord(&words[9], "cloud", "");
				swkbdSetDictWord(&words[10], "umbrella", "");
				swkbdSetDictWord(&words[11], "telephone", "☎");
				swkbdSetDictWord(&words[12], "spade", "♠");
				swkbdSetDictWord(&words[13], "heart", "♥");
				swkbdSetDictWord(&words[14], "clubs", "♣");
				swkbdSetDictWord(&words[15], "diamond", "♦");
				swkbdSetDictWord(&words[16], "happyface", "");
				swkbdSetDictWord(&words[17], "angry", "");
				swkbdSetDictWord(&words[18], "sad", "");
				swkbdSetDictWord(&words[19], "sleepy", "");
				swkbdSetDictWord(&words[20], "snowman", "");

				swkbdSetDictionary(&swkbd, words, sizeof(words)/sizeof(SwkbdDictWord));
				static bool reload = false;
				swkbdSetStatusData(&swkbd, &swkbdStatus, reload, true);
				swkbdSetLearningData(&swkbd, &swkbdLearning, reload, true);
				reload = true;
				button = swkbdInputText(&swkbd, mybuf, sizeof(mybuf));
				if (button != SWKBD_BUTTON_NONE && strlen(mybuf) > 0) { 
					memset(overwriteName,0,sizeof(overwriteName));
					strncpy(overwriteName,mybuf,sizeof(overwriteName));
					clearString(); snprintf(mystring,sizeof(mystring),"Welcome, %s",overwriteName);
					myprintf(mystring);
					writeUsername();
				} else {
					memset(overwriteName,0,sizeof(overwriteName));
					myprintf("Name set to default.");
					writeUsername();
				}
			} else myprintf("You can't change your name with cheats enabled!");
		}
		else if (!ignoreB) if((kDown & KEY_B) || (kHeld & KEY_B)) {
			myprintf("Scanning...");
			while(aptMainLoop()) {
				//gspWaitForVBlank();
				hidScanInput();

				keepConsole();
				kHeld = hidKeysHeld();
				kDown = hidKeysDown();
				if (!(kHeld & KEY_B)) break;
				total_networks = 0;
				memset(tmpbuf, 0, sizeof(tmpbuf_size));
				ret = udsScanBeacons(tmpbuf, tmpbuf_size, &networks, &total_networks, wlancommID, 0, NULL, false);

				if(total_networks) { network = &networks[0]; readyToJoin = 1; break; }
			}
			if (total_networks == 1) {
				if (network->network.total_nodes >= 8) {
					readyToJoin = false;
					myprintf("Only one room was found and it was full!");
					myprintf("Press A to go back to main menu");
					while(aptMainLoop()) {
						//gspWaitForVBlank();
						hidScanInput();
						keepConsole();
						kDown = hidKeysDown();
						if (kDown & KEY_A) break;
						if (kDown & KEY_START) return;
					}
				}
			}
			if (total_networks > 1) {
				int selected = 0;
				myconsoleClear();
				myprintf("Please choost a host by 3ds name:");
				while(aptMainLoop()) {
					//gspWaitForVBlank();
	
					network = &networks[0];
					keepConsole();
					if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"network: total nodes = %u.\n", (unsigned int)network->network.total_nodes); myprintf(mystring); }


					for(pos=0; pos<total_networks; pos++)
					{
						network = &networks[pos];
						if(!udsCheckNodeInfoInitialized(&network->nodes[0]))continue;
						if (network->network.total_nodes >= 8) continue;
						memset(tmpstr, 0, sizeof(tmpstr));

						ret = udsGetNodeInfoUsername(&network->nodes[0], tmpstr);
						if(R_FAILED(ret))
						{
							clearString(); snprintf(mystring,sizeof(mystring),"udsGetNodeInfoUsername() returned 0x%08x.\n", (unsigned int)ret);
							myprintf(mystring);
							CATASTROPHIC_FAILURE = true;
							free(networks);
							return;
						}

						if (pos == selected) { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s\n", (unsigned int)(pos + 1), YELLOW, tmpstr, WHITE); myprintf(mystring); }
						else { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s",(unsigned int)(pos + 1),tmpstr); myprintf(mystring); }
					}
					hidScanInput();
					kDown = hidKeysDown();
					if ((kDown & KEY_DUP) || (kDown & KEY_CPAD_UP)) selected--;
					if ((kDown & KEY_DDOWN) || (kDown & KEY_CPAD_DOWN)) selected++;
					if (kDown & KEY_A) { network = &networks[selected]; break; }
					if (selected < 0 || selected >= total_networks) selected = 0;
				}
			}
			myconsoleClear();
			if (readyToJoin) break;
			else { snprintf(mystring,sizeof(mystring),"Version %s",VERSION); myprintf(mystring); myprintf("\x1b[2;0HHold  to host"); myprintf("Press  to scan for a host."); myprintf("Press  to change name."); myprintf("Press + to reset high score."); myprintf("Press SELECT for game modes."); myprintf("Press START to exit."); myprintf(" "); importUsername(); }
		}
		if (kUp & KEY_B) ignoreB = false;

	}
	if(total_networks && !hosting)
	{

		if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"network: total nodes = %u.\n", (unsigned int)network->network.total_nodes); myprintf(mystring); }


		for(pos=0; pos<NUM_SPRITES; pos++)
		{
			if(!udsCheckNodeInfoInitialized(&network->nodes[pos]))continue;

			memset(tmpstr, 0, sizeof(tmpstr));

			ret = udsGetNodeInfoUsername(&network->nodes[pos], tmpstr);
			if(R_FAILED(ret))
			{
				clearString(); snprintf(mystring,sizeof(mystring),"udsGetNodeInfoUsername() returned 0x%08x.\n", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				free(networks);
				return;
			}

			if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"node%u username: %s\n", (unsigned int)pos, tmpstr); myprintf(mystring); }
		}

		for(pos=0; pos<10; pos++)
		{
			ret = udsConnectNetwork(&network->network, passphrase, strlen(passphrase)+1, &bindctx, UDS_BROADCAST_NETWORKNODEID, conntype, data_channel, recv_buffer_size);
			if(R_FAILED(ret))
			{
				clearString(); snprintf(mystring,sizeof(mystring),"udsConnectNetwork() returned 0x%08x.\n", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				return;
			}
			else
			{
				break;
			}
		}

		free(networks);

		if(pos==10)return;

		if (debugging) myprintf("Connected.\n");


		tmp = 0;
		ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
		if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"udsGetChannel() returned 0x%08x. channel = %u.\n", (unsigned int)ret, (unsigned int)tmp); myprintf(mystring); }
		if(R_FAILED(ret))
		{
			CATASTROPHIC_FAILURE = true;
			return;
		}
		con_type = 1;
		
	}
	if (hosting)
	{
		if (uds_enabled) {
			udsGenerateDefaultNetworkStruct(&networkstruct, wlancommID, 0, 8); //only have room for 8 players.

			myprintf("Creating the network...");
			ret = udsCreateNetwork(&networkstruct, passphrase, strlen(passphrase)+1, &bindctx, data_channel, recv_buffer_size);
			if(R_FAILED(ret))
			{
				clearString(); snprintf(mystring,sizeof(mystring),"udsCreateNetwork() returned 0x%08x.\n", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				return;
			}

			tmp = 0;
			ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
			if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"udsGetChannel() returned 0x%08x. channel = %u.\n", (unsigned int)ret, (unsigned int)tmp); myprintf(mystring); }
			if(R_FAILED(ret))
			{
				udsDestroyNetwork();
				udsUnbind(&bindctx);
				CATASTROPHIC_FAILURE = true;
				return;
			}
		}
		con_type = 0;
		myNum = 0;
	}
	free(tmpbuf);
	tmpbuf = NULL;
	tmpbuf_size = UDS_DATAFRAME_MAXSIZE;
	tmpbuf = malloc(tmpbuf_size);
	if(tmpbuf==NULL)
	{
		myprintf("Failed to allocate tmpbuf for receiving data.");

		CATASTROPHIC_FAILURE = true;
		if (uds_enabled) {
			if(con_type)
			{
				udsDestroyNetwork();
			}
			else
			{
				udsDisconnectNetwork();
			}
			udsUnbind(&bindctx);
		}
		return;
	}
	if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
	{
		if (debugging) myprintf("Constatus event signaled.");
		ret=0;
		u32 pos;
		

		//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
		ret = udsGetConnectionStatus(&constatus);
		if(R_FAILED(ret))
		{
			clearString(); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			CATASTROPHIC_FAILURE = true;
			return;
		}
		else
		{
			if (debugging) {
				clearString(); snprintf(mystring,sizeof(mystring),"constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
				myprintf(mystring);
				clearString(); snprintf(mystring,sizeof(mystring),"1=0x%x\n", (unsigned int)constatus.unk_x4);
				myprintf(mystring);
				clearString(); snprintf(mystring,sizeof(mystring),"cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
				myprintf(mystring);
				clearString(); snprintf(mystring,sizeof(mystring),"unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
				myprintf(mystring);
				for(pos=0; pos<(0x20>>2); pos++) { clearString(); snprintf(mystring,sizeof(mystring),"%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]); myprintf(mystring); } 
				clearString(); snprintf(mystring,sizeof(mystring),"\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
				myprintf(mystring);
				clearString(); snprintf(mystring,sizeof(mystring),"max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
				myprintf(mystring);
				clearString(); snprintf(mystring,sizeof(mystring),"node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
				myprintf(mystring);
			}
			myNode = constatus.cur_NetworkNodeID;
			sprites[myNum].node = myNode;
			memset(tmpstr, 0, sizeof(tmpstr));
			ret = udsGetNodeInformation(constatus.cur_NetworkNodeID,&tmpnode);
			ret = udsGetNodeInfoUsername(&tmpnode,tmpstr);
			if (strlen(overwriteName) == 0) strncpy(myName,tmpstr,sizeof(myName));
			else strncpy(myName,overwriteName,sizeof(myName));

			if (!hosting) {
				currentBots = 1;
				myNum = constatus.total_nodes - 1;
				num_bikes = constatus.total_nodes;

				setSprites();
				if (debugging) myprintf("Sending request to join...");
				sprites[myNum].speed = 1111;
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 1111;
				UDSSend(msg);
				memset(replySprite,0,sizeof(replySprite[0]) * 10);
				lastSprite = svcGetSystemTick();
				while(aptMainLoop()) {
					hidScanInput();
					keepConsole();
					if (hidKeysDown() & KEY_START) { myprintf("ENDING..."); CATASTROPHIC_FAILURE = true; return; }
					if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
						if (debugging) myprintf("Resending request...");
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						sprites[myNum].node = myNode;
						msg.sprite = sprites[myNum]; 
						msg.sprite.speed = 1111; 
						lastSprite = svcGetSystemTick();
						UDSSend(msg);
					}
					memset(tmpbuf, 0, tmpbuf_size);
					actual_size = 0;
					src_NetworkNodeID = 0;
					if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
					if(R_FAILED(ret))
					{
						clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
						myprintf(mystring);
						replay = false;
						CATASTROPHIC_FAILURE = true;
						return;
					}
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"speed: %d image: %d myNum: %d\n",msg.sprite.speed, msg.sprite.image, myNum); myprintf(mystring); }
						if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; sprites[myNum] = msg.sprite; sprites[myNum].node = myNode; msg.sprite = sprites[myNum]; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; memset(replySprite,0,sizeof(replySprite[0]) * 10); break; } //joined game in score screen
						else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].dead = true; sprites[myNum].node = myNode; sprites[myNum].speed = 45; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); break; } // joined game in progress
						else if(msg.sprite.speed == 1211 && msg.sprite.image == myNum) break;
					}
				}
			}
		}

	}

	C3D_TexBind(0, &spritesheet_tex);
	//myprintf("Press A to stop data transfer.\n");
	char quitName[50];
	memset(quitName,0,sizeof(quitName));
	C3D_TexBind(0, &spritesheet_tex);
	while (replay) {
		debugHold = false;
		errorQuit = 0;
		if (num_bikes < 1) num_bikes = 1;
		for (int i = 0; i < numPlayers(); i++) {
			score[i] = 0;
		}
		if (!inGame) setSprites();
		if (con_type == 0) { //hosting, wait for connection
			hidScanInput();
			u32 kDown = hidKeysDown();
			u32 kUp = hidKeysUp();
			u32 kHeld = hidKeysHeld();
			myconsoleClear();
			if (!connectionEstablished) {
				myprintf("Waiting for connection...");
				myprintf("Let go of A to play by yourself.");
			}
			while ((kHeld & KEY_A) && !(kUp & KEY_A)) {
				keepConsole();
				hidScanInput();

				kHeld = hidKeysHeld();
				kDown = hidKeysDown();
				kUp = hidKeysUp();
				if(kDown & KEY_START) {
					udsDisconnectNetwork();
					udsUnbind(&bindctx);
					return;
				}
				if (kUp & KEY_A) break;
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					setSprites();
					connectionEstablished = true;
					
					ret = udsGetConnectionStatus(&constatus);
					ret = udsGetNodeInformation(0x1,&tmpnode);
					memset(sprites[0].username,0,sizeof(sprites[0].username));
					udsGetNodeInfoUsername(&tmpnode,sprites[0].username);
					ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
					if (constatus.total_nodes >= num_bikes) {
						memset(sprites[num_bikes].username,0,sizeof(sprites[num_bikes].username));
						udsGetNodeInfoUsername(&tmpnode,sprites[num_bikes].username);
						sprites[num_bikes].node = constatus.total_nodes;
						if (debugging) {
							clearString(); snprintf(mystring,sizeof(mystring),"constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"1=0x%x\n", (unsigned int)constatus.unk_x4);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
							myprintf(mystring);
							for(pos=0; pos<(0x20>>2); pos++) { clearString(); snprintf(mystring,sizeof(mystring),"%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]); myprintf(mystring); }
							clearString(); snprintf(mystring,sizeof(mystring),"\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
							myprintf(mystring);
						}
						currentBots = 1;
						clearString(); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s\n",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
						myprintf(mystring);
						num_bikes = constatus.total_nodes;
					}
					break;
				}
			}
			int i = 0;
			ret = 0;
			if (debugging) myprintf("Sending bike information");
			bool redo = true;
			lastSprite = svcGetSystemTick();
			lastChange = svcGetSystemTick();
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			memset(replyChange,0,sizeof(replyChange[0]) * 10);
			int load = 0;
			u64 lastLoad = svcGetSystemTick();
			while (redo && num_bikes > 1) {
				snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sPreparing room...",loading[load]);
				myprintf(mystring);
				if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
				if (load > 7) load = 0;
				keepConsole();
				for (i = 0; i < num_bikes; i++) {
					snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sPreparing room...",loading[load]);
					myprintf(mystring);
					if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
					if (load > 7) load = 0;
					keepConsole();
					gspWaitForVBlank();
					msg.sprite = sprites[i];
					UDSResend(replySprite,msg);
				}
				if (!allReplied(replySprite)) lastSprite = svcGetSystemTick();
				if (!allReplied(replyChange)) lastChange = svcGetSystemTick();
				msg.sprite.image = 0;
				msg.sprite.speed = 66;
				msg.sprite.x = apple.x;
				msg.sprite.y = apple.y;
				msg.sprite.dx = optionsToInt();
				UDSResend(replyChange,msg);
				while(aptMainLoop()) {
					snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sPreparing room...",loading[load]);
					myprintf(mystring);
					if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
					if (load > 7) load = 0;
					keepConsole();
					hidScanInput();
					u32 kDown = hidKeysDown();
					if (kDown & KEY_START) {
						CATASTROPHIC_FAILURE = true;
						return;
					}
					memset(tmpbuf, 0, tmpbuf_size);
					actual_size = 0;
					src_NetworkNodeID = 0;

					if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
					{
						u32 pos;
						

						//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
						ret = udsGetConnectionStatus(&constatus);
						if(R_FAILED(ret))
						{
							clearString(); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
							myprintf(mystring);
							CATASTROPHIC_FAILURE = true;
							return;
						}
						else
						{
							if (constatus.total_nodes >= num_bikes) {
								if (debugging) {
									clearString(); snprintf(mystring,sizeof(mystring),"constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
									myprintf(mystring);
									clearString(); snprintf(mystring,sizeof(mystring),"1=0x%x\n", (unsigned int)constatus.unk_x4);
									myprintf(mystring);
									clearString(); snprintf(mystring,sizeof(mystring),"cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
									myprintf(mystring);
									clearString(); snprintf(mystring,sizeof(mystring),"unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
									myprintf(mystring);
									for(pos=0; pos<(0x20>>2); pos++) { clearString(); snprintf(mystring,sizeof(mystring),"%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]); myprintf(mystring); }
									clearString(); snprintf(mystring,sizeof(mystring),"\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
									myprintf(mystring);
									clearString(); snprintf(mystring,sizeof(mystring),"max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
									myprintf(mystring);
									clearString(); snprintf(mystring,sizeof(mystring),"node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
									myprintf(mystring);
								}
								ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
								if (constatus.total_nodes >= num_bikes) {
									memset(sprites[num_bikes].username,0,sizeof(sprites[num_bikes].username));
									udsGetNodeInfoUsername(&tmpnode,sprites[num_bikes].username);
									if (!sprites[num_bikes].node) sprites[num_bikes].node = constatus.total_nodes;
									connectionEstablished = true;
									currentBots = 1;
									clearString(); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s\n",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
									myprintf(mystring);
								}
							} else {
								myprintf("Lost one!");
							}
							num_bikes = constatus.total_nodes;

						}
					}
					if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
					if(R_FAILED(ret))
					{
						clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
						myprintf(mystring);
						CATASTROPHIC_FAILURE = true;
						return;
					}
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"speed: %d image: %d\n",msg.sprite.speed, msg.sprite.image); myprintf(mystring); }
						if (msg.sprite.speed == 100) replySprite[msg.sender] = true;
						else if (msg.sprite.speed == 777) {} //ignore
						else if (msg.sprite.speed == 123) {} //ignore
						else if (msg.sprite.speed == 66) replyChange[msg.sender] = true;
						else if (msg.sprite.speed == 1111) { if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"Accepting request to join...(%d)\n",msg.sender); myprintf(mystring); } sprites[msg.sender].node = msg.sprite.node; replyChange[msg.sender] = false; replySprite[msg.sender] = false; sprites[msg.sender].speed = 1211; msg.sprite = sprites[msg.sender]; UDSSend(msg); } 
						else if (msg.sprite.speed == 999) { CATASTROPHIC_FAILURE = true; return; } //player quit
					}
					if (allReplied(replySprite) && allReplied(replyChange)) {
						if (debugging) myprintf("Starting game...");
						redo = false;
						msg.sprite = sprites[myNum];
						msg.sprite.image = 0;
						msg.sprite.speed = 101;
						UDSSend(msg);
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						lastSprite = svcGetSystemTick();
						wakeup = true;
						break;
					} else if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 30 * lagMult()) {
						break;
					} else if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
						break;
					}
				}
				gspWaitForVBlank();
			}
			gspWaitForVBlank();
		} else if (!inGame) { //guest connection
			if (debugging) myprintf("\x1b[0;0HReceiving bike information...\n");
			keepConsole();
			clearString();
			myprintf(mystring);
			memset(replySprite,true,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick();
			int oldspeed = 0;
			int load = 0;
			u64 lastLoad = svcGetSystemTick();
			while(aptMainLoop()) {
				snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sLoading...",loading[load]);
				myprintf(mystring);
				snprintf(mystring,sizeof(mystring),"\x1b[1;0HYou are %s%s%s!",textColors[myNum],colorNames[myNum],WHITE);
				myprintf(mystring);
				if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
				if (load > 7) load = 0;
				keepConsole();
				hidScanInput();
				u32 kDown = hidKeysDown();
				if (kDown & KEY_START) {
					return;
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
			
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					u32 pos;
					

					//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
					ret = udsGetConnectionStatus(&constatus);
					if(R_FAILED(ret))
					{
						clearString(); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
						myprintf(mystring);
						CATASTROPHIC_FAILURE = true;
						return;
					}
					else
					{
						if (debugging) {
							clearString(); snprintf(mystring,sizeof(mystring),"constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"1=0x%x\n", (unsigned int)constatus.unk_x4);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
							myprintf(mystring);
							for(pos=0; pos<(0x20>>2); pos++) { clearString(); snprintf(mystring,sizeof(mystring),"%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]); myprintf(mystring); }
							clearString(); snprintf(mystring,sizeof(mystring),"\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
							myprintf(mystring);
							clearString(); snprintf(mystring,sizeof(mystring),"node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
							myprintf(mystring);
						}
						if (!hosting) {
							currentBots = 1;
							myNum = constatus.cur_NetworkNodeID - 1;
							num_bikes = constatus.total_nodes;
							sprites[myNum].image = myNum;
							sprites[myNum].node = myNode;
							memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
							strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
							msg.sprite = sprites[myNum];
							msg.sprite.speed = 1111;
							UDSDirect(1,msg);
						}
					}
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
				//myprintf("tmpbuf_size: 0x%08x (0x%08x)\n",tmpbuf_size,sizeof(Message));
				if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
				if(R_FAILED(ret))
				{
					clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
					myprintf(mystring);
					CATASTROPHIC_FAILURE = true;
					return;
				}
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (debugging) if (msg.sprite.speed != oldspeed) { clearString(); snprintf(mystring,sizeof(mystring),"image: %d speed: %d myNum: %d myNode: %d\n",msg.sprite.image, msg.sprite.speed, myNum, myNode); myprintf(mystring); }
					oldspeed = msg.sprite.speed;
					
					if (msg.sprite.speed == 123) {} //ignore
					else if (msg.sprite.speed == 777) {} //ignore
					else if (msg.sprite.speed == 555) { if (msg.sender == 0) UDSSend(msg); } //make sure host realizes we are waiting for him!
					else if (msg.sprite.speed == 1111) { sprites[msg.sprite.image] = msg.sprite; strncpy(sprites[msg.sprite.image].username,msg.sprite.username,sizeof(sprites[msg.sprite.image])); oldbikes--; } //ignore
					else if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; msg.sprite.speed = 45; sprites[myNum] = msg.sprite; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; break; } //joined game in score screen
					else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].speed = 45; sprites[myNum].node = myNode; sprites[myNum].dead = true; memset(sprites[myNum].username,0,sizeof(sprites[myNum].username)); strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username)); break; } // joined game in progress
					else if (msg.sprite.speed == 66) {
						if (msg.sender == 0) {
							apple.x = msg.sprite.x;
							apple.y = msg.sprite.y;
							setOptions((unsigned int)msg.sprite.dx);
							UDSDirect(sprites[0].node,msg);
						}
					} else if (msg.sprite.speed == 101) { if (msg.sender == 0) UDSSend(msg); break; }
					else if (msg.sender == 0 && (msg.sprite.speed == 45 || msg.sprite.speed == 1211)) {
						path[0][msg.sprite.image].x = msg.sprite.x;
						path[0][msg.sprite.image].y = msg.sprite.y;
						sprites[msg.sprite.image] = msg.sprite;
						sprites[msg.sprite.image].speed = 45;
						if (msg.sprite.image >= num_bikes - 1) {
							msg.sprite.speed = 100;
							UDSDirect(sprites[0].node,msg);
						}
					}
				} 
			}
		}
		C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		gfxFlushBuffers();
		gfxSwapBuffers();
		C3D_RenderTargetSetClear(target, 0, 0, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		gfxFlushBuffers();
		gfxSwapBuffers();
		for (int i = 0; i < 10; i++) oldscore[i] = 0;
		oldbikes = num_bikes;
		myconsoleClear();
		// Main loop
		for (int i = 0; i < numPlayers(); i++) {
			frameTicks[i] = svcGetSystemTick();
		}
		int oldApplex = 0;
		int oldAppley = 0;
		int oldDx = 15;
		C3D_RenderTargetSetClear(target, 0, 0, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		UDSSent = svcGetSystemTick();
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replyScore,1,sizeof(replyScore[0]) * 10);
		if (myNum) memset(replyChange,1,sizeof(replyChange[0]) * 10);
		frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);
		if (!inGame && myNum != 0) memset(replySprite,1,sizeof(replySprite[0]) * 10);
		quit = -1;
		if (!inGame) actual_bikes = num_bikes;
		printScore();
		death = 0;
		for (int i = numPlayers(); i < NUM_SPRITES; i++) {
			sprites[i].dead = true;
		}
		oldCPos.dx = 0;
		oldCPos.dy = 0;
		nextMove = 0;
		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			if (options[0]) {
				drawWall(7);
			}
			drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
		C3D_FrameEnd(0);
		lastDead = 0;
		totalSpace = 0;
		ignoreDeath = true;
		for (int i = 0; i < NUM_SPRITES; i++) {
			erased[i] = false;
		}
		bool goDiag = false;
		for (int b = 0; b < currentBots; b++) {
			if (b != 0) plotCourse(b);
			else if (autoPilot && b == myNum) plotCourse(b);
		}
		forfeit = false;
		movingApple = false;
		while (aptMainLoop()) {
			if (CATASTROPHIC_FAILURE) return;
			if (cheats || autoPilot) forfeit = true;
			if (actual_bikes > 1) {
				for (int b = 0; b < currentBots; b++) {
					if (b != 0 && !sprites[b].dead) {
						sprites[b].dead = true;
						lastDead = b;
						snprintf(mystring,sizeof(mystring),"%s%s%s has left the game.",textColors[b],sprites[b].username,WHITE);
						myprintf(mystring);
					}
				}
				currentBots = 1;
			}
			totalSpace = 0;
			for (int i = 0; i < numPlayers(); i++) {
				totalSpace += getLength(i);
			}
			if (totalSpace >= 24000) {
				int sanityCheck = 0;
				for (int i = 0; i < numPlayers(); i++) {
					sanityCheck += sprites[i].length;
				}
				if (sanityCheck >= 24000) { //Wow, the screen is actually filled.
					sprites[myNum].dead = true;
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					lastSprite = svcGetSystemTick();
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				}
			}
			if (everyoneElseIsDead(myNum) && sprites[myNum].dead) break;
			if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 3) {
				return;
			}
			if (myNum == 0) {
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					
					ret = udsGetConnectionStatus(&constatus);
					ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
					if (constatus.total_nodes >= num_bikes) {
						replyScore[msg.sender] = true;
						replyChange[msg.sender] = true;
						num_bikes = constatus.total_nodes;
					} else {
						errorQuit = svcGetSystemTick();
					}
				}
			}
			if (!wakeup) { //wakeup is true when everyone has started the round
				if (!allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.image = myNum;
					msg.sprite.speed = 77;
					msg.sprite.dx = score[myNum];
					msg.sprite.x = apple.x;
					msg.sprite.y = apple.y;
					UDSResend(replyScore,msg);
				}
				else if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.image = myNum;
					msg.sprite.speed = 66;
					msg.sprite.x = apple.x;
					msg.sprite.y = apple.y;
					UDSResend(replyChange,msg);
				}
				if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					if (sprites[myNum].speed == 1011) {
						memset(replySprite,1,sizeof(replySprite[0]) * 10);
					} else {
						sprites[myNum].node = myNode;
						memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
						strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
						msg.sprite = sprites[myNum];
						lastSprite = svcGetSystemTick();
						UDSResend(replySprite,msg);
					}
				}
			} else { //not everyone has started the round yet.
				if (!allReplied(replySprite) && svcGetSystemTick() -  lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.speed = 101;
					UDSResend(replySprite,msg);
					lastSprite = svcGetSystemTick();
				}
				if (allReplied(replySprite)) {
					wakeup = false;
				}
			}
			hidScanInput();

			// Respond to user input
			u32 kDown = hidKeysDown();
			u32 kHeld = hidKeysHeld();
			u32 kUp = hidKeysUp();
			if (debugging && kDown & KEY_SELECT) showCameFrom(1);
			hidCircleRead(&cpos);

			//Read the touch screen coordinates
			hidTouchRead(&touch);

			float px = (float)touch.px / 312.0f;
			float py = (float)touch.py / 235.0f;
			px *= 400.0f;
			py *= 240.0f;

			//Read the CirclePad position
			if (kDown & KEY_START) {
				replay = false;
				return; // break in order to return to hbmenu
			}
			u32 msgtype = 0;
			float dvd = fabs(cpos.dx) / fabs(cpos.dy);
			if (fabs(cpos.dy) > fabs(cpos.dx)) dvd = fabs(cpos.dy) / fabs(cpos.dx);
			if (goDiag || ((abs(cpos.dy) > 20 || abs(cpos.dx) > 20) && !(oldCPos.dx == 0 && oldCPos.dy == 0))) {
				if (dvd < 3.5 && !options[2]) {
					if (cpos.dy > 0 && cpos.dx > 0) {
						goDiag = true;
						sprites[myNum].diag = NORTHEAST;
						if (oldMove == MOVE_UP) kDown |= KEY_CPAD_RIGHT;
						else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_UP;
						else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
						else kDown |= KEY_CPAD_RIGHT;
					} else if (cpos.dx < 0 && cpos.dy < 0) {
						goDiag = true;
						sprites[myNum].diag = SOUTHWEST;
						if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_LEFT;
						else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_DOWN;
						else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
						else kDown |= KEY_CPAD_LEFT;
					} else if (cpos.dx < 0 && cpos.dy > 0) {
						goDiag = true;
						sprites[myNum].diag = NORTHWEST;
						if (oldMove == MOVE_UP) kDown |= KEY_CPAD_LEFT;
						else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_UP;
						else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
						else kDown |= KEY_CPAD_LEFT;
					} else if (cpos.dx > 0 && cpos.dy < 0) {
						goDiag = true;
						sprites[myNum].diag = SOUTHEAST;
						if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_RIGHT;
						else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_DOWN;
						else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
						else kDown |= KEY_CPAD_RIGHT;
					} 
				} else if (cpos.dx != oldCPos.dx || cpos.dy != oldCPos.dy) {
					goDiag = false;
					if (cpos.dx < 0 && abs(cpos.dx) > abs(cpos.dy)) { msgtype = MOVE_LEFT; kDown |= KEY_CPAD_LEFT; }
					else if (cpos.dx > 0 && abs(cpos.dx) > abs(cpos.dy)) { msgtype = MOVE_RIGHT; kDown |= KEY_CPAD_RIGHT; }
					else if (cpos.dy < 0 && abs(cpos.dy) > abs(cpos.dx)) { msgtype = MOVE_DOWN; kDown |= KEY_CPAD_DOWN; } 
					else if (cpos.dy > 0 && abs(cpos.dy) > abs(cpos.dx)) { msgtype = MOVE_UP; kDown |= KEY_CPAD_UP; }
					sprites[myNum].diag = 0;
				} else if (goDiag) {
					if (sprites[myNum].diag == NORTHEAST) {
						if (oldMove == MOVE_UP) kDown |= KEY_CPAD_RIGHT;
						else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_UP;
						else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
						else kDown |= KEY_CPAD_RIGHT;
					} else if (sprites[myNum].diag == SOUTHWEST) {
						if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_LEFT;
						else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_DOWN;
						else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
						else kDown |= KEY_CPAD_LEFT;
					} else if (sprites[myNum].diag == NORTHWEST) {
						if (oldMove == MOVE_UP) kDown |= KEY_CPAD_LEFT;
						else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_UP;
						else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
						else kDown |= KEY_CPAD_LEFT;
					} else if (sprites[myNum].diag == SOUTHEAST) {
						if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_RIGHT;
						else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_DOWN;
						else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
						else kDown |= KEY_CPAD_RIGHT;
					} else if (oldDiag) {
						goDiag = false;
						msgtype = MOVE_LEFT;
						sprites[myNum].diag = 0;
					}
				}
			} else if (oldDiag) {
				goDiag = false;
				sprites[myNum].diag = 0;
				msgtype = MOVE_LEFT;
				if (sprites[myNum].dx > 0) msgtype = MOVE_RIGHT;
				else if (sprites[myNum].dx < 0) msgtype = MOVE_LEFT;
				else if (sprites[myNum].dy > 0) msgtype = MOVE_UP;
				else if (sprites[myNum].dy < 0) msgtype = MOVE_DOWN;
			}
			oldCPos = cpos;
			if (debugging && (kDown & KEY_X || kHeld & KEY_X)) {
				debugHold = true;
			}
			if (debugging && kUp & KEY_X) debugHold = false;
			if (kDown & KEY_L) {
				if (autoPilot) { myprintf("Autopilot disengaged."); autoPilot = false; }
				else { autoPilot = true; myprintf("Autopilot engaged."); plotCourse(myNum); }
			}
			if (!options[3] && !autoPilot) { //A is enabled
				if (kDown & KEY_A || kHeld & KEY_A) sprites[myNum].speed = 15;
				else if (kUp & KEY_A) sprites[myNum].speed = 45;
			}
			if (actual_bikes == 1 && sprites[myNum].dead && kDown & KEY_A) {
				forfeit = true;
				for (int b = 1; b < currentBots; b++) {
					sprites[b].dead = true;
				}
			}
			if (!options[4] && !autoPilot) { //B is enabled
				if (kDown & KEY_B || kHeld & KEY_B) sprites[myNum].speed = 90;
				else if (kUp & KEY_B) sprites[myNum].speed = 45;
			}
			int prevn = currentPath[myNum] - 1;
			if (prevn < 0) prevn = 120 * 200 - 1;
			if (goDiag && (kDown & KEY_DUP || kDown & KEY_DDOWN || kDown & KEY_DLEFT || kDown & KEY_DRIGHT)) {
				goDiag = false;
				sprites[myNum].diag = 0;
				nextMove = 0;
				if (kDown & KEY_DUP) {
					sprites[myNum].dx = 0;
					sprites[myNum].dy = bikeSpeed * -1;
					msgtype = MOVE_UP;
				} else if (kDown & KEY_DDOWN) {
					sprites[myNum].dx = 0;
					sprites[myNum].dy = bikeSpeed;
					msgtype = MOVE_DOWN;
				} else if(kDown & KEY_DLEFT) {
					sprites[myNum].dx = bikeSpeed * -1;
					sprites[myNum].dy = 0;
					msgtype = MOVE_LEFT;
				} else if(kDown & KEY_DRIGHT) {					
					sprites[myNum].dx = bikeSpeed;
					sprites[myNum].dy = 0;
					msgtype = MOVE_RIGHT;
				}
			}
			else if ((kDown & KEY_CPAD_UP || kDown & KEY_DUP || nextMove == MOVE_UP) && !sprites[myNum].dy) { //they want to move up
				if (kDown & KEY_DUP) sprites[myNum].diag = 0;
				if (path[prevn][myNum].x == sprites[myNum].x) nextMove = MOVE_UP;
				else {
					sprites[myNum].dx = 0;
					sprites[myNum].dy = bikeSpeed * -1;
					msgtype = MOVE_UP;
					nextMove = 0;
				}
			} else if((kDown & KEY_CPAD_DOWN || kDown & KEY_DDOWN || nextMove == MOVE_DOWN)  && !sprites[myNum].dy) { //they want to move down
				if (kDown & KEY_DDOWN) sprites[myNum].diag = 0;
				if (path[prevn][myNum].x == sprites[myNum].x) nextMove = MOVE_DOWN;
				else {
					sprites[myNum].dx = 0;
					sprites[myNum].dy = bikeSpeed;
					msgtype = MOVE_DOWN;
					nextMove = 0;
				}
			} else if ((kDown & KEY_CPAD_LEFT || kDown & KEY_DLEFT || nextMove & MOVE_LEFT)  && !sprites[myNum].dx) { //they want to move left
				if (kDown & KEY_DLEFT) sprites[myNum].diag = 0;
				if (path[prevn][myNum].y == sprites[myNum].y) nextMove = MOVE_LEFT;
				else {
					sprites[myNum].dx = bikeSpeed * -1;
					sprites[myNum].dy = 0;
					msgtype = MOVE_LEFT;
					nextMove = 0;
				}
			} else if ((kDown & KEY_CPAD_RIGHT || kDown & KEY_DRIGHT || nextMove == MOVE_RIGHT)  && !sprites[myNum].dx) { //they want to move right
				if (kDown & KEY_DRIGHT) sprites[myNum].diag = 0;
				if (path[prevn][myNum].y == sprites[myNum].y) nextMove = MOVE_RIGHT;
				else {
					sprites[myNum].dx = bikeSpeed;
					sprites[myNum].dy = 0;
					msgtype = MOVE_RIGHT;
					nextMove = 0;
				}
			}
			if (msgtype != 0 || oldDx != sprites[myNum].speed) { //there has been some kind of change, lets send an update
				oldMove = msgtype;
				if (oldDiag != sprites[myNum].diag || !sprites[myNum].diag || oldDx != sprites[myNum].speed) {
					oldDiag = sprites[myNum].diag;
					sprites[myNum].node = myNode;
					strncpy(sprites[myNum].username,myName,sizeof(myName));
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					msg.sprite = sprites[myNum];
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				oldDx = sprites[myNum].speed;
			}
			//send my sprite info
			//Message msg;
			

			//receive other sprite's info
			memset(tmpbuf, 0, tmpbuf_size);
			actual_size = 0;
			src_NetworkNodeID = 0;
			if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
			if(R_FAILED(ret))
			{
				clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				return;
			}
			if (wakeup) {
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (msg.sprite.speed == 101) {
						replySprite[msg.sender] = true; //need to know if they have all joined the game.
					}
				}
			}
			/*for (int i = 0; i < num_bikes; i++) {
				if (score[i] != oldscore[i]) clearFlag = true;
			}
			if (sprites[myNum].dead && !olddead) clearFlag = true;
			if (oldbikes != num_bikes) { clearFlag = true; oldbikes = num_bikes; }*/
			printScore();
			/*if (clearFlag) {
				//if (!debugging) myconsoleClear();
				printScore();
				for (int i = 0; i < num_bikes; i++) oldscore[i] = score[i];
					olddead = sprites[myNum].dead;
				clearFlag = false;
			}*/
			/*gfxFlushBuffers();
			gfxSwapBuffers();*/
			
			//Wait for VBlank
			//gspWaitForVBlank();
			// Render the scene
			if (!wakeup) { //everyone has joined the game, we can draw to the top screen now!
				bool skipPlotting = false;
				for (int b = 0; b < currentBots; b++) {
					if (sprites[getBot(b)].dead) continue;
					if (b != 0 || autoPilot) skipPlotting = checkPath(b);
					if (!skipPlotting) {
						if (everyoneElseIsDead(b) && getHighestScore() == b) {
							sprites[b].dead = true;
							lastDead = b;
						}
						else if (plotting[b]) {
							if (b != 0) continuePlotting(b);
							else if (autoPilot) continuePlotting(b);
						} else if (totalPathN[b] < 1) {
							if (b != 0)	plotCourse(b);
							else if (autoPilot) plotCourse(b);
						}
					}
				}
				C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
					C3D_FrameDrawOn(target);
					C3D_TexBind(0, &spritesheet_tex);
					C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
					//player has pressed R with it enabled
					if (movingApple) {
						bool oldUsed = usedSpecial[0];
						changeApple();
						movingApple = false;
						usedSpecial[0] = oldUsed;
					}
					if (options[6] && !sprites[myNum].dead && kDown & KEY_R) {
						reversePath(myNum);
						if (sprites[myNum].forwards) sprites[myNum].forwards = false;
						else sprites[myNum].forwards = true;
						msg.sprite = sprites[myNum];
						lastSprite = svcGetSystemTick();
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						UDSSend(msg);
						overwriteSprite(sprites[myNum].x >> 8, sprites[myNum].y >> 8, 2, 2, myNum);
						ignoreDeath = true; //the frame buffer isn't updated from erasing the last piece of the tail...
					}
					//Player has pressed Y and it is not disabled
					if (!options[5] && !options[7]) if (kDown & KEY_Y && !usedSpecial[0]) {
						usedSpecial[0] = true;
						memset(replyChange,0,sizeof(replyChange[0]) * 10);
						changeApple();
					}
					//cheats are activated and player is dragging the apple
					if (cheats && px && py) {
						drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 9);
						apple.x = (int)px;
						apple.y = (int)py;
						apple.x = apple.x << 8;
						apple.y = apple.y << 8;
						drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
						oldpx = px;
						oldpy = py;
					} else if (oldpx && oldpy) { //player has dropped the apple
						oldpx = 0;
						oldpy = 0;
						msg.sprite.speed = 66;
						msg.sprite.x = apple.x;
						msg.sprite.y = apple.y;
						memset(replyChange,0,sizeof(replyChange[0]) * 10);
						UDSSend(msg);
						if (debugging) {
							snprintf(mystring,sizeof(mystring),"pathfindToApple: %d",pathfindToApple(myNum));
							myprintf(mystring);
						}
					}
					sceneRender();
					moveSprites();
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						//Message msg;
						memcpy(&msg,tmpbuf,sizeof(Message));
						//if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"sender: %d image: %d speed: %d diag: %d",msg.sender,msg.sprite.image, msg.sprite.speed,msg.sprite.diag); myprintf(mystring); }
						if (msg.sprite.speed == 101 && msg.sender == 0) { UDSSend(msg); } //host is making sure we joined the game.
						else if (msg.sprite.speed == 999) { //quit message
							errorQuit = 0;
							if (msg.sender == msg.sprite.node && msg.sender == msg.sprite.image) {
								for (int i = 0; i < num_bikes; i++) {
									if (sprites[i].node == msg.sprite.node) { quit = i; break; }
								}
								memset(quitName,0,sizeof(quitName));
								strncpy(quitName,msg.sprite.username,sizeof(quitName));
								
					
								for (int i = 0; i < num_bikes; i++) {
									sprites[i].dead = true;
								}
								msg.sprite.image = msg.sprite.node;
								msg.sprite.node = myNode;
								UDSDirect(msg.sprite.image,msg);
							}
						}
						else if (msg.sprite.speed == 2020) { } // ignore
						else if (msg.sprite.speed == 1111) { //join message
							sprites[msg.sprite.image] = msg.sprite;
							if (myNum == 0 && msg.sprite.image == msg.sender) {
								msg.sprite = sprites[msg.sprite.image];
								msg.sprite.image = actual_bikes;
								msg.sprite.speed = 1011;
								msg.sprite.dead = true;
								sprites[num_bikes] = msg.sprite;
								oldbikes = 0;
								UDSSend(msg);
							}
						}
						else if (msg.sprite.speed == 5050) {} //ignore
						else if (msg.sprite.speed == 123) {} //ignore
						else if (msg.sprite.speed == 1011 && myNum != 0) {} // ignore
						else if (msg.sprite.speed == 66) { //change apple message
							if (msg.sprite.image == myNum) { 
								if (msg.timestamp == lastChange) replyChange[msg.sender] = true; 
								else if (debugging) { 
									clearString(); 
									snprintf(mystring,sizeof(mystring),"replyChange from %d: 0x%" PRIx64 " != 0x%" PRIx64,msg.sender,msg.timestamp,lastChange); 
									myprintf(mystring); 
								} 
							}
							else if (msg.sender == msg.sprite.image) { 
								UDSDirect(msg.sprite.node,msg); 
								if (debugging) myprintf("changing apple..."); 
								if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) updateApple(msg.sprite.x,msg.sprite.y); 
							}
						}
						else if (msg.sprite.speed == 77) { //scored a point message
							if (msg.sprite.image == myNum) { 
								if (msg.timestamp == lastScore) replyScore[msg.sender] = true; 
								else if (debugging) { 
									clearString(); 
									snprintf(mystring,sizeof(mystring),"replyScore from %d: 0x%" PRIx64 " != 0x%" PRIx64,msg.sender,msg.timestamp,lastScore); 
									myprintf(mystring); 
								} 
							}
							else if (msg.sender == msg.sprite.image) { 
								UDSDirect(msg.sprite.node,msg); 
								if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) { 
									sprites[msg.sprite.image].length = msg.sprite.length; 
									setApple(msg.sprite.image, msg.sprite.x, msg.sprite.y); 
								} 
								score[msg.sprite.image] = msg.sprite.dx; 
							}
						}
						else if (msg.sprite.image == myNum) { if (msg.sprite.speed == 1001) break; if (msg.timestamp == lastSprite) replySprite[msg.sender] = true;  else if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"replySprite from %d: 0x%" PRIx64 " != 0x%" PRIx64,msg.sender,msg.timestamp,lastSprite); myprintf(mystring);} }
						else if (msg.sprite.speed == 1001) {} //ignore.
						else {
							
							
							if (msg.sprite.image > num_bikes) { //someone has joined and we missed it...
								num_bikes = msg.sprite.image + 1; 
								for (int i = actual_bikes; i < NUM_SPRITES; i++) { 
									sprites[i].dead = true; 
								} 
								if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
								if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
								if (sprites[myNum].dead) { 
									sprites[myNum].image = myNum; 
									sprites[myNum].node = myNode; 
									msg.sprite = sprites[myNum]; 
									replySprite[num_bikes - 1] = false; 
									UDSSend(msg); 
								} 
							}
							if (msg.sprite.image == num_bikes) { //someone has joined and we missed it
								sprites[num_bikes].dead = true; 
								if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
								if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
								num_bikes++; 
								if (sprites[myNum].dead) { 
									sprites[myNum].image = myNum; 
									sprites[myNum].node = myNode; 
									msg.sprite = sprites[myNum]; 
									replySprite[num_bikes - 1] = false; 
									UDSSend(msg); 
								} 
							}
							//this is someone's movement. lets update their sprite information
							if (msg.sender == msg.sprite.image) UDSDirect(msg.sprite.node,msg);
							if (msg.sprite.dead && options[9]) eraseLine(msg.sprite.image);
							int img = msg.sprite.image;
							//they haven't gone in reverse yet.
							//let's clean up any graphical artifacts and fill any holes from teleporting
							if (sprites[img].forwards == msg.sprite.forwards) if (msg.sprite.image < actual_bikes && msg.sender == msg.sprite.image) {
								
								if (abs(currentPath[img] - pathPos[img]) > 40) {
									
									if (msg.sprite.dead && !options[9]) {
										lastDead = msg.sprite.image;
										eraseOvershoot(msg.sprite);
									}
									else finishLine(currentPath[img],sprites[img].x, sprites[img].y, msg.sprite.x, msg.sprite.y, msg.sprite, img);
								}
							}
							//this is definitely a message of movement change
							if (msg.sender == msg.sprite.image) {
								//they sent a message showing they have gone in reverse
								if (msg.sprite.forwards != sprites[msg.sprite.image].forwards) {
									reversePath(msg.sprite.image);
									int cp = currentPath[img];
									int x = path[cp][img].x >> 8;
									int y = path[cp][img].y >> 8;
									int cx = 0;
									int cy = 0;
									if ((path[cp][img].y >> 8) == (msg.sprite.y >> 8)) {
										if ((path[cp][img].x >> 8) < (msg.sprite.x >> 8)) cx = 2;
										else cx = -2;
									} else if ((path[cp][img].x >> 8) == (msg.sprite.x >> 8)) {
										if ((path[cp][img].y >> 8) < (msg.sprite.y >> 8)) cy = 2;
										else cy = -2;
									}
									int i = 0;
									if (!msg.sprite.dead) {
										if (x == (msg.sprite.x >> 8) || y == (msg.sprite.y >> 8)) while ((path[cp][img].x >> 8) != (msg.sprite.x >> 8) || (path[cp][img].y >> 8) != (msg.sprite.y >> 8)) {
											overwriteSprite(x, y, 2, 2, img);
											cp++;
											x += cx;
											y += cy;
											if (cp >= 120 * 200) cp = 0;
											path[cp][img].x = x << 8;
											path[cp][img].y = y << 8;
											i++;
										}
										overwriteSprite(x << 8, y << 8, 2, 2, img);
										currentPath[img] = cp;
									}
								}
								sprites[msg.sprite.image] = msg.sprite;
							}
							if (everyoneElseIsDead(myNum)) {
								//if it's No apple mode...
								if (options[7] && !sprites[myNum].dead) {
									lastDead = myNum;
									sprites[myNum].dead = true;
									msg.sprite = sprites[myNum];
									memset(replySprite,0,sizeof(replySprite[0]) * 10);
									lastSprite = svcGetSystemTick();
									UDSSend(msg);
								}
								//or it's normal, and we have the highest score while everyone else is dead...
								else if (getHighestScore() == myNum && allReplied(replyScore)) { lastDead = myNum; sprites[myNum].dead = true; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); lastSprite = svcGetSystemTick(); UDSSend(msg); }
							}
						}
					}
					//redraw the apple, it has moved
					if (oldApplex != apple.x && oldAppley != apple.y) { 
						drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
						oldApplex = apple.x;
						oldAppley = apple.y;
					}
				C3D_FrameEnd(0);
				/*gfxFlushBuffers();
				gfxSwapBuffers();*/
			}
			keepConsole();
			if (everyoneElseIsDead(myNum)) {
				//no apple mode
				if (options[7] && !sprites[myNum].dead) {
					lastDead = myNum;
					sprites[myNum].dead = true;
					msg.sprite = sprites[myNum];
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				//its normal
				else if (getHighestScore() == myNum && allReplied(replyScore)) { lastDead = myNum; sprites[myNum].dead = true; sprites[myNum].node = myNode; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); lastSprite = svcGetSystemTick(); UDSSend(msg); }
			}
			if (everyoneElseIsDead(myNum) && sprites[myNum].dead) break;
		}

		//This is the end of round screen...

		if (debugging) {
			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
				C3D_FrameDrawOn(target);
				C3D_TexBind(0, &spritesheet_tex);
				C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
				for (int k = 0; k < numBots; k++) {
					for (int i = totalPathN[k] - 10; i < totalPathN[k] + 10; i++) {
						overwriteSprite(totalPath[k][i].x,totalPath[k][i].y, 2, 2, 6);
					}
				}
			C3D_FrameEnd(0);
		}

		myconsoleClear();
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replyScore,0,sizeof(replyScore[0]) * 10);
		memset(replyDead,1,sizeof(replyDead[0]) * 10);
		memset(replySprite,0,sizeof(replySprite[0]) * 10);
		memset(replyHighscore,1,sizeof(replyHighscore[0]) * 10);
		memset(replyScreenScore,0,sizeof(replyScreenScore[0]) * 10);
		memset(receivedScreenScore,0,sizeof(receivedScreenScore[0]) * 10);
		msg.sprite = sprites[myNum];
		msg.sprite.speed = 5050;
		if (options[4]) totalSpace *= 1.25;
		if (options[5]) totalSpace *= 1.25;
		msg.sprite.dx = totalSpace;
		lastScreenScore = svcGetSystemTick();
		UDSSend(msg);
		lastScore = 0;
		int oldQuit = 0;
		int numLeft = 0;
		errorQuit = 0;
		for (int i = 0; i < NUM_SPRITES; i++) {
			ready[i] = false;
		}
		joinedNum = 0;
		waitForFinish = 0;
		u64 readyLock = 0;
		readyLock = svcGetSystemTick();
		inGame = false;
		bool saveReady = false;
		bool displayedHS = false;
		bool iWin = false;
		while (aptMainLoop()) {

			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target2);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &textprojection);
			myprintf("\x1b[2;0H "); //clear the 3rd line in case we scroll text
			keepSConsole();
			if (totalSpace >= 24000) { //entire screen is filled... wow.
				snprintf(mystring,sizeof(mystring),"\x1b[6;0H%sThe screen is completely filled!",RAINBOW);
				myprintf(mystring);
				snprintf(mystring,sizeof(mystring),"\x1b[7;0H%sI can't even.%s",RAINBOW,WHITE);
				myprintf(mystring);
			}
			//Be sure to still resend my death msg if someone hasn't gotten it
			if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
				sprites[myNum].image = myNum;
				sprites[myNum].dead = true;
				sprites[myNum].node = myNode;
				msg.sprite = sprites[myNum];
				lastSprite = svcGetSystemTick();
				UDSResend(replySprite,msg);
			}

			if (!allReplied(replyDead) && svcGetSystemTick() - lastDeadmsg > TICKS_PER_MS * 15 * 6 * lagMult()) {
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 2020;
				msg.sprite.dx = optionsToInt();
				lastDeadmsg = svcGetSystemTick();
				UDSResend(replyDead,msg);
			}
			if (!allReplied(replyHighscore) && svcGetSystemTick() - lastHighscore > TICKS_PER_MS * 15 * 6 * lagMult()) {
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 3030;
				msg.sprite.dx = highScore;
				lastHighscore = svcGetSystemTick();
				UDSResend(replyHighscore,msg);
			}
			if (!allReplied(replyScreenScore) && svcGetSystemTick() - lastScreenScore > TICKS_PER_MS * 15 * 6 * lagMult()) {
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 5050;
				msg.sprite.dx = totalSpace;
				lastScreenScore = svcGetSystemTick();
				UDSResend(replyScreenScore,msg);
			}
			//if it's not survival mode
			if (!options[7]) {
				if (itsATie()) myprintf("\x1b[0;0HIt's a TIE!");
				else if (getHighestScore() == myNum ) { 
					if (forfeit) {
						snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sYou forfeit the match!",WHITE);
						myprintf(mystring);
					}
					else {
						iWin = true; 
						snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sA winner is YOU!%s",RAINBOW,WHITE);
						myprintf(mystring); 
					}
				}
				else { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[0;0HYou LOSE! %s%s wins the game!%s",textColors[getHighestScore()],sprites[getHighestScore()].username,WHITE); myprintf(mystring); }
			} else {
				if (myNum == lastDead) { 
					if (forfeit) {
						snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sYou forfeit the match!",WHITE);
						myprintf(mystring);
					}
					else {
						iWin = true; 
						snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sA winner is YOU!%s",RAINBOW,WHITE); 
						myprintf(mystring); 
					}
				}
				else { snprintf(mystring,sizeof(mystring),"\x1b[0;0HYou LOSE! %s%s wins the game!%s",textColors[lastDead],sprites[lastDead].username,WHITE); myprintf(mystring); }
			}
			clearString(); snprintf(mystring,sizeof(mystring),"\x1b[1;0HScore: ");
			char scores[10];
			float widths[10];
			float h;
			char te[100];
			char k[10];
			memset(te,0,sizeof(te));
			snprintf(te,sizeof(te),"Score: ");
			memset(scores,0,sizeof(scores));
				for (int i = 0; i < NUM_SPRITES; i++) {
					memset(scores,0,sizeof(scores));
					memset(k,0,sizeof(k));
					if (i < numPlayers() || i == 0) snprintf(scores,sizeof(scores),"%s%d ",textColors[i],score[i]);
					snprintf(k,sizeof(k),"%d ",score[i]);
					//else snprintf(scores,sizeof(scores),"  ");
					screen_get_string_size_wrap(&widths[i], &h, te, 0.5f, 0.5f, 320);
					strcat(mystring,scores);
					strcat(te,k);
				}
			myprintf(mystring);
			//clearString(); snprintf(mystring,sizeof(mystring),"\x1b[2;0H%sScore: ", BLACK);
				for (int i = 0; i < NUM_SPRITES; i++) {
					memset(scores,0,sizeof(scores));
					if (i < num_bikes) {
						if (ready[i]) snprintf(scores,sizeof(scores),"%sR",GREEN);
						else snprintf(scores,sizeof(scores),"%s-",WHITE);
						rText(widths[i],h * 2 + 10.0,.5f,.5f,true,scores);
					}
				}
			C3D_FrameEnd(0);
			if (allReplied(replyScore) && myNum == 0 && num_bikes > 1) { if (debugging) myprintf("Everyone got the message. Sending bike information.."); break; }
			clearString(); snprintf(mystring,sizeof(mystring),"\x1b[3;0H%sPress A if you're ready!",WHITE);
			myprintf(mystring);
			myprintf("\x1b[4;0HPress START to quit.");
			if (!myNum) myprintf("\x1b[5;0HPress SELECT to set game modes!");



			snprintf(mystring,sizeof(mystring),"\x1b[5;0HScreen score: %d",totalSpace);
			myprintf(mystring);
			if (iWin && allReplied(receivedScreenScore)) {
				if ((unsigned int)totalSpace > highScore) setHighscore((unsigned int)totalSpace);
			}
			if (num_bikes == 1 && actual_bikes > 1) { currentBots = numBots; numLeft++; num_bikes--; clearString(); snprintf(mystring,sizeof(mystring),"Everyone has left the game!"); myprintf(mystring); }
			
			//Trigger to resend dropped packet of "Ready"
			if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 123;
				//memset(replyChange,0,sizeof(replyChange[0]) * 10);
				UDSResend(replyChange,msg);
			}

			//Trigger to resend dropped packet of "Start game"
			if (myNum == 0 && lastScore && !allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 30 * lagMult()) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 555;
				UDSResend(replyScore,msg);
				lastScore = svcGetSystemTick();
			}


			hidScanInput();
			u32 kDown = hidKeysDown();
			memset(tmpbuf, 0, tmpbuf_size);
			actual_size = 0;
			src_NetworkNodeID = 0;
			if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
			if(R_FAILED(ret))
			{
				clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				replay = false;
				return;
			}
			if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
			{
				//Message msg;
				memcpy(&msg,tmpbuf,sizeof(Message));
				if (debugging) {
					numLeft++;
					/*clearString(); snprintf(mystring,sizeof(mystring),"sender: %d, image: %d, speed: %d node: %d",msg.sender,msg.sprite.image,msg.sprite.speed, msg.sprite.node);
					myprintf(mystring);*/
				}
				if (msg.sprite.speed == 999) { //death message
					if (msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
						memset(quitName,0,sizeof(quitName));
						strncpy(quitName,msg.sprite.username,sizeof(quitName));
						for (int i = 0; i < num_bikes; i++) {
							if (sprites[i].node == msg.sprite.node && i != oldQuit) { quit = i; oldQuit = quit; }
						}
						msg.sprite.image = msg.sprite.node;
						msg.sprite.node = myNode;
						UDSDirect(msg.sprite.image,msg);
					}
				}
				/*if (msg.sprite.speed == 999 && msg.sprite.image != quit) {
					if (msg.sender <= num_bikes) {
						lastQuit = msg.timestamp;
						quit = msg.sprite.image;
						quitNum = msg.sender;
						if (quit < myNum) myNum--;
						num_bikes--;
						replyChange--;
					}
				} //connection killed by guest*/
				else if (msg.sprite.speed == 1011) { } //ignore
				else if (msg.sprite.speed == 3030) {
					if (msg.sprite.image != myNum) {
						if (!displayedHS) snprintf(mystring,sizeof(mystring),"%s%s%s's new High Score: %s%u",textColors[msg.sprite.image],msg.sprite.username,WHITE,RAINBOW,(unsigned int)msg.sprite.dx); myprintf(mystring);
						displayedHS = true;
						UDSDirect(msg.sprite.node,msg);
					} else if (msg.sprite.image == sprites[myNum].image) replyHighscore[msg.sender] = true;
				}
				else if (msg.sprite.speed == 5050) {
					if (msg.sprite.image != myNum) {
						if (msg.sprite.dx > totalSpace) totalSpace = msg.sprite.dx;
						receivedScreenScore[msg.sender] = true;
						UDSDirect(msg.sprite.node,msg);
					} else if (msg.sprite.image == sprites[myNum].image) replyScreenScore[msg.sender] = true;
				}
				else if (msg.sprite.speed == 2020) {
					if (msg.sender == 0) {
						if (lastDeadmsg != msg.timestamp) {
							lastDeadmsg = msg.timestamp;
							int n = msg.sprite.dx;
							snprintf(mystring,sizeof(mystring),"%s%s%s was in game options...",textColors[0],sprites[0].username,WHITE);
							myprintf(mystring);
							bool flag = false;
							for (unsigned int i = 0; i != numOptions; ++i)
							{
								if (options[i] && !(n & 1)) {
									flag = true;
								  	snprintf(mystring,sizeof(mystring),"    %s%s%s is now %soff%s.",DARKYELLOW,optionNames[i],WHITE,RED,WHITE);
								  	myprintf(mystring);
								}
							 	n /= 2;
							}
							n = msg.sprite.dx;
							for (unsigned int i = 0; i != numOptions; ++i)
							{
								if (!options[i] && n & 1) {
									flag = true;
								  	snprintf(mystring,sizeof(mystring),"    %s%s%s is now %son%s.",YELLOW,optionNames[i],WHITE,GREEN,WHITE);
								  	myprintf(mystring);
								}
							 	n /= 2;
							}
							if (!flag) myprintf("    but nothing was changed...");
							setOptions(msg.sprite.dx);
						}
						UDSDirect(msg.sprite.node,msg);
					} else {
						replyDead[msg.sender] = true;
					}
				}
				else if (msg.sprite.speed == 1111) { //join message
					sprites[msg.sprite.image] = msg.sprite;
					sprites[msg.sprite.image].node = msg.sprite.node;
					currentBots = 1;
					if (joinedNum != msg.sprite.image) { clearString(); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s",textColors[msg.sprite.image],msg.sprite.username,colorNames[msg.sprite.image],WHITE); myprintf(mystring); }
					joinedNum = msg.sprite.image;
					if (myNum == 0) {
						sprites[myNum].node = myNode;
						msg.sprite = sprites[msg.sprite.image];
						msg.sprite.dead = true;
						msg.sprite.speed = 1001;
						UDSSend(msg);
					}
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					sprites[myNum].node = myNode;
					memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
					sprites[myNum].node = myNode;
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				}
				//ready message
				else if (msg.sprite.speed == 123) { 
					if (!ready[msg.sender]) { 
						numLeft++;  
						clearString(); 
						snprintf(mystring,sizeof(mystring),"%s%s%s is ready!",textColors[msg.sender],msg.sprite.username,WHITE);
						if (notReadies() - 1) snprintf(mystring,sizeof(mystring),"%s%s%s is ready! Waiting on %d more...", textColors[msg.sender], msg.sprite.username, WHITE, notReadies() - 1); 
						myprintf(mystring); 
					} 
					ready[msg.sender] = true; 
					if (msg.sprite.node != myNode) { 
						msg.sprite.image = msg.sender; 
						msg.sprite.speed = 777; 
						UDSDirect(msg.sprite.node,msg); 
					} 
				}
				//response to ready message
				else if (msg.sprite.speed == 777) {
					if (msg.sprite.node == myNode) replyChange[msg.sender] = true;

					//game start message
				} else if(msg.sprite.speed == 555) {
					if (msg.sender == 0) {
						UDSDirect(msg.sprite.node,msg); 
						break; 
					} else if (myNum == 0) {
						replyScore[msg.sender] = true;
					}
				} else { //or its a sprite change
					if (msg.sprite.image == myNum && msg.sprite.dead && lastSprite == msg.timestamp) replySprite[msg.sender] = true;
					else if (msg.sprite.image == msg.sender) {
						sprites[msg.sprite.image] = msg.sprite;
						UDSDirect(msg.sprite.node,msg);
					}
				}
			}
			if (allReady() && num_bikes > 1 && !lastScore) { 
				clearString(); snprintf(mystring,sizeof(mystring),"Starting game....");  
				myprintf(mystring);
				if (myNum == 0) { 
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 555;
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					UDSSend(msg);
				}
				lastScore = svcGetSystemTick();
			}



			if (kDown & KEY_L) {
				if (autoPilot) {
					autoPilot = false;
					myprintf("Autopilot disengaged.");
				} else {
					autoPilot = true;
					myprintf("Autopilot engaged");
				}
			}
			if (myNum == 0 && kDown & KEY_SELECT) {
				if (!ready[0]) { 
					gameOptions(); 
					myconsoleClear(); 
					msg.sprite = sprites[myNum];
					msg.sprite.speed = 2020;
					msg.sprite.dx = optionsToInt();
					lastDeadmsg = svcGetSystemTick();
					memset(replyDead,0,sizeof(replyDead[0]) * 10);
					UDSSend(msg);
				}
				else myprintf("Can't edit modes when you are ready!");
			}
			//player pressed A
			if (kDown & KEY_A || saveReady || (autoPilot && actual_bikes > 1)) {
				if (num_bikes <= 1) break; 
				if (!ready[myNum] && svcGetSystemTick() - readyLock > TICKS_PER_SEC) { 
					sprites[myNum].node = myNode; 
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username)); 
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 123; 
					lastChange = svcGetSystemTick(); 
					memset(replyChange,0,sizeof(replyChange[0]) * 10); 
					UDSSend(msg); 
					numLeft++; 
					clearString(); snprintf(mystring,sizeof(mystring),"%s%s%s is ready! Waiting on %d more...",textColors[myNum],sprites[myNum].username,WHITE,notReadies() - 1); 
					myprintf(mystring);
					ready[myNum] = true;  
				} else saveReady = true;
			}

			//leaving the game
			if (kDown & KEY_START) { return; }

			//someone left or joined
			if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
			{
				connectionEstablished = true;
				readyLock = svcGetSystemTick();
				for (int i = 0; i < 10; i++) {
					ready[i] = false;
				}
				ret = udsGetConnectionStatus(&constatus);
				ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
				if (constatus.total_nodes >= num_bikes) {
					num_bikes = constatus.total_nodes;
					memset(sprites[num_bikes].username,0,sizeof(sprites[num_bikes - 1].username));
					udsGetNodeInfoUsername(&tmpnode,sprites[num_bikes - 1].username);
					msg.sprite = sprites[num_bikes - 1];
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					memset(replyChange,1,sizeof(replyChange[0]) * 10);
					numLeft++;
				} else {
						numLeft++;
						if (quit < 0) {
							numLeft++;
							clearString(); snprintf(mystring,sizeof(mystring),"A player has crashed...");
							myprintf(mystring);
							errorQuit = svcGetSystemTick();
							while(aptMainLoop()) {
								keepConsole();
								gfxFlushBuffers();
								gfxSwapBuffers();
								hidScanInput();
								kDown = hidKeysDown();
								if (kDown & KEY_START) {
									CATASTROPHIC_FAILURE = true;
									return;
								}
								if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 4) {
									numLeft++;
									if (numLeft >= 15) { myconsoleClear(); numLeft = 0; }
									clearString(); snprintf(mystring,sizeof(mystring),"%sError: unknown person left. Removing a color...%s",RED,WHITE);
									myprintf(mystring);
									num_bikes = constatus.total_nodes;
									memset(replyChange,1,sizeof(replyChange[0]) * 10);
									memset(replySprite,1,sizeof(replySprite[0]) * 10);
									if (myNum >= num_bikes) {
										currentBots = 1;
										myNum = num_bikes - 1;
										clearString(); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE);
										myprintf(mystring);
									}
									errorQuit = 0;
									break;
								}
								memset(tmpbuf, 0, tmpbuf_size);
								actual_size = 0;
								src_NetworkNodeID = 0;
								if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
								if(R_FAILED(ret))
								{
									clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
									myprintf(mystring);
									CATASTROPHIC_FAILURE = true;
									replay = false;
									return;
								}
								if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
								{

									memcpy(&msg,tmpbuf,sizeof(Message));
									if (msg.sprite.speed == 999 && msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
										joinedNum = 0;
										for (int i = 0; i < num_bikes; i++) {
											if (sprites[i].node == msg.sprite.node) { quit = i; break; }
										}
										if (quit < 0) {
											CATASTROPHIC_FAILURE = true;
											return;
										}
										memset(quitName,0,sizeof(quitName));
										strncpy(quitName,msg.sprite.username,sizeof(quitName));
										msg.sprite.image = msg.sprite.node;
										msg.sprite.node = myNode;
										UDSDirect(msg.sprite.image,msg);
										oldQuit = quit;
										numLeft++;
										if (numLeft + num_bikes - quit >= 15) { myconsoleClear(); numLeft = 0; }
										clearString(); snprintf(mystring,sizeof(mystring),"%s%s has left the game.%s",textColors[quit],quitName,WHITE);
										myprintf(mystring);
										if (quit > 0 && quit < num_bikes - 1) {
											if (quit < myNum) myNum--;
											for (int i = quit; i < num_bikes - 1; i++) {
												numLeft++;
												if (i == myNum) { clearString(); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE); }
												else { clearString(); snprintf(mystring,sizeof(mystring),"  %s%s%s is now %s%s%s!", textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE); }
												myprintf(mystring);
												sprites[i] = sprites[i+1];
												sprites[i].image = i;
											}
										}
										num_bikes = constatus.total_nodes;
										memset(replyChange,1,sizeof(replyChange[0]) * 10);
										memset(replySprite,1,sizeof(replySprite[0]) * 10);
										quit = -1;
										oldQuit = -1;
										break;
									}
								}
							}
						}
						else {
							joinedNum = 0;
							if (numLeft + num_bikes - quit >= 15) { myconsoleClear(); numLeft = 0; }
							clearString(); snprintf(mystring,sizeof(mystring),"%s%s has left the game.%s",textColors[quit],quitName,WHITE);
							myprintf(mystring);
							if (quit > 0 && quit < num_bikes - 1) {
								if (quit < myNum) myNum--;
								for (int i = quit; i < num_bikes - 1; i++) {
									numLeft++;
									if (i == myNum) { clearString(); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE); }
									else clearString(); snprintf(mystring,sizeof(mystring),"  %s%s%s is now %s%s%s!", textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE);
									myprintf(mystring);
									sprites[i] = sprites[i+1];
									sprites[i].image = i;
								}
								quit = -1;
							}
							oldQuit = -1;
							quit = -1;
						}
					/*int foundNum = -1;
					for (int i = 0; i < constatus.total_nodes; i++) {
						numLeft++;
						ret = udsGetNodeInformation(i,&tmpnode);
						udsGetNodeInfoUsername(&tmpnode,&sprites[i - 1].username);
						if (!strcmp(sprites[i].username,myname)) foundNum = i;
						myprintf("\x1b[%d;0H%s == %s? (%d)\n",numLeft + 5, sprites[i].username, myname,i);
					}
					if (foundNum == -1) myNum = constatus.total_nodes - 1;*/
					num_bikes = constatus.total_nodes;
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					memset(replyChange,1,sizeof(replyChange[0]) * 10);
					}
				}
			}
		}
	}
//---------------------------------------------------------------------------------
int main(int argc, char **argv) {
//---------------------------------------------------------------------------------
	srand(time(NULL));
	// Initialize graphics
	gfxInitDefault();
	C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);

	// Output at 100% on the first pair of left and right channels.


	// Initialize the render target
	target = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	target2 = C3D_RenderTargetCreate(240, 320, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target2, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target2, GFX_BOTTOM, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	Result res = fontEnsureMapped();

	if (R_FAILED(res))
		return 1;
	//consoleInit(GFX_BOTTOM, NULL); //Print to bottom screen
	// Initialize the scene
	sceneInit();

	ret = 0;
	ret = udsInit(0x3000, NULL);//The sharedmem size only needs to be slightly larger than the total recv_buffer_size for all binds, with page-alignment.
	uds_enabled = true;
	if(R_FAILED(ret))
	{
		uds_enabled = false;
		if (ret == 0xc9411002) {
			myprintf("Wi-Fi must be turned on local play!");
			myprintf("Be sure you switch your wifi on");
			myprintf("For old 3ds, its the switch on the right");
			myprintf("\x1b[6;0HPress A or START to play offline.");
		}
		else {
			clearString(); snprintf(mystring,sizeof(mystring),"udsInit failed: 0x%08x.\n\nPress A or START to play offline.", (unsigned int)ret);
			myprintf(mystring);
		}
		while(aptMainLoop()) {
			keepConsole();
			gfxFlushBuffers();
			gfxSwapBuffers();
			hidScanInput();
			if (hidKeysDown() & KEY_START) break;
			if (hidKeysDown() & KEY_A) break;
		}
		myconsoleClear();
	}
	uds_test();
	size_t tmpbuf_size = 0x4000;
	u32 *tmpbuf = malloc(tmpbuf_size);
	size_t actual_size;
	u32 kDown;
	if (debugging) if (CATASTROPHIC_FAILURE) {
		clearString(); snprintf(mystring,sizeof(mystring),"%sCATASTROPHIC_FAILURE",RED);
		myprintf(mystring);
		while (aptMainLoop()) {
			keepConsole();
			gfxFlushBuffers();
			gfxSwapBuffers();
			hidScanInput();
			if (hidKeysDown() & KEY_START) break;
		}
	}
	if (uds_enabled) {

		if (myNum) {
			sprites[myNum].node = myNode;
			memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
			strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
			sprites[myNum].image = myNode;
			sprites[myNum].node = myNode;
			msg.sprite = sprites[myNum];
			msg.sprite.speed = 999; 
			UDSSend(msg);
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick(); 
			if (debugging) myprintf("Sending quit message...");
			while (aptMainLoop()) {
				keepConsole();
				gfxFlushBuffers();
				gfxSwapBuffers();
				hidScanInput();
				kDown = hidKeysDown();
				u32 kUp = hidKeysUp();
				if (kDown & KEY_START && kUp & KEY_START) {
					if (debugging) myprintf("...you stopped?");
					break;
				}
				if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					sprites[myNum].node = myNode;
					memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
					sprites[myNum].image = myNode;
					sprites[myNum].node = myNode;
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 999;
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
				if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
				if(R_FAILED(ret))
				{
					clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.\nYou failed to leave the game. Press start.", (unsigned int)ret);
					myprintf(mystring);
					replay = false;
					CATASTROPHIC_FAILURE = true;
					while(aptMainLoop()) {
						keepConsole();
						gfxFlushBuffers();
						gfxSwapBuffers();
						hidScanInput();
						kDown = hidKeysDown();
						if (kDown & KEY_START) break;
					}
					break;
				}
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					//if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"image: %d sender: %d node: %d speed: %d", msg.sprite.image, msg.sender, msg.sprite.node, msg.sprite.speed); myprintf(mystring); }
					if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.timestamp == lastSprite) { if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"%d leaving: %d",myNode,msg.sprite.node); myprintf(mystring); } replySprite[msg.sprite.node] = true; }
					int responded = 0;
					for (int i = 0; i <= NUM_SPRITES; i++) {
						if (i != myNode && replySprite[i]) responded++;
					}
					if (responded >= num_bikes - 1) {
						if (debugging) myprintf("You successfuly left.");
						break;
					}
				}
			}
		}
		if(!myNum)
		{
			udsDestroyNetwork();
		}
		else
		{
			udsDisconnectNetwork();
		}
		udsUnbind(&bindctx);
		udsExit();
	}
	if (!CATASTROPHIC_FAILURE) {
		if (debugging) myprintf("You were successfully removed from the game.");
		if (debugging) {
			while (aptMainLoop()) {
				keepConsole();
				gfxFlushBuffers();
				gfxSwapBuffers();
				hidScanInput();
				kDown = hidKeysDown();
				if (kDown & KEY_START) break;
			}
		}
	}


	// Deinitialize the scene
	sceneExit();

	// Deinitialize graphics
	C3D_Fini();
	gfxExit();
	return 0;
}
