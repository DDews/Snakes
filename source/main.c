#include <3ds.h>
#include <citro3d.h>

#include <sys/dirent.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <errno.h>
#include <stdarg.h>
#include <unistd.h>
#include <inttypes.h>

#include "lodepng.h"

// These headers are generated by the build process
#include "vshader_shbin.h"
//#include "textshader_shbin.h"

#include "bike_png.h"
#include "qrcode_png.h"

#define VERSION "0.2.4"

#define CLEAR_COLOR 0x000000FF

#define NAME_SIZE 50
#define MOVE_UP 1
#define MOVE_DOWN 2
#define MOVE_LEFT 3
#define MOVE_RIGHT 4
#define TYPE_DEATH 5

#define NORTHEAST 1
#define SOUTHEAST 2
#define SOUTHWEST 3
#define NORTHWEST 4

#define ESC(x) "\x1b[" #x
#define RED     "!.r"
#define DARKRED "!.R"
#define GREEN   "!.g"
#define DARKERGREEN "!.G"
#define YELLOW  "!.y"
#define DARKYELLOW  "!.j"
#define BLUE    "!.b"
#define DARKBLUE "!.B"
#define MAGENTA "!.m"
#define DARKMAGENTA "!.M"
#define CYAN    "!.c"
#define DARKCYAN "!.C"
#define ORANGE  "!.o"
#define DARKORANGE "!.O"
#define DARKGREEN "!.d"
#define PINK "!.p"
#define DARKPINK "!.P"
#define WHITE "!.w"
#define GREY "!.W"
#define BLACK "!.z"
#define RAINBOW "!.u"

// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO)

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGBA8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

#define NUM_SPRITES 10
#define numBots 4

#define SAMPLERATE 22050
#define SAMPLESPERBUF (SAMPLERATE / 30)
#define BYTESPERSAMPLE 4
#define TEXT_VTX_ARRAY_COUNT (4*1024)
#define MODE_SPRITES 1
#define MODE_TEXT 2

typedef struct { float position[3]; float texcoord[2]; } textVertex_s;

static C3D_Tex* glyphSheets;
static textVertex_s* textVtxArray;
static int textVtxArrayPos = 0;

const static int BIKE_FAST = 15;
const static int BIKE_NORMAL = 45;
const static int BIKE_SLOW = 90;

u8 appdata[0x14] = {0x69, 0x8a, 0x05, 0x5c};

char tmpstr[256];

u64 stackTrace = 0;
bool patchConsole = false;
bool was_in_game = false;
bool network_created = false;
size_t tmpbuf_size = 0;
u32 *tmpbuf = NULL;

char gonOrOff[5];
char gselectedColor[5];
int gselected = 0;
int gload = 0;
int load = 0;
bool redo = true;
u64 glastLoad;
u64 lastLoad;
int specialSelection = -1;
char botsColor[20];

size_t beacon_size = 0x4000;
u32 *beacon_msg = NULL;

int hosting = 0;
int readyToJoin = 0;
udsNetworkStruct networkstruct;
udsNetworkScanInfo *networks = NULL;
udsNetworkScanInfo *network = NULL;
size_t total_networks = 0;
size_t actual_size = 0;
bool ignoreB = false;




char quitName[50];
int selected = 0;
u64 readyLock = 0;
int oldQuit = 0;
int numLeft = 0;
int oldspeed = 0;
int goDiag = 0;
int oldApplex = 0;
int oldAppley = 0;
int oldDx = 15;
bool saveReady = false;
bool displayedHS = false;
bool iWin = false;
int texEnvMode = 0;
u64 TICKS_PER_SEC = 268123480;
u64 TICKS_PER_MS = 268123;
bool movingApple = false;
int currentBots = 2;
bool plotting[numBots];
int epsilon = 1;
int oldBotSpeed = 90;
u32 highScore = 0;
u64 flash = 0;
bool ignoreDeath = true;
char consoleBuffer[30][100];
u32 colors[10] = { 0x000cff00, 0x00e4ff00, 0x00004eff, 0x00fc00ff, 0x0000fff0, 0x0025722c, 0x00ff9600, 0x00ff7f82, 0x00ffffff, 0x00000000 };
u64 waitForFinish = 0;
bool uds_enabled = false;
bool readyToStart = false;
bool debugging = false;
int numOptions = 11;
bool erased[11];
bool options[11];
char optionNames[11][50] = {"Boundaries kill", "Tron mode", "Disable Diagonals", "Disable A", "Disable B", "Disable Y", "Enable R", "No apple", "Apples double length", "Disappear on death", "Occasional holes"};
char loading[8][10] = {"","","","","","","",""};;
u32 recv_buffer_size = UDS_DEFAULT_RECVBUFSIZE;
u32 wlancommID = 0x783a9dab;//Unique ID, change this to your own.
char passphrase[100] = "dandewsudssnake.2.2 saadistheman";//Change this passphrase to your own. The input you use for the passphrase doesn't matter since it's a raw buffer.
static DVLB_s* vshader_dvlb;
static shaderProgram_s program;
static int uLoc_projection;
static C3D_Mtx projection;

//static DVLB_s* textshader_dvlb;
//static shaderProgram_s textprogram;
static C3D_Mtx textprojection;

bool autoPilot = false;
bool debugHold = false;
int hole = 0;
int totalSpace = 0;
int lastDead = 0;
char mystring[200];
bool cheats = false;
bool forfeit = false;
float oldpx = 0;
float oldpy = 0;
int diag = 0;
circlePosition oldCPos;
touchPosition touch;
int wakeup = false;
int myNode = 0;
bool CATASTROPHIC_FAILURE = false;
bool inGame = 0;
u16 src_NetworkNodeID;
udsBindContext bindctx;
u64 errorQuit = 0;
bool clearFlag = true;
char myName[50];
char overwriteName[50];
int quit = -1;
u32 dead;
u32 dead2;
bool addedToGame = true;
u64 lastSent = 0;
u64 UDSSent = 0;
circlePosition cpos;

bool replay = true;
bool connectionEstablished = false;
udsConnectionStatus constatus;

bool qrcode = false;
int oldDiag = 0;
u32 nextMove = 0;
u32 oldMove = 0;
bool usedSpecial[numBots];
u32 death = 0;
int myNum = 0;
int growthRate = 40;
int growth[10] = {40,40,40,40,40,40,40,40,40,40};

int pathPos[10] = {0,0,0,0,0,0,0,0,0,0};
int currentPath[10] = {1,1,1,1,1,1,1,1,1,1};

bool ready[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

int bikeSpeed = 2;
static u32 darken(u32 color, float shade_factor) {
	u32 r = color & (u32)0x00ff0000;
	r >>= 16;
	u32 g = color & (u32)0x0000ff00;
	g >>= 8;
	u32 b = color & (u32)0x000000ff;
	return 0xff000000 | (u32)(r * (1 - shade_factor)) << 16 | (u32)(g * (1 - shade_factor)) << 8 | (u32)(b * (1 - shade_factor));
}
static u32 lighten(u32 color, float tint_factor) {
	u32 r = color & (u32)0x00ff0000;
	r >>= 16;
	u32 g = color & (u32)0x0000ff00;
	g >>= 8;
	u32 b = color & (u32)0x000000ff;
	return 0xff000000 | (u32)(r + (255 - r) * tint_factor) << 16 | (u32)(g + (255 - g) * tint_factor) << 8 | (u32)(b + (255 - b) * tint_factor);
}
static u32 HSL2RGB(float h, float sl, float l)
{
    float v;
    float r,g,b;

    r = l;   // default to gray
    g = l;
    b = l;
    v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);
    if (v > 0)
    {
          float m;
          float sv;
          int sextant;
          float fract, vsf, mid1, mid2;

          m = l + l - v;
          sv = (v - m ) / v;
          h *= 6.0;
          sextant = (int)h;
          fract = h - sextant;
          vsf = v * sv * fract;
          mid1 = m + vsf;
          mid2 = v - vsf;
          switch (sextant)
          {
                case 0:
                      r = v;
                      g = mid1;
                      b = m;
                      break;
                case 1:
                      r = mid2;
                      g = v;
                      b = m;
                      break;
                case 2:
                      r = m;
                      g = v;
                      b = mid1;
                      break;
                case 3:
                      r = m;
                      g = mid2;
                      b = v;
                      break;
                case 4:
                      r = mid1;
                      g = m;
                      b = v;
                      break;
                case 5:
                      r = v;
                      g = m;
                      b = mid2;
                      break;
          }
    }
    u32 out = 0;
    out |= (int)(r * 255.0f);
    out |= (int)(g * 255.0f);
    out |= (int)(b * 255.0f) << 16;
    out |= 0xff000000;
    return out;
}
void fill_buffer(void* audioBuffer, size_t offset, size_t size, int frequency) {
	u32* dest = (u32*) audioBuffer;

	for (int i = 0; i < size; i++) {
		// This is a simple sine wave, with a frequency of `frequency` Hz, and an amplitude 30% of maximum.
		s16 sample = 0.3 * 0x7FFF * sin(frequency * (2 * M_PI) * (offset + i) / SAMPLERATE);

		// Stereo samples are interleaved: left and right channels.
		dest[i] = (sample << 16) | (sample & 0xffff);
	}

	DSP_FlushDataCache(audioBuffer, size);
}
//simple sprite struct
typedef struct {
	int x,y;			// screen co-ordinates 
	int dx, dy;			// velocity
	int image;
	int speed;
	int length;
	bool dead;
	int node;
	int diag;
	bool forwards;
	u8 hole;
	char username[NAME_SIZE];
}Sprite;

typedef struct scene_s {
    void (*init)(); //the initialization function of the scene
    void (*update)(); //function pointer to update function
    void (*draw)(); //function pointer to draw function
    void (*finish)(); //function pointer to clean up function
    bool initialized;
    struct scene_s * next; //next Scene in the stack
}Scene;
 
 
Scene *scenes = NULL; //the top of the stack
Scene *oldScene = NULL;
int numScenes = 0;


typedef struct bot_s {
	int can_go_fast;
	int precision;
	int patience;
	int fudge_x;
	int fudge_y;
	int fudge_factor;
	int difficulty;
	u64 last_speed_change;
}Bot;

Bot bots[numBots];
int numOpponents = 1;


typedef struct path_s {
	int x, y;
	struct path_s * next;
}Path;
Path path[200 * 120][NUM_SPRITES];

//autopilot and ai
u64 giveUpTimer[numBots];
u64 timeTilDeath[numBots];
Path *openSet[numBots];
Path cameFrom[numBots][401][241];
Path totalPath[numBots][401 * 241];
int totalPathN[numBots];
int openSetN[numBots];
Path *closedSet[numBots];
int closedSetN[numBots];
int gscore[numBots][401][241];
int fscore[numBots][401][241];

typedef struct {
	int x, y;
}Apple;

typedef struct {
	Sprite sprite;
	u64 timestamp;
	int sender;
}Message;

u64 lastApple = 0;

u64 lastRainbow = 0;
float rainbow = 0.0f;

int actual_bikes = 1;
Message sentMsg;
u64 lastScore;
u64 lastChange;
u64 lastSprite;
u64 lastDeadmsg;
u64 lastHighscore;
u64 lastScreenScore;
bool replyScreenScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool receivedScreenScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyDead[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyHighscore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyChange[10] = {0,0,0,0,0,0,0,0,0,0};
bool replySprite[10] = {0,0,0,0,0,0,0,0,0,0};

udsNodeInfo tmpnode;
Result ret=0;
u32 failure = 0;


u32 gameOver = 0;
Apple apple;
Message msg;
udsConnectionType conntype;

int num_bikes = 1;
Sprite sprites[NUM_SPRITES];

u32 con_type = 0;


C3D_RenderTarget* target;
C3D_RenderTarget* target2;


u64 frameTicks[10];

int score[10] = {0,0,0,0,0,0,0,0,0,0};
int oldscore[10];

int joinedNum = 0;
int oldbikes;

u8* frameBuf;
static float printy = 10.0;
static float printx = 10.0;
void pushScene(void (*initialization)(), void (*update)(), void (*draw)(), void (*finish)());
void popScene();
int getHighestScore();
int dangerousNeighbors(int x, int y, int s);
void game_init();
void game_update();
void connect_update();
void setup_init();
void setup_update();
void scan_finish();
void wait_for_player_init();
void wait_for_player_update();
void roundEnd_init();
void roundEnd_update();
void gameOptions_init();
void gameOptions();
void opponent_options_update();
void opponent_options_init();
void opponent_options_draw();
void opponent_options_finish();
void difficulty_menu_init();
void difficulty_menu_update();
void difficulty_menu_draw();
void difficulty_menu_finish();
void options_menu_init();
void options_menu_update();
void options_menu_draw();
void options_menu_finish();
void send_bike_init();
void send_bike_update();
void send_bike_finish();
void send_request_init();
void displayMessage();
void displayMessageInit();
void displayMessageFinish();
void send_request_update();
void send_quit_init();
void send_quit_update();
void send_quit_finish();
void receive_bike_init();
void receive_bike_update();
void prepare_room_update();
void prepare_room_finish();
void failure_message_init();
void failure_message_update();
void failure_message_finish();
int optionsToInt() {
    int ret = 0;
    int tmp;
    for (int i = 0; i < numOptions; i++) {
        tmp = options[i];
        ret |= tmp << (i);
    }
    return ret;
}
static void clearString() {
	memset(mystring,0,sizeof(mystring));
}
void setOptions(unsigned int n) {
	for (unsigned int i = 0; i != numOptions; ++i)
	{
	  options[i] = n & 1;
	  n /= 2;
	}
}

int numPlayers() {
	if (actual_bikes > 1) return actual_bikes;
	return actual_bikes + numOpponents;
}
int toBot(int s) {
	if (autoPilot && s == myNum) return 0;
	if (s >= currentBots) return 0;
	return s;
}
int getBot(int s) {
	if (s == 0) return myNum;
	if (s >= currentBots) return currentBots - 1;
	return s;
}

static void screen_get_string_size_internal(float* width, float* height, const char* text, float scaleX, float scaleY, bool oneLine, bool wrap, float wrapX) {
    float w = 0;
    float h = 0;
    float lineWidth = 0;

    if(text != NULL) {
        h = scaleY * fontGetInfo()->lineFeed;

        const uint8_t* p = (const uint8_t*) text;
        const uint8_t* lastAlign = p;
        u32 code = 0;
        ssize_t units = -1;
        while(*p && (units = decode_utf8(&code, p)) != -1 && code > 0) {
            p += units;

            if(code == '\n' || (wrap && lineWidth + scaleX * fontGetCharWidthInfo(fontGlyphIndexFromCodePoint(code))->charWidth >= wrapX)) {
                lastAlign = p;

                if(lineWidth > w) {
                    w = lineWidth;
                }

                lineWidth = 0;

                if(oneLine) {
                    break;
                }

                h += scaleY * fontGetInfo()->lineFeed;
            }

            if(code != '\n') {
                u32 num = 1;
                if(code == '\t') {
                    code = ' ';
                    num = 4 - (p - units - lastAlign) % 4;

                    lastAlign = p;
                }

                lineWidth += (scaleX * fontGetCharWidthInfo(fontGlyphIndexFromCodePoint(code))->charWidth) * num;
            }
        }
    }

    if(width) {
        *width = lineWidth > w ? lineWidth : w;
    }

    if(height) {
        *height = h;
    }
}
void screen_get_string_size_wrap(float* width, float* height, const char* text, float scaleX, float scaleY, float wrapX) {
    screen_get_string_size_internal(width, height, text, scaleX, scaleY, false, true, wrapX);
}
static void setTextColor(u32 color)
{
	texEnvMode = MODE_TEXT;
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_RGB, GPU_CONSTANT, 0, 0);
	C3D_TexEnvSrc(env, C3D_Alpha, GPU_TEXTURE0, GPU_CONSTANT, 0);
	C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
	C3D_TexEnvFunc(env, C3D_RGB, GPU_REPLACE);
	C3D_TexEnvFunc(env, C3D_Alpha, GPU_MODULATE);
	C3D_TexEnvColor(env, color);
}

static void addTextVertex(float vx, float vy, float tx, float ty)
{
	textVertex_s* vtx = &textVtxArray[textVtxArrayPos++];
	vtx->position[0] = vx;
	vtx->position[1] = vy;
	vtx->position[2] = 0.5f;
	vtx->texcoord[0] = tx;
	vtx->texcoord[1] = ty;
}
static void renderText(float x, float y, float scaleX, float scaleY, bool baseline, const char* text)
{
	ssize_t  units;
	uint32_t code;

	// Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);
	BufInfo_Add(bufInfo, textVtxArray, sizeof(textVertex_s), 2, 0x10);

	const uint8_t* p = (const uint8_t*)text;
	float firstX = x;
	u32 flags = GLYPH_POS_CALC_VTXCOORD | (baseline ? GLYPH_POS_AT_BASELINE : 0);
	int lastSheet = -1;
	do
	{
		if (!*p) break;
		units = decode_utf8(&code, p);
		if (units == -1)
			break;
		p += units;
		if (code == '\n')
		{
			x = firstX;
			y += scaleY*fontGetInfo()->lineFeed;
		}
		else if (code > 0)
		{
			int glyphIdx = fontGlyphIndexFromCodePoint(code);
			fontGlyphPos_s data;
			fontCalcGlyphPos(&data, glyphIdx, flags, scaleX, scaleY);

			// Bind the correct texture sheet
			if (data.sheetIndex != lastSheet)
			{
				lastSheet = data.sheetIndex;
				C3D_TexBind(0, &glyphSheets[lastSheet]);
			}

			int arrayIndex = textVtxArrayPos;
			if ((arrayIndex+4) >= TEXT_VTX_ARRAY_COUNT)
				break; // We can't render more characters

			// Add the vertices to the array
			addTextVertex(x+data.vtxcoord.left,  y+data.vtxcoord.bottom, data.texcoord.left,  data.texcoord.bottom);
			addTextVertex(x+data.vtxcoord.right, y+data.vtxcoord.bottom, data.texcoord.right, data.texcoord.bottom);
			addTextVertex(x+data.vtxcoord.left,  y+data.vtxcoord.top,    data.texcoord.left,  data.texcoord.top);
			addTextVertex(x+data.vtxcoord.right, y+data.vtxcoord.top,    data.texcoord.right, data.texcoord.top);

			// Draw the glyph
			C3D_DrawArrays(GPU_TRIANGLE_STRIP, arrayIndex, 4);

			x += data.xAdvance;

		}
	} while (code > 0);
}
static void rText(float x, float y, float scaleX, float scaleY, bool baseline, const char* text) {
	setTextColor(0xffffffff); 
	char out[100];
	char sub[100];
	memset(out,0,sizeof(out));
	strncpy(out,text,sizeof(out) - 1);
	float height;
	float width;
	int i = 0;
	while (strstr(out,"!.") != NULL && i < 40) {
		i++;
		const char *result = strstr(out,"!.");
		int position = result - out + 3;
		int substringLength = strlen(out) - position;
		out[position - 3] = 0;
		renderText(x,y,.5f,.5f,true,out);
		screen_get_string_size_wrap(&width, &height, out, 0.5f, 0.5f, 320);
		x += width;
		float dark = 0.2f;
		if (out[position - 1] == 'r') setTextColor(0xff0000ff);
		else if (out[position - 1] == 'R') setTextColor(darken(0xff0000ff,dark));
		else if(out[position - 1] == 'g') setTextColor(colors[0] | 0xff000000);
		else if(out[position - 1] == 'G') setTextColor(darken(colors[0] | 0xff000000,dark));
		else if(out[position - 1] == 'y') setTextColor(0xff00ffe4);
		else if(out[position - 1] == 'Y') setTextColor(darken(0xff00ffe4,dark));
		else if(out[position - 1] == 'b') setTextColor(0xffff4e00);
		else if(out[position - 1] == 'B') setTextColor(darken(0xffff4e00,dark));
		else if(out[position - 1] == 'm') setTextColor(0xffff00fc);
		else if(out[position - 1] == 'M') setTextColor(darken(0xffff00fc,dark));
		else if(out[position - 1] == 'c') setTextColor(0xfff0ff00);
		else if(out[position - 1] == 'C') setTextColor(darken(0xfff0ff00,dark));
		else if(out[position - 1] == 'd') setTextColor(0xff2c7225);
		else if(out[position - 1] == 'D') setTextColor(darken(0xff2c7225,dark));
		else if(out[position - 1] == 'o') setTextColor(0xff0096ff);
		else if(out[position - 1] == 'O') setTextColor(darken(0xff0096ff,dark));
		else if(out[position - 1] == 'p') setTextColor(0xff827fff);
		else if(out[position - 1] == 'P') setTextColor(darken(0xff827fff,dark));
		else if(out[position - 1] == 'w') setTextColor(0xffffffff);
		else if(out[position - 1] == 'W') setTextColor(darken(0xffffffff,dark));
		else if(out[position - 1] == 'z') setTextColor(0xff000000);
		else if(out[position - 1] == 'Z') setTextColor(0xff000000);
		else if(out[position - 1] == 'j') setTextColor(0xff008275);
		else if(out[position - 1] == 'J') setTextColor(darken(0xff008275,dark));
		else if(out[position - 1] == 'u') setTextColor(HSL2RGB(rainbow,0.5,0.5));
		memset(sub,0,sizeof(sub));
		snprintf(sub,sizeof(sub),"%.*s",substringLength,out + position);
		result = strstr(sub,"!.");
		if (result != NULL) position = result - sub;
		else position = sizeof(sub) - 1;
		memset(out,0,sizeof(out));
		snprintf(out,sizeof(out),"%.*s",sizeof(sub) - position,sub + position);
		sub[position] = 0;
		//sprintf("%.*s",substringLength,out + position);
		renderText(x, y, .5f, .5f, true, sub);
		screen_get_string_size_wrap(&width, &height, sub, 0.5f, 0.5f, 320);
		x += width;
	}
	renderText(x, y, .5f, .5f, true, out);
}
int consolei = 0;
void keepXConsole() {
	if (svcGetSystemTick() - lastRainbow > TICKS_PER_MS * 30) { lastRainbow = svcGetSystemTick(); rainbow += 0.01; if (rainbow > 1) rainbow = 0.0f; }
	printy = 10.0;
	float height;
	float width;
	textVtxArrayPos = 0;
	char out[100];
	char sub[100];
	memset(out,0,sizeof(out));
	for (int i = 0; i <= consolei; i++) {
		printx = 0.0;
		setTextColor(0xffffffff); 
		if (strlen(consoleBuffer[i]) > 0) {
			strncpy(out,consoleBuffer[i],sizeof(out));
			int i = 0;
			while (strstr(out,"!.") != NULL && i < 40) {
				i++;
				const char *result = strstr(out,"!.");
				int position = result - out + 3;
				int substringLength = strlen(out) - position;
				out[position - 3] = 0;
				renderText(printx,printy,.5f,.5f,true,out);
				screen_get_string_size_wrap(&width, &height, out, 0.5f, 0.5f, 320);
				printx += width;
				float dark = 0.2f;
				if (out[position - 1] == 'r') setTextColor(0xff0000ff);
				else if (out[position - 1] == 'R') setTextColor(darken(0xff0000ff,dark));
				else if(out[position - 1] == 'g') setTextColor(colors[0] | 0xff000000);
				else if(out[position - 1] == 'G') setTextColor(darken(colors[0] | 0xff000000,dark));
				else if(out[position - 1] == 'y') setTextColor(0xff00ffe4);
				else if(out[position - 1] == 'Y') setTextColor(darken(0xff00ffe4,dark));
				else if(out[position - 1] == 'b') setTextColor(0xffff4e00);
				else if(out[position - 1] == 'B') setTextColor(darken(0xffff4e00,dark));
				else if(out[position - 1] == 'm') setTextColor(0xffff00fc);
				else if(out[position - 1] == 'M') setTextColor(darken(0xffff00fc,dark));
				else if(out[position - 1] == 'c') setTextColor(0xfff0ff00);
				else if(out[position - 1] == 'C') setTextColor(darken(0xfff0ff00,dark));
				else if(out[position - 1] == 'd') setTextColor(0xff2c7225);
				else if(out[position - 1] == 'D') setTextColor(darken(0xff2c7225,dark));
				else if(out[position - 1] == 'o') setTextColor(0xff0096ff);
				else if(out[position - 1] == 'O') setTextColor(darken(0xff0096ff,dark));
				else if(out[position - 1] == 'p') setTextColor(0xff827fff);
				else if(out[position - 1] == 'P') setTextColor(darken(0xff827fff,dark));
				else if(out[position - 1] == 'w') setTextColor(0xffffffff);
				else if(out[position - 1] == 'W') setTextColor(darken(0xffffffff,dark));
				else if(out[position - 1] == 'z') setTextColor(0xff000000);
				else if(out[position - 1] == 'Z') setTextColor(0xff000000);
				else if(out[position - 1] == 'j') setTextColor(0xff008275);
				else if(out[position - 1] == 'J') setTextColor(darken(0xff008275,dark));
				else if(out[position - 1] == 'u') setTextColor(HSL2RGB(rainbow,0.5,0.5));
				memset(sub,0,sizeof(sub));
				snprintf(sub,sizeof(sub),"%.*s",substringLength,out + position);
				result = strstr(sub,"!.");
				if (result != NULL) position = result - sub;
				else position = sizeof(sub) - 1;
				memset(out,0,sizeof(out));
				snprintf(out,sizeof(out),"%.*s",sizeof(sub) - position,sub + position);
				sub[position] = 0;
				//sprintf("%.*s",substringLength,out + position);
				renderText(printx, printy, .5f, .5f, true, sub);
				screen_get_string_size_wrap(&width, &height, sub, 0.5f, 0.5f, 320);
				printx += width;
			}
			renderText(printx, printy, .5f, .5f, true, out);
		}
		screen_get_string_size_wrap(NULL, &height, ".", 0.5f, 0.5f, 320);
		printy += height;
		if (printy > 320) break;
	}
}
void keepSConsole() {
	keepXConsole();
}
void keepConsole() {
	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
	C3D_FrameDrawOn(target2);
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &textprojection);
	keepXConsole();
	C3D_FrameEnd(0);
}
void disconnectNetwork() {
	if (uds_enabled) {
		if(hosting && network_created)
		{
			network_created = false;
			udsDestroyNetwork();
		}
		else if (myNum)
		{
			myNum = 0;
			udsDisconnectNetwork();
		}
		udsUnbind(&bindctx);
	}
}
void myprintf(const char *format, ...) {
	if (strstr(format,"[") != NULL && format[0] == '\x1b') {
		char sub[100];
		memset(sub,0,sizeof(sub));
		const char *result = strstr(format,"[");
		int position = result - format + 1;
		int substringLength = strlen(format) - position;
		snprintf(sub,sizeof(sub),"%.*s",substringLength,format + position);
		if (strstr(sub,";") != NULL) {
			char num[20];
			result = strstr(sub,";");
			position = result - sub;
			if (position > 2) return;
			memset(num,0,sizeof(num));
			snprintf(num,sizeof(num),"%.*s",position,sub);
			int n;
			sscanf(num,"%d",&n);
			if (n > 15 || n < 0) return;
			if (strstr(sub,"H") == NULL) return;
			result = strstr(sub,"H");
			position = result - sub + 1;
			memset(consoleBuffer[n],0,sizeof(consoleBuffer[n]));
			snprintf(consoleBuffer[n],sizeof(consoleBuffer[n]),"%.*s",strlen(sub) - position,sub + position);
			if (n > consolei && n < 14) consolei = n + 1;
			else if (n == consolei && n < 15) consolei++;
			return;
		} else return;
	}
	if (consolei >= 15) {
		for (int i = 0; i < 15; i++) {
			strncpy(consoleBuffer[i],consoleBuffer[i+1],sizeof(consoleBuffer[i]) - 1);
		}
		consolei = 15;
	}
	snprintf(consoleBuffer[consolei], sizeof(consoleBuffer[consolei]), "%s", format);
	if (consolei < 15) consolei += 1;
	//keepConsole();
	return;
}
Path current[numBots];
void util_free_path_utf8(FS_Path* path) {
    free((void*) path->data);
    free(path);
}
FS_Path* util_make_path_utf8(const char* path) {
    size_t len = strlen(path);

    u16* utf16 = (u16*) calloc(len + 1, sizeof(u16));
    if(utf16 == NULL) {
        return NULL;
    }

    ssize_t utf16Len = utf8_to_utf16(utf16, (const uint8_t*) path, len);

    FS_Path* fsPath = (FS_Path*) calloc(1, sizeof(FS_Path));
    if(fsPath == NULL) {
        free(utf16);
        return NULL;
    }

    fsPath->type = PATH_UTF16;
    fsPath->size = (utf16Len + 1) * sizeof(u16);
    fsPath->data = utf16;

    return fsPath;
}
Result importUsername() {
	char pathBuf[64];
	snprintf(pathBuf, 64, "/snakes.dat");

	Result res = 0;

	FS_Path* fsPath = util_make_path_utf8(pathBuf);
	if(fsPath != NULL) {
	    char name[50];
	    u32 score = 0;

	    Handle fileHandle = 0;
	    if(R_SUCCEEDED(res = FSUSER_OpenFileDirectly(&fileHandle, ARCHIVE_SDMC, fsMakePath(PATH_EMPTY, ""), *fsPath, FS_OPEN_READ, 0))) {
	        u32 bytesRead = 0;
	        res = FSFILE_Read(fileHandle, &bytesRead, 0, name, sizeof(name));
	        if (bytesRead > 0) {
		        clearString();
		        /*snprintf(mystring,sizeof(mystring),"size: %d",bytesRead);
		        myprintf(mystring);*/
		        snprintf(overwriteName,sizeof(overwriteName),"%s",name);
	    	}
	    	res = FSFILE_Read(fileHandle, &bytesRead, sizeof(name), &score, sizeof(score));
	        if (bytesRead > 0) {
	        	snprintf(mystring,sizeof(mystring),"Current Highscore: %" PRIu32,score);
	        	myprintf(mystring);
	        	highScore = score;
	        }
	        FSFILE_Close(fileHandle);
	    }

	    util_free_path_utf8(fsPath);

	    if(R_SUCCEEDED(res)) {
	    	if (strlen(overwriteName) > 0) {
		    	clearString();
		    	snprintf(mystring,sizeof(mystring),"Welcome, %s",overwriteName);
		    	myprintf(mystring);
	    	}
	    } else {
	    	//myprintf("Creating save file...");
	    	FILE *fp;
	    	fp = fopen("sdmc:/snakes.dat", "wb");
	    	fclose(fp);
	    }
	} else {
		//myprintf("Creating save file...");
    	FILE *fp;
    	fp = fopen("sdmc:/snakes.dat", "wb");
    	fclose(fp);
	    res = -1;
	}

	return res;
}
Result writeUsername() {
	char pathBuf[64];
	snprintf(pathBuf, 64, "/snakes.dat");

	Result res = 0;

	FS_Path* fsPath = util_make_path_utf8(pathBuf);
	if(fsPath != NULL) {

	    Handle fileHandle = 0;
	    if(R_SUCCEEDED(res = FSUSER_OpenFileDirectly(&fileHandle, ARCHIVE_SDMC, fsMakePath(PATH_EMPTY, ""), *fsPath, FS_OPEN_WRITE, 0))) {
	        u32 bytesRead = 0;
	        res = FSFILE_Write(fileHandle, &bytesRead, 0, overwriteName, sizeof(overwriteName), 0);

	        res = FSFILE_Write(fileHandle, &bytesRead, sizeof(overwriteName), &highScore, sizeof(highScore), 0);
	        FSFILE_Close(fileHandle);
	    }

	    util_free_path_utf8(fsPath);

	    if(R_SUCCEEDED(res)) {
	        if (debugging) myprintf("Successfully saved usename.");
	    } else {
	    	if (debugging) myprintf("Couldn't write to file.");
	    }
	} else {
		if (debugging) myprintf("Something went wrong saving username.");
	    res = -1;
	}

	return res;
}
static C3D_Tex spritesheet_tex;
static C3D_Tex qrcode_tex;
int getImg(int img) {
	if (sprites[img].hole) return 9;
	return img;
}
int getAndDecImg(int img) {
	if (sprites[img].hole) { sprites[img].hole--; if (sprites[img].hole) return 9; }
	return img;
}
void myconsoleClear() {
	consolei = 0;
	memset(consoleBuffer,0,sizeof(consoleBuffer[0][0]) * 100 * 30);
	return;
}
int getLength(int num) {
	u32 max = 200 * 120;
	if (num >= numPlayers()) return 0;
	if (currentPath[num] < pathPos[num]) return (int)((max - pathPos[num]) + currentPath[num]);
	return (int)(currentPath[num] - pathPos[num]);
}

struct { float left, right, top, bottom; } images[12] = {
	{0.5f, 0.625f, 0.0f, 0.125f}, //bikes
	{0.625f, 0.75f, 0.0f, 0.125f},
	{0.75f, 0.875f, 0.0f, 0.125f},
	{0.875f, 1.0f, 0.0f, 0.125f},
	{0.5f, 0.625f, 0.125f, 0.25f},
	{0.625f, 0.75f, 0.125f, 0.25f},
	{0.75f, 0.875f, 0.125f, 0.25f},
	{0.875f, 1.0f, 0.125f, 0.25f},
	{0.5f, 0.75f, 0.25f, 0.5f}, //apple
	{0.75f, 1.0f, 0.25f, 0.5f}, //erase
	{0.0f, 0.5f, 0.0f, 0.5f}, //splash screen
	{0.0f, 1.0f, 0.0f, 1.0f}, //qrcode
};
char textColors[10][12] = {GREEN, YELLOW, BLUE, MAGENTA, CYAN, DARKGREEN, ORANGE, PINK, RAINBOW, WHITE};
char darkColors[10][12] = {DARKERGREEN, DARKYELLOW, DARKBLUE, DARKMAGENTA, DARKCYAN, DARKGREEN, DARKORANGE, DARKPINK, RAINBOW, GREY};
char colorNames[10][12] = {"Green", "Yellow", "Blue", "Magenta", "Cyan", "Dark Green", "Orange", "Pink", "Rainbow", "Black"};

u32 getNextColor(int x, int y) { // Thank you WolfVak for the code!
	if (x > 400) x = 0;
	else if(x < 0) x = 400;
	if (y > 240) y = 0;
	else if (y < 0) y = 240;
	for (int i = 0; i < numPlayers(); i++) {
		if (sprites[i].dead) continue;
		if (abs(x - sprites[i].x) < 2 && abs(y - sprites[i].y) < 2) return colors[i];
	}
	u32 offset = ((x * 240) - y + 239) * 3;
	return (u32) (frameBuf[offset] | frameBuf[offset + 1] << 8 | frameBuf[offset  + 2] << 16);
}
u32 getColor(int x, int y) { // Thank you WolfVak for the code!
	if (x > 400) x = 0;
	else if(x < 0) x = 400;
	if (y > 240) y = 0;
	else if (y < 0) y = 240;
	u32 offset = ((x * 240) - y + 239) * 3;
	return (u32) (frameBuf[offset] | frameBuf[offset + 1] << 8 | frameBuf[offset  + 2] << 16);
}
void writeColor(int x, int y, u32 color) {
	if (x > 400) x = 0;
	else if(x < 0) x = 398;
	if (y > 240) y = 0;
	else if (y < 0) y = 238;
	u32 offset = ((x * 240) - y + 239) * 3;
	frameBuf[offset] = color;
	frameBuf[offset + 1] = color >> 8;
	frameBuf[offset + 2] = color >> 16;
}
void showMemoryError() {
	myprintf("Error: ran out of memory...");
	while (aptMainLoop()) {
		keepConsole();
		hidScanInput();
		if (hidKeysDown() & KEY_START) {
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			return;
		}
	}
}
void addClosedSet(int x, int y, int s) {
	Path * newNode;
	newNode = malloc(sizeof(Path));
	if (newNode == NULL) {
		showMemoryError();
		return;
	}
	newNode->x = x;
	newNode->y = y;
	if (closedSetN[s] > 0) newNode->next = closedSet[s];
	else newNode->next = NULL;
	closedSet[s] = newNode;
    closedSetN[s]++;
}
void clearClosedSet(int s) {
	if (closedSetN[s] == 0) return;
    Path * c;
    Path * temp;
    c = closedSet[s];
    if (c == NULL) return;
    while (c->next != NULL) {
    	temp = c;
        c = c->next;
        temp->next = NULL;
        free(temp);
    }
    free(c);
    closedSet[s] = NULL;
    closedSetN[s] = 0;
}
void remClosedSet(int x, int y, int s) {
	if (closedSetN[s] <= 0) return;
    Path * c;
    Path * prev = NULL;
    c = closedSet[s];
    if (c == NULL) return;
    if (c->x == x && c->y == y) {
    	Path * temp;
        temp = c->next;
        free(c);
        closedSet[s] = temp;
        closedSetN[s]--;
        return;
    }
    while (c->next != NULL) {
        prev = c;
        c = c->next;
        if (c->x == x && c->y == y) break;
    }
    if (c->x != x || c->y != y) return;
    if (prev == NULL) return;
    prev->next = c->next;
    free(c);
    c = NULL;
    closedSetN[s]--;
}
bool openSetNotEmpty(int s) {
	return openSetN[s] != 0;
}
int sanitizeX(int x) {
	if (x < 2) return 396;
	if (x > 396) return 2;
	return x;
	/*if (x > 398) return 0;
	else if (x < 0) return 398;
	return x;*/
}
int sanitizeY(int y) {
	if (y < 2) return 236;
	if (y > 236) return 2;
	return y;
	/*if (y > 238) return 0;
	else if (y < 0) return 238;
	return y;*/
}
bool inClosedSet(int x, int y, int s) {
	Path * c = closedSet[s];
    while (c != NULL) {
    	if (c->x == x && c->y == y) return true;
		c = c->next;
    }
	return false;
}
bool inOpenSet(int x, int y, int s) {
	Path * c = openSet[s];
    while (c != NULL) {
    	if (c->x == x && c->y == y) return true;
		c = c->next;
    }
	return false;
}
void addOpenSet(int x, int y, int s) {
	Path * newNode;
	newNode = malloc(sizeof(Path));
	if (newNode == NULL) {
		showMemoryError();
		return;
	}
	newNode->x = x;
	newNode->y = y;
	if (openSetN[s] > 0) newNode->next = openSet[s];
	else newNode->next = NULL;
	openSet[s] = newNode;
    openSetN[s]++;
}
void clearOpenSet(int s) {
	if (openSetN[s] == 0) return;
    Path * c;
    Path * temp;
    c = openSet[s];
    if (c == NULL) return;
    while (c->next != NULL) {
    	temp = c;
        c = c->next;
        temp->next = NULL;
        free(temp);
    }
    free(c);
    openSet[s] = NULL;
    openSetN[s] = 0;
}
void remOpenSet(int x, int y, int s) {
	if (openSetN[s] <= 0) return;
    Path * c;
    Path * prev = NULL;
    c = openSet[s];
    if (c == NULL) return;
    if (c->x == x && c->y == y) {
    	Path * temp;
        temp = c->next;
        free(c);
        openSet[s] = temp;
        openSetN[s]--;
        return;
    }
    while (c->next != NULL) {
        prev = c;
        c = c->next;
        if (c->x == x && c->y == y) break;
    }
    if (c->x != x || c->y != y) return;
    if (prev == NULL) return;
    prev->next = c->next;
    c->next = NULL;
    free(c);
    c = NULL;
    openSetN[s]--;
}
int getDist(int x, int y, int dx, int dy) {
	if (!options[0]) {
		/*if (dx % 2 != x % 2) {
			if (abs(dx - 1 - x) < abs(dx + 1 - x)) dx -= 1;
			else dx += 1;
		}
		if (dy % 2 != y % 2) {
			if (abs(dy - 1 - y) < abs(dy + 1 - y)) dy -= 1;
			else dy += 1;
		}*/
		int smallestx = abs(dx - x);
		int smallesty = abs(dy - y);
		if (398 - dx + x < smallestx) smallestx = 398 - dx + x - 2;
		else if (398 - x + dx < smallestx) smallestx = 398 - x + dx;
		if (238 - dy + y < smallesty) smallesty = 238 - dy + y - 2;
		else if (238 - y + dy < smallesty) smallesty = 238 - y + dy;
		return smallestx + smallesty;
	}
	return abs(dx - x) + abs(dy - y);
}
void addNode(int x, int y, int nx, int ny, int myGScore, int s) {
	int ac = getBot(s);
	gscore[s][nx][ny] = myGScore;
	fscore[s][nx][ny] = myGScore + getDist(nx,ny,sprites[ac].x ,sprites[ac].y);
}
void addNodeToApple(int x, int y, int nx, int ny, int myGScore, int s) {
	int danger = 1 + dangerousNeighbors(x,y,s);
	cameFrom[s][nx][ny].x = x;
	cameFrom[s][nx][ny].y = y;
	gscore[s][nx][ny] = myGScore;
	fscore[s][nx][ny] = myGScore + getDist(nx,ny,apple.x,apple.y) * danger;
}
void continueAddNodeToApple(int x, int y, int nx, int ny, int myGScore, int s) {
	int danger = 1 + dangerousNeighbors(x,y,s);
	cameFrom[s][nx][ny].x = x;
	cameFrom[s][nx][ny].y = y;
	gscore[s][nx][ny] = myGScore;
	fscore[s][nx][ny] = myGScore + getDist(nx,ny,apple.x,apple.y) * danger;
}
bool directions[4] = {false,false,false,false};
int getDirectionYFor(int i, int y, int s, int f) {
	f += 1;
	if (i == 0) return sanitizeY(y - 2 * f);
	else if (i == 1) return sanitizeY(y + 2 * f);
	return sanitizeY(y);
}
int getDirectionXFor(int i, int x, int s, int f) {
	f += 1;
	if (i == 2) return sanitizeX(x - 2 * f);
	else if (i == 3) return sanitizeX(x + 2 * f);
	return sanitizeX(x);
}
int getDirectionY(int i, int s) {
	if (i == 0) return sanitizeY(current[s].y - 2);
	else if (i == 1) return sanitizeY(current[s].y + 2);
	return sanitizeY(current[s].y);
}
int getDirectionX(int i, int s) {
	if (i == 2) return sanitizeX(current[s].x - 2);
	else if (i == 3) return sanitizeX(current[s].x + 2);
	return sanitizeX(current[s].x);
}
int getDirectionYTo(int i, int y, int s) {
	if (i == 0) return sanitizeY(y - 2);
	else if (i == 1) return sanitizeY(y + 2);
	else if (i == 2) return sanitizeY(y + 2);
	else if (i == 3) return sanitizeY(y - 2);
	else if (i == 4) return sanitizeY(y - 2);
	else if (i == 5) return sanitizeY(y + 2);
	return sanitizeY(y);
}
int getDirectionXTo(int i, int x, int s) {
	if (i <= 1) return sanitizeX(x - 2);
	else if (i == 2) return sanitizeX(x + 2);
	else if (i == 3) return sanitizeX(x + 2);
	else if (i <= 5) return sanitizeX(x);
	else if (i == 6) return sanitizeX(x - 2);
	else if (i == 7) return sanitizeX(x + 2);
	return sanitizeX(x);
}
int getDirection(int s) {
	int ac = getBot(s);
	int r = 0;
	int smallest = INT_MAX;
	for (int i = 0; i < 4; i++) {
		if (directions[i] && getDist(getDirectionX(i,s), getDirectionY(i,s),sprites[ac].x , sprites[ac].y ) < smallest) {
			smallest = getDist(getDirectionX(i,s),getDirectionY(i,s),sprites[ac].x , sprites[ac].y );
			r = i;
		}
	}
	return r;
}
int getDirectionToApple(int s) {
	int r = 0;
	int smallest = INT_MAX;
	for (int i = 0; i < 4; i++) {
		if (directions[i] && getDist(getDirectionX(i,s), getDirectionY(i,s),apple.x,apple.y) < smallest) {
			smallest = getDist(getDirectionX(i,s),getDirectionY(i,s),apple.x,apple.y);
			r = i;
		}
	}
	return r;
}
void setCurrentF(int s) {
	int smallest = INT_MAX;
	if (openSetN[s] <= 0) {
		current[s].x = 0;
		current[s].y = 0;
		return;
	}
	Path * c = openSet[s];
	while (c != NULL) {
		if (fscore[s][c->x][c->y] != 1 && fscore[s][c->x][c->y] < smallest) {
			smallest = fscore[s][c->x][c->y];
			current[s].x = c->x;
			current[s].y = c->y;
		}
		c = c->next;
	}
}
/*void setCurrentF2() {
	int smallest = INT_MAX;
	for (int i = 0; i < openSetN[s]; i++) {
		if (fscore[openSet[i].x][openSet[i].y] != 1 && fscore[openSet[i].x][openSet[i].y] < smallest) {
			smallest = fscore[openSet[i].x][openSet[i].y];
			current[s].x = openSet[i].x;
			current[s].y = openSet[i].y;
		}
	}
}*/
bool haveDirection() {
	for (int i = 0; i < 4; i++) {
		if (directions[i]) return true;
	}
	return false;
}
static int UDSSend(Message msg) {
	if (!uds_enabled || debugHold || num_bikes <= 1) return 0;
	msg.sender = myNum;
	//if (debugging) { snprintf(mystring,sizeof(mystring),"sending speed: %d image: %d diag: %d",msg.sprite.speed,msg.sprite.image,msg.sprite.diag); myprintf(mystring); }
	if (msg.sprite.image == myNum && msg.sprite.speed == 77) { msg.timestamp = lastScore; }
	else if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.sprite.node == myNode) { msg.timestamp = lastSprite; msg.sender = myNode; }
	else if (msg.sprite.speed == 2020 && myNum == 0) msg.timestamp = lastDeadmsg;
	else if (msg.sprite.speed == 5050 && myNum == msg.sprite.image) msg.timestamp = lastScreenScore;
	else if (msg.sprite.image == myNum && msg.sprite.speed == 66) { msg.timestamp = lastChange; }
	else if (msg.sprite.image == myNum) { msg.timestamp = lastSprite; }
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		ret = udsSendTo(UDS_BROADCAST_NETWORKNODEID, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			snprintf(mystring,sizeof(mystring),"Error: UDSSend() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			return 1;
		}
	}
	return 0;
}
int getMoveableRange(int s) {
	if (s >= numPlayers()) return 40;
	clearClosedSet(s);
	clearOpenSet(s);
	memset(gscore[s],1,sizeof(gscore[0][0][0]) * 401 * 241);
	memset(fscore[s],1,sizeof(fscore[0][0][0]) * 401 * 241);
	int x = sprites[s].x;
	int y = sprites[s].y;
	addOpenSet(x,y,s);
	gscore[s][x][y] = 0;
	fscore[s][x][y] = getDist(x,y,sprites[s].x ,sprites[s].y );
	int i = 0;
	while (openSetNotEmpty(s) && i < 80) {
		if (closedSetN[s] > 80) return 40;
		if (openSetN[s] > 80) return 40;
		hidScanInput();
		if (hidKeysDown() & KEY_START) break;
		//keepConsole();
		i++;
		setCurrentF(s);
		/*C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			writeColor(current[s].x,current[s].y,colors[4]);
		C3D_FrameEnd(0);*/
		if (abs((apple.x ) - current[s].x) < 3 && abs((apple.y ) - current[s].y) < 3) {
			return 40;
		}
		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection()  && m < 4) {
			m++;
			int d = getDirection(s);
			/*snprintf(mystring,sizeof(mystring),"dist: %d",getDist(getDirectionX(d,s),getDirectionY(d,s),sprites[s].x , sprites[s].y ));
			myprintf(mystring);*/
			if (!getColor(getDirectionX(d,s),getDirectionY(d,s)) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
				}
				directions[d] = false;
			}
			directions[d] = false;
		}

	}
	return closedSetN[s] / 2;
}
void getMoveableRangeApple(int s) {
	if (s >= numPlayers()) return;
	u64 startPath = svcGetSystemTick();
	clearClosedSet(s);
	clearOpenSet(s);
	memset(gscore[s],1,sizeof(gscore[0][0][0]) * 401 * 241);
	memset(fscore[s],1,sizeof(fscore[0][0][0]) * 401 * 241);
	int x = sprites[s].x;
	int y = sprites[s].y;
	addOpenSet(x,y,s);
	gscore[s][x][y] = 0;
	fscore[s][x][y] = getDist(x,y,sprites[s].x ,sprites[s].y );
	int i = 0;
	while (openSetNotEmpty(s) && i < 400) {
		if ((svcGetSystemTick() - startPath) / TICKS_PER_MS / (sprites[s].speed / 3)) {
			if (closedSetN[s] >= 0) {
				apple.x = ((rand() % (400 - 64)) + 30);
				apple.y = ((rand() % (240 - 64)) + 30);
				while (getColor(apple.x , apple.y ) || getColor((apple.x ) + 1, (apple.y ) + 1)) {
					apple.x = ((rand() % (400 - 64)) + 30);
					apple.y = ((rand() % (240 - 64)) + 30);
				}
				return;
			}
			apple.x = closedSet[s]->x;
			apple.y = closedSet[s]->y;
			return;
		}
		if (closedSetN[s] > 400) { 
			apple.x = closedSet[s]->x;
			apple.y = closedSet[s]->y;
			return;
		}
		if (openSetN[s] > 400) {
			if (closedSetN[s] <= 0) {
				apple.x = ((rand() % (400 - 64)) + 30);
				apple.y = ((rand() % (240 - 64)) + 30);
				while (getColor(apple.x , apple.y ) || getColor((apple.x ) + 1, (apple.y ) + 1)) {
					apple.x = ((rand() % (400 - 64)) + 30);
					apple.y = ((rand() % (240 - 64)) + 30);
				}
				return;
			}
			apple.x = closedSet[s]->x;
			apple.y = closedSet[s]->y;
			return;
		}
		hidScanInput();
		if (hidKeysDown() & KEY_START) {
			if (closedSet[s] == NULL) {
				apple.x = ((rand() % (400 - 64)) + 30);
				apple.y = ((rand() % (240 - 64)) + 30);
				while (getColor(apple.x , apple.y ) || getColor((apple.x ) + 1, (apple.y ) + 1)) {
					apple.x = ((rand() % (400 - 64)) + 30);
					apple.y = ((rand() % (240 - 64)) + 30);
				}
				return;
			}
			apple.x = closedSet[s]->x;
			apple.y = closedSet[s]->y;
			return;
		}
		//keepConsole();
		i++;
		setCurrentF(s);

		/*C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			writeColor(current[s].x,current[s].y,colors[4]);
		C3D_FrameEnd(0);*/

		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection() && m < 4) {
			m++;
			int d = getDirection(s);
			/*snprintf(mystring,sizeof(mystring),"dist: %d",getDist(getDirectionX(d,s),getDirectionY(d,s),sprites[s].x , sprites[s].y ));
			myprintf(mystring);*/
			if (!getColor(getDirectionX(d,s),getDirectionY(d,s)) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
				}
				directions[d] = false;
			}
			directions[d] = false;
		}

	}
	if (closedSet[s] == NULL) {
		apple.x = ((rand() % (400 - 64)) + 30);
		apple.y = ((rand() % (240 - 64)) + 30);
		while (getColor(apple.x , apple.y ) || getColor((apple.x ) + 1, (apple.y ) + 1)) {
			apple.x = ((rand() % (400 - 64)) + 30);
			apple.y = ((rand() % (240 - 64)) + 30);
		}
		return;
	}
	apple.x = closedSet[s]->x;
	apple.y = closedSet[s]->y;
	return;
}
bool noCameFrom(int x, int y, int s) {
	return (!cameFrom[s][x][y].x && !cameFrom[s][x][y].y);
}
bool isCameFrom(int x, int y, int s) {
	return (cameFrom[s][x][y].x || cameFrom[s][x][y].y);
}
void showClosedSet(int s) {
	snprintf(mystring,sizeof(mystring),"current: %d %d (%d) dist: %d",current[s].x,current[s].y,getDist(current[s].x,current[s].y,apple.x,apple.y),getDist(sprites[s].x,sprites[s].y,apple.x,apple.y));
	myprintf(mystring);
	int i = 0;
	while (aptMainLoop()) {
		hidScanInput();
		keepConsole();
		if (hidKeysDown() & KEY_SELECT) break;
		Path *c = closedSet[s];
		while (c != NULL) {
			if (i < 5) {
				snprintf(mystring,sizeof(mystring),"f: %d",fscore[s][c->x][c->y]);
				myprintf(mystring);
				i++;
			}
			float f = (float)fscore[s][c->x][c->y] / 240.0f;
			f *= 100.0f;
			f = 100.0f - f;
			u32 color = ((int)(2.0f * f) << 16) + ((int)(2.0f * (1.0f - f)) << 8);
			writeColor(c->x,c->y,color);
			writeColor(sanitizeX(c->x + 1),c->y,color);
			writeColor(sanitizeX(c->x + 1),sanitizeY(c->y + 1),color);
			writeColor(c->x,sanitizeY(c->y+1),color);
			c = c->next;
		}
	}
}
void showCameFrom(int s) {
	/*snprintf(mystring,sizeof(mystring),"%d: openSetN: (%d = %d) closedSetN: (%d = %d) ",s, openSetN[s],countOpenSet(s), closedSetN[s],countClosedSet(s));
	myprintf(mystring);*/
	float px = 0;
	float py = 0;
	float oldpx = 0;
	float oldpy = 0;
	int dpx = (int)px;
	int dpy = (int)py;
	while (aptMainLoop()) {
		hidScanInput();
		hidTouchRead(&touch);

		if (hidKeysDown() & KEY_SELECT) break;
		px = (float)touch.px / 312.0f;
		py = (float)touch.py / 235.0f;
		px *= 400.0f;
		py *= 240.0f;
		dpx = (int)px;
		dpy = (int)py;
		keepConsole();
		if (totalPathN[s] < 500) for (int m = totalPathN[s]; m >= 0; m--) {
			writeColor(totalPath[s][m].x,totalPath[s][m].y,colors[8]);
		}
		if (px && py) {
			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
				C3D_FrameDrawOn(target);
				C3D_TexBind(0, &spritesheet_tex);
				C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
				if (noCameFrom(dpx,dpy,s)) {
					if (isCameFrom(sanitizeX(dpx + 1),dpy,s)) dpx += 1;
					else if (isCameFrom(dpx,sanitizeY(dpy + 1),s)) dpy += 1;
					else if (isCameFrom(sanitizeX(dpx + 1),sanitizeY(dpy + 1),s)) { dpx += 1; dpy += 1; }
				}
				writeColor(dpx, dpy, colors[8]);
				writeColor(current[s].x,current[s].y,colors[8]);
				int tx = current[s].x;
				int otx;
				int ty = current[s].y;
				while (tx != 0 || ty != 0) {
					writeColor(tx,ty,colors[8]);
					otx = tx;
					tx = cameFrom[s][tx][ty].x;
					ty = cameFrom[s][otx][ty].y;
				}
				int i = 0; int tempx;
				while (isCameFrom(dpx,dpy,s) && i < 100) {
					i++;
					writeColor(cameFrom[s][dpx][dpy].x,cameFrom[s][dpx][dpy].y,colors[8]);
					writeColor(sanitizeX(cameFrom[s][dpx][dpy].x + 1),cameFrom[s][dpx][dpy].y,colors[8]);
					writeColor(sanitizeX(cameFrom[s][dpx][dpy].x + 1),sanitizeY(cameFrom[s][dpx][dpy].y + 1),colors[8]);
					writeColor(cameFrom[s][dpx][dpy].x,sanitizeY(cameFrom[s][dpx][dpy].y + 1),colors[8]);
					tempx = dpx;
					dpx = cameFrom[s][dpx][dpy].x;
					dpy = cameFrom[s][tempx][dpy].y;
				}
			C3D_FrameEnd(0);
			oldpx = px;
			oldpy = py;
		} else if (oldpx && oldpy) { //player has dropped the apple
			oldpx = 0;
			oldpy = 0;
		}
	}
}
void getFarthestCurrent(int s) {
	int ac = getBot(s);
	Path *c = closedSet[s];
	int pdis = 0;
	int pdanger = INT_MAX;
	int myx = sprites[ac].x;
	int myy = sprites[ac].y;
	while (c != NULL) {
		if (getDist(myx,myy,c->x,c->y) > pdis || dangerousNeighbors(c->x,c->y,s) < pdanger) {
			bool flag = true;
			if (getColor(c->x,c->y)) { c = c->next; continue; }
			for (int i = 4; i < 8; i++) {
				if (getColor(getDirectionXTo(i,c->x,s),getDirectionYTo(i,c->y,s))) flag = false;
			}
			if (!flag) { c = c->next; continue; }
			pdanger = dangerousNeighbors(c->x,c->y,s);
			current[s].x = c->x;
			current[s].y = c->y;
			pdis = getDist(myx,myy,c->x,c->y);
		}
		c = c->next;
	}
}
void plotMovement(int s) {
	int ac = getBot(s);
	if (totalPathN[s] > 10) return;
	if (s >= numPlayers()) {
		plotting[s] = false;
		totalPathN[s] = 0;
		return;
	}
	int tempx;
	int tempy;
	totalPathN[s] = 0;
	while ((cameFrom[s][current[s].x][current[s].y].x || cameFrom[s][current[s].x][current[s].y].y) && totalPathN[s] < 1000) {
		tempx = cameFrom[s][current[s].x][current[s].y].x;
		tempy = cameFrom[s][current[s].x][current[s].y].y;
		totalPath[s][totalPathN[s]].x = current[s].x;
		totalPath[s][totalPathN[s]].y = current[s].y;
		totalPathN[s]++;
		if (tempx == sprites[ac].x  && tempy == sprites[ac].y ) break;
		current[s].x = tempx;
		current[s].y = tempy;
	}
}
/*void setCloseCurrent() {
	int i = 0;
	while (isAPlaceIMoved(closedSet[i].x,closedSet[i].y)) {
		i++;
	}
	current[s].x = closedSet[i].x;
	current[s].y = closedSet[i].y;
}*/
bool pathfindToApple(int s) {
	if (s >= numPlayers()) return false;
	int ac = getBot(s);
	u64 startPathFind = svcGetSystemTick();
	clearClosedSet(s);
	clearOpenSet(s);
	memset(gscore[s],1,sizeof(gscore[0][0][0]) * 401 * 241);
	memset(fscore[s],1,sizeof(fscore[0][0][0]) * 401 * 241);
	int x = apple.x;
	int y = apple.y;
	addOpenSet(x,y,s);
	gscore[s][x][y] = 0;
	fscore[s][x][y] = getDist(x,y,sprites[ac].x ,sprites[ac].y );
	if (getDist(x,y,sprites[ac].x ,sprites[ac].y ) * epsilon < 4) return true;
	int i = 0;
	while (openSetNotEmpty(s) && i < 240 * 400) {
		if ((svcGetSystemTick() - startPathFind) / TICKS_PER_MS / (sprites[ac].speed / 3)) return false;
		if (closedSetN[s] >= 240 * 400) return false;
		if (openSetN[s] >= 240 * 400) return false;
		/*hidScanInput();
		u32 kDown = hidKeysDown();
		u32 kUp = hidKeysUp();
		if (kDown & KEY_START) return false;
		if (kDown & KEY_A && !options[3]) {
			sprites[myNum].speed = 15;
		}
		if (kUp & KEY_A && !options[3]) {
			sprites[myNum].speed = 45;
		}
		if (kDown & KEY_B && !options[4]) {
			sprites[myNum].speed = 90;
		}
		if (kUp & KEY_B && !options[4]) {
			sprites[myNum].speed = 45;
		}*/
		//keepConsole();
		i++;
		setCurrentF(s);

		/*C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			writeColor(current[s].x,current[s].y,colors[6]);
		C3D_FrameEnd(0);*/
		if (abs(sprites[ac].x - current[s].x) <= 2 && abs(sprites[ac].y - current[s].y) <= 2) {
			return true;
		}

		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection() && m < 4) {
			m++;
			int d = getDirection(s);
			/*snprintf(mystring,sizeof(mystring),"dist: %d",getDist(getDirectionX(d,s),getDirectionY(d,s),sprites[s].x , sprites[s].y ));
			myprintf(mystring);*/
			if (!getColor(getDirectionX(d,s),getDirectionY(d,s)) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) { addNode(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s); }
				}
				directions[d] = false;
			}
			directions[d] = false;
		}

	}
	return false;
}
void showPathToApple(int s) {
	giveUpTimer[s] = (u64)0;
	plotting[s] = false;
	int ac = getBot(s);
	if (getDist(sprites[ac].x,sprites[ac].y,apple.x,apple.y) > 400) { //its far away, we should speed up maybe?
		if (rand() % 100 < bots[s].can_go_fast * 2 && !options[3]) sprites[ac].speed = BIKE_FAST; //twice as likely to go fast because it's far away
		else sprites[ac].speed = BIKE_NORMAL;
	} else { //its close by. mostly depends on how aggressive I am.
		if (rand() % 100 < bots[s].can_go_fast && !options[3]) sprites[ac].speed = BIKE_FAST; //mostly depends on how aggressive I am
		else sprites[ac].speed = BIKE_NORMAL;
	}
	bots[s].fudge_factor = 0;
	bots[s].fudge_x = 0;
	bots[s].fudge_y = 0;
	if (ac >= numPlayers()) {
		plotting[s] = false;
		totalPathN[s] = 0;
		return;
	}
	int tempx;
	int tempy;
	plotting[s] = false;
	totalPathN[s] = 0;
	u64 timeUp = svcGetSystemTick();
	while ((cameFrom[s][current[s].x][current[s].y].x || cameFrom[s][current[s].x][current[s].y].y) && totalPathN[s] < 240 * 400 && svcGetSystemTick() - timeUp < TICKS_PER_MS) {
		tempx = cameFrom[s][current[s].x][current[s].y].x;
		tempy = cameFrom[s][current[s].x][current[s].y].y;
		totalPath[s][totalPathN[s]].x = current[s].x;
		totalPath[s][totalPathN[s]].y = current[s].y;
		/*hidScanInput();
		u32 kDown = hidKeysDown();
		if (kDown & KEY_START) break;
		if (kDown & KEY_L) { autoPilot = false; break; }*/
		totalPathN[s]++;
		if (tempx == sprites[ac].x  && tempy == sprites[ac].y ) break;
		current[s].x = tempx;
		current[s].y = tempy;
	}
	if (totalPathN[s] >= 240 * 400) {
		/*snprintf(mystring,sizeof(mystring),"wtf.. %d",isGone);
		myprintf(mystring);*/
		totalPathN[s] = 0;
		plotting[s] = false;
	}
	/*snprintf(mystring,sizeof(mystring),"totalPathN: %d",totalPathN);
	myprintf(mystring);*/
	/*while (aptMainLoop()) {
		keepConsole();
		hidScanInput();
		if (hidKeysDown() & KEY_A) break;
		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			int i = totalPathN;
			for (; i >= 0; i--) {
				if (i == totalPathN) writeColor(totalPath[i].x + 1,totalPath[i].y,colors[8]);
				else writeColor(totalPath[i].x + 1,totalPath[i].y,colors[0]);
			}
		C3D_FrameEnd(0);
	}*/
}
bool everyoneElseIsDead(int n) {
	for (int i = 0; i < numPlayers(); i++) {
		if (i != n && !sprites[i].dead) return false;
	}
	return true;
}
int getAlive() {
	//int k = 0;
	/*for (int i = 0; i < actual_bikes; i++) {
		if (sprites[i].dead || getMoveableRange(i) < 40) k++;
	}
	if (k >= actual_bikes - 1) return -1;*/
	if (everyoneElseIsDead(myNum)) return myNum;
	int r = (rand() % numPlayers());
	//while (sprites[r].dead) r = rand() % actual_bikes;
	if (r >= numPlayers()) return myNum;
	return r;
}
void fixCameFroms(int i) {
	int bc = toBot(i);
	if (!plotting[bc]) return;
	if ((i > 0 && i != myNum && i < currentBots) || (autoPilot && i == myNum)) {
		int dx = sprites[i].dx;
		int dy = sprites[i].dy;
		int x, y, h;
		int odx = 0;
		int ody = 0;
		x = sprites[i].x;
		y = sprites[i].y;
		h = currentPath[i] - 1;
		//char offsets[20];
		int o = 0;
		while ((dx != odx || dy != ody) && h != pathPos[i] && o < 40) {
			o++;
			h--;
			if (h < 0) h = 120 * 200 - 1;
			odx = dx;
			ody = dy;
			dx = x - (path[h][i].x );
			dy = y - (path[h][i].y );
			x = path[h][i].x;
			y = path[h][i].y;
		}
		h--;
		if (h < 0) h = 120 * 200 - 1;
		int nexth = h;
		o = 0;
		while (h != currentPath[i] && o < 40) {
			o++;
			x = path[h][i].x;
			y = path[h][i].y;
			nexth = h + 1;
			if (nexth >= 120 * 200) nexth = 0;
			dx = (path[nexth][i].x ) - x;
			dy = (path[nexth][i].y ) - y;
			//snprintf(mystring,sizeof(mystring),"%d (%d %d):",currentPath[myNum] - h, dx, dy);
			for (int k = 0; k < 8; k++) {
				if (dx == 0 && getDirectionXTo(k,x,bc) == x) continue;
				if (dy == 0 && getDirectionYTo(k,y,bc) == y) continue;
				if (getDist(getDirectionXTo(k,x,i),getDirectionYTo(k,y,i),sanitizeX(x + dx),sanitizeY(y + dy)) <= 4) if (!getColor(getDirectionXTo(k,x,bc),getDirectionYTo(k,y,bc))) {
					//snprintf(offsets,sizeof(offsets)," %d",i);
					//strcat(mystring,offsets);
					//writeColor(getDirectionXTo(i,x,myNum) + 1,getDirectionYTo(i,y,myNum) + 1,colors[8]);
					cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].x = sanitizeX(getDirectionXTo(k,x,bc) + dx);
					cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].y = sanitizeY(getDirectionYTo(k,y,bc) + dy);		
				}
			}
			//myprintf(mystring);
			h++;
			if (h >= 120 * 200) h = 0;
		}
		x = sprites[i].x;
		y = sprites[i].y;
		odx = dx;
		ody = dy;
		dx = sprites[i].dx;
		dy = sprites[i].dy;
		/*snprintf(mystring,sizeof(mystring),"dx: %d dy: %d odx: %d ody: %d",dx,dy,odx,ody);
		myprintf(mystring);*/
		if (odx != dx || ody != dy) { //we are taking a turn, so we need to fix the corner's cameFrom.
			if (dx == 0) {
				cameFrom[bc][sanitizeX(x + odx)][sanitizeY(y - dy)].x = sanitizeX(x + odx);
				cameFrom[bc][sanitizeX(x + odx)][sanitizeY(y - dy)].y = y;
			} else if (dy == 0) {
				cameFrom[bc][sanitizeX(x - dx)][sanitizeY(y + ody)].x = x;
				cameFrom[bc][sanitizeX(x - dx)][sanitizeY(y + ody)].y = sanitizeY(y + ody);
			}
		}
		//snprintf(mystring,sizeof(mystring),"%d (%d %d):",currentPath[myNum] - h, dx, dy);
		for (int k = 0; k < 8; k++) {
			if (dx == 0 && getDirectionXTo(k,x,i) == x) continue;
			if (dy == 0 && getDirectionYTo(k,y,i) == y) continue;
			if (getDist(getDirectionXTo(k,x,bc),getDirectionYTo(k,y,bc),sanitizeX(x + dx),sanitizeY(y + dy)) <= 4) if (!getColor(getDirectionXTo(k,x,bc),getDirectionYTo(k,y,bc))) {
				//snprintf(offsets,sizeof(offsets)," %d",i);
				//strcat(mystring,offsets);
				//writeColor(getDirectionXTo(i,x,myNum) + 1,getDirectionYTo(i,y,myNum) + 1,colors[8]);
				cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].x = sanitizeX(getDirectionXTo(k,x,bc) + dx);
				cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].y = sanitizeY(getDirectionYTo(k,y,bc) + dy);		
			}
		}
		//myprintf(mystring);
		//addPlacesIMoved(x,y);
		cameFrom[bc][x][y].x = 0;
		cameFrom[bc][x][y].y = 0;
	}
	if ((i > 0 && i < currentBots) || (autoPilot && i == myNum)) {
		int x = sanitizeX(sprites[i].x + sprites[i].dx );
		int y = sanitizeY(sprites[i].y + sprites[i].dy );
		//addPlacesIMoved(x,y);
		cameFrom[bc][x][y].x = 0;
		cameFrom[bc][x][y].y = 0;
		for (int k = 4; k < 8; k++) {
			cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].x = x;
			cameFrom[bc][getDirectionXTo(k,x,bc)][getDirectionYTo(k,y,bc)].y = y;
		}
	}
}
void relocateApple() {
	apple.x = ((rand() % (400 - 64)) + 30);
	apple.y = ((rand() % (240 - 64)) + 30);
	while (getColor(apple.x , apple.y ) || getColor((apple.x ) + 1, (apple.y ) + 1)) {
		apple.x = ((rand() % (400 - 64)) + 30);
		apple.y = ((rand() % (240 - 64)) + 30);
	}
	//int n = getAlive();
	/*if (n >= 0) if (!pathfindToApple(n)) {
		getMoveableRangeApple(n);
	}*/
	for (int b = 0; b < numBots; b++) {
		if (sprites[getBot(b)].dead || b > numOpponents + 1) continue;
		int ax = apple.x;
		int ay = apple.y;
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		ax = sanitizeX(ax + 1);
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		ay = sanitizeY(ay + 1);
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		if (cameFrom[b][apple.x ][ay].x && cameFrom[b][apple.x ][ay].y) {
			current[b].x = apple.x;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		totalPathN[b] = 0;
		plotting[b] = false;
	}
}
void overwriteSprite( int x, int y, int width, int height, int image ) {
//---------------------------------------------------------------------------------
	if (texEnvMode != MODE_SPRITES) {
		C3D_TexEnv* env = C3D_GetTexEnv(0);
		C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, GPU_PRIMARY_COLOR, GPU_PRIMARY_COLOR);
	    C3D_TexEnvOp(env, C3D_Both, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR);
	    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
	    texEnvMode = MODE_SPRITES;
	}
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);
	BufInfo_Add(bufInfo, textVtxArray, sizeof(textVertex_s), 2, 0x10);
	if (strstr(sprites[image].username,"!.u") != NULL) { setTextColor(HSL2RGB(rainbow,0.5,0.5)); texEnvMode = MODE_TEXT; }
	int arrayIndex = textVtxArrayPos;
	if ((arrayIndex+4) >= TEXT_VTX_ARRAY_COUNT)
		return; 
	float left = images[image].left;
	float right = images[image].right;
	float top = images[image].top;
	float bottom = images[image].bottom;

	/*if (image < 8) {
		for (int j = 0; j < numBots; j++) {
			for (int i = totalPathN[j] - 1; i >= 0; i--) {
				if (abs(totalPath[j][i].x - (sprites[getBot(j)].x )) < 2 && abs(totalPath[j][i].y - (sprites[getBot(j)].y )) < 2) { myprintf("skipped."); continue; }
				if (abs(x - totalPath[j][i].x) < 2 && abs(y - totalPath[j][i].y) < 2) {
					setTextColor(0xff0000ff);
					snprintf(mystring,sizeof(mystring),"!.ryep %llu!.w",(u64)svcGetSystemTick());
					myprintf(mystring);

					current[j].x = 0;
					current[j].y = 0;
					plotting[j] = false;
					totalPathN[j] = 0;
					break;
				}
			}
		}
	}*/
	// Draw a textured quad directly
	addTextVertex(x,  y+height, left,  bottom);
	addTextVertex(x+width, y+height, right, bottom);
	addTextVertex(x,  y,    left,  top);
	addTextVertex(x+width, y,    right, top);

	// Draw the glyph
	C3D_DrawArrays(GPU_TRIANGLE_STRIP, arrayIndex, 4);

}
//---------------------------------------------------------------------------------
void drawSprite( int x, int y, int width, int height, int image ) {
//---------------------------------------------------------------------------------
	u32 color = getColor(x,y);
	if (image < 10 && width < 100 && height < 100) if (image != 9 && color != colors[8] && color) return;
	overwriteSprite(x, y, width, height, image);
	/*C3D_ImmDrawBegin(GPU_TRIANGLES);
		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( left, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);


	C3D_ImmDrawEnd();*/

}
static void changeApple() {
	overwriteSprite(apple.x , apple.y , 2, 2, 9);
	relocateApple();
	overwriteSprite(apple.x , apple.y , 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 66;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
}
static void moveApple() {
	overwriteSprite(apple.x , apple.y , 2, 2, 9);
	relocateApple();
	overwriteSprite(apple.x , apple.y , 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 77;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
	for (int b = 0; b < numBots; b++) {
		usedSpecial[b] = false;
	}
}
static void updateApple(int x, int y) {
	overwriteSprite(apple.x , apple.y , 2, 2, 9);
	apple.x = x;
	apple.y = y;
	overwriteSprite(apple.x , apple.y , 2, 2, 8);
	for (int b = 0; b < numBots; b++) {
		int ax = apple.x;
		int ay = apple.y;
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		ax = sanitizeX(ax + 1);
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		ay = sanitizeY(ay + 1);
		if (cameFrom[b][ax][ay].x && cameFrom[b][ax][ay].y) {
			current[b].x = ax;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		if (cameFrom[b][apple.x ][ay].x && cameFrom[b][apple.x ][ay].y) {
			current[b].x = apple.x;
			current[b].y = ay;
			showPathToApple(b);
			continue;
		}
		totalPathN[b] = 0;
		plotting[b] = false;
	}
}
void useSpecialIfICan(int s) {
	if (!usedSpecial[s] && !options[5] && !options[7]) {
		usedSpecial[s] = true;
		movingApple = true;
	}
}
void useSpecialOrGiveUp(int s) {
	/*snprintf(mystring,sizeof(mystring),"time left: %" PRIu64 "(%d)",(svcGetSystemTick() - giveUpTimer[s]),(giveUpTimer[s] == (u64)0));
	myprintf(mystring);*/
	if (!usedSpecial[s]) {
		useSpecialIfICan(s);
	} else {
		/*snprintf(mystring,sizeof(mystring),"giveuptimer: %llu < %llu",svcGetSystemTick() - giveUpTimer[s],(u64)(TICKS_PER_SEC * 30));
		myprintf(mystring);*/
		if (giveUpTimer[s] == (u64)0) {
			timeTilDeath[s] = (u64)BIKE_SLOW * TICKS_PER_MS * (closedSetN[s] / (100 / bots[s].patience));
			giveUpTimer[s] = svcGetSystemTick();
		} else if ((svcGetSystemTick() - giveUpTimer[s]) > timeTilDeath[s]) {
			sprites[s].dead = true;
		}
	}
}

void showPlotMovement(int s, bool refresh) {
	if (refresh && patchConsole) keepConsole();
	if (sprites[getBot(s)].dead) return;
	if (openSetN[s] == 0) {
		useSpecialOrGiveUp(s);
	} else if (closedSetN[s] > 12000 * (float)((float)bots[s].patience / 100.0f)) {
		useSpecialIfICan(s);
	}
	plotting[s] = true;
	if (totalPathN[s] > 2) return;
	int ac = getBot(s);
	/*myprintf("calculating...");*/
	getFarthestCurrent(s);
	int tempx;
	int tempy;
	totalPathN[s] = 0;
	u64 timeUp = svcGetSystemTick();
	while ((cameFrom[s][current[s].x][current[s].y].x || cameFrom[s][current[s].x][current[s].y].y) && totalPathN[s] < 240 * 400 && svcGetSystemTick() - timeUp < TICKS_PER_MS) {
		tempx = cameFrom[s][current[s].x][current[s].y].x;
		tempy = cameFrom[s][current[s].x][current[s].y].y;
		if (getNextColor(tempx,tempy) && tempx != sprites[ac].x  && tempy != sprites[ac].y )  {
			plotting[s] = false;
			totalPathN[s] = 0;
			return;
		}
		totalPath[s][totalPathN[s]].x = current[s].x;
		totalPath[s][totalPathN[s]].y = current[s].y;
		/*hidScanInput();
		u32 kDown = hidKeysDown();
		if (kDown & KEY_START) break;
		if (kDown & KEY_L) { autoPilot = false; break; }
		if (debugging) {
			keepConsole();

			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
				C3D_FrameDrawOn(target);
				C3D_TexBind(0, &spritesheet_tex);
				C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
				writeColor(current[s].x + 1,current[s].y + 1,colors[8]);
			C3D_FrameEnd(0);
		}*/
		totalPathN[s]++;
		if (tempx == sprites[ac].x  && tempy == sprites[ac].y) break;
		current[s].x = tempx;
		current[s].y = tempy;
	}
	if (totalPathN[s] >= 120 * 200 - 1) {
		//bool isGone = (current[s].x == 0 && current[s].y == 0);
		/*snprintf(mystring,sizeof(mystring),"wtf.. %d",isGone);
		myprintf(mystring);*/
	}
	/*snprintf(mystring,sizeof(mystring),"totalpathn: %d",totalPathN);
	myprintf(mystring);*/
}

u64 firstTimeDiff() {
	u64 smallest = svcGetSystemTick() + (u64)BIKE_SLOW * TICKS_PER_MS;
	for (int i = 0; i < numPlayers(); i++) {
		if (sprites[i].dead) continue;
		if (frameTicks[i] + ((u64)sprites[i].speed * TICKS_PER_MS) < smallest) {
			smallest = frameTicks[i] + ((u64)sprites[i].speed * TICKS_PER_MS);
		}
	}
	u64 r = smallest - svcGetSystemTick();
	if (r > TICKS_PER_SEC) return (u64)0;
	return r;
}
u64 timeDiff(int num) {
	u64 speed = (u64)sprites[num].speed;
	return (svcGetSystemTick() - frameTicks[num]) / TICKS_PER_MS / speed;
}
int livingBots() {
	int r = 0;
	for (int b = 1; b < currentBots; b++) {
		if (!sprites[b].dead) r++;
	}
	if (autoPilot && !sprites[myNum].dead) r++;
	if (r <= 0) return 1;
	return r;
}

//Return a multiplier for difficulty level for this bot going to this node.
//This multiplier will be multiplied by the cost to reach this node in the A* search algorithm.
//This is to create "hills and valleys" of difficulty levels, making valleys be "easy" to get to and walls be "hills" that should
//mostly be avoided.

int dangerousNeighbors(int x, int y, int s) {
	int fudge = 4; 
	if (bots[s].precision >= 100) fudge = 1;
	else if (bots[s].precision >= 90) fudge = 2;
	else if (bots[s].precision >= 80) fudge = 3;
	int danger = 0;
	for (int i = 0; i < 4; i++) {
		for (int f = 0; f < fudge; f++) {
			u32 c = getColor(getDirectionXFor(i,x,s,f),getDirectionYFor(i,y,s,f));
			if (c && c != colors[8]) { danger += fudge - f; break; }
		}
	}
	return danger;
}
void continuePlotting(int s) {
	int ac = getBot(s);
	if (sprites[ac].dead) return;
	u64 startThinking = svcGetSystemTick();
	plotting[s] = true;
	if (!options[4]) sprites[ac].speed = BIKE_SLOW;
	int x = sprites[ac].x;
	int y = sprites[ac].y;
	/*cameFrom[x][y].x = 1;
	cameFrom[x][y].y = 1;*/
	int i = 0;
	u64 thinkingTime = firstTimeDiff();
	thinkingTime /= livingBots();
	thinkingTime /= 2;
	while (openSetNotEmpty(s) && i < 400) {
		i++;
		if (svcGetSystemTick() - startThinking > thinkingTime) {
			if (!options[4]) sprites[ac].speed = BIKE_SLOW;
			showPlotMovement(s,true);
			return;
		}
		if (closedSetN[s] >= 240 * 400) {
			if (!options[4]) sprites[ac].speed = BIKE_SLOW; 
			showPlotMovement(s,true);
			return;
		}
		if (openSetN[s] >= 240 * 400) {
			if (!options[4]) sprites[ac].speed = BIKE_SLOW;
			showPlotMovement(s,true);
			return;
		}
		setCurrentF(s);
		if (abs((apple.x ) - current[s].x) < 3 && abs((apple.y ) - current[s].y) < 3) {
			sprites[ac].speed = BIKE_NORMAL;
			showPathToApple(s);
			return;
		}
		/*hidScanInput();
		u32 kDown = hidKeysDown();
		if (kDown & KEY_START) { 
			sprites[s].speed = 90;
			showPlotMovement(s,true);
			return;
		}
		if (kDown & KEY_L) {
			autoPilot = false;
			return;
		}*/
		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection() && m < 4) {
			m++;
			int d = getDirectionToApple(s);
			/*snprintf(mystring,sizeof(mystring),"d: %d",d);
			myprintf(mystring);
			keepConsole();*/
			if (((!getColor(getDirectionX(d,s),getDirectionY(d,s)) && !getColor(sanitizeX(getDirectionX(d,s) + 1),sanitizeY(getDirectionY(d,s) + 1)) && !(x == getDirectionX(d,s) && y == getDirectionY(d,s)))) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8] || getColor(sanitizeX(getDirectionX(d,s) + 1),sanitizeY(getDirectionY(d,s) + 1)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					/*bool cflag = false;
					for (int a = 0; a < numPlayers(); a++) {
						if (a == s) continue;
						if (abs(getDirectionX(d,s) - ((sprites[a].x + sprites[a].dx) )) < 2 && abs(getDirectionY(d,s) - ((sprites[a].y + sprites[a].dy) )) < 2) {
							//addClosedSet(getDirectionX(d,s),getDirectionY(d,s),s);
							myprintf("...");
							cflag = true;
							break;
						}
					}
					if (cflag) { directions[d] = false; continue; }*/
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							continueAddNodeToApple(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) continueAddNodeToApple(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
				}
				directions[d] = false;
			}
			directions[d] = false;
		}
	}
	if (!options[4]) sprites[ac].speed = BIKE_SLOW;
	showPlotMovement(s,true);
	return;
}
void plotCourse(int s) {
	//snprintf(mystring,sizeof(mystring),"!.rplotCourse(%d)",s);
	//myprintf(mystring);
	bots[s].fudge_x = 0;
	bots[s].fudge_y = 0;
	bots[s].fudge_factor = 0;
	int ac = getBot(s);
	if (sprites[ac].dead) return;
	plotting[s] = false;
	clearClosedSet(s);
	clearOpenSet(s);
	memset(cameFrom[s],0,sizeof(cameFrom[0][0][0]) * 401 * 241);
	memset(totalPath[s],0,sizeof(totalPath[0][0]) * 401 * 241);
	memset(gscore[s],1,sizeof(gscore[0][0][0]) * 401 * 241);
	memset(fscore[s],1,sizeof(fscore[0][0][0]) * 401 * 241);
	int x = sprites[ac].x;
	int y = sprites[ac].y;
	addOpenSet(x,y,s);
	gscore[s][x][y] = 0;
	fscore[s][x][y] = getDist(x,y,apple.x ,apple.y );
	if (s >= numPlayers()) { showPlotMovement(s,true); return; }
	//if (getDist(x,y,apple.x ,apple.y ) * epsilon < 4) { plotMovement(s); return; }
	//myprintf("!.yplotCourse()");
	int i = 0;
	u64 startThinking = svcGetSystemTick();
	u64 thinkingTime = firstTimeDiff();
	if (thinkingTime == 0) thinkingTime = 5 * TICKS_PER_MS;
	thinkingTime /= livingBots();
	current[s].x = x;
	current[s].y = y;
	while (openSetNotEmpty(s) && i < 240 * 400) {
		i++;
		if (svcGetSystemTick() - startThinking > thinkingTime) {
			if (!options[4]) sprites[ac].speed = BIKE_SLOW;
			showPlotMovement(s,true);
			return;
		}
		if (closedSetN[s] >= 200 * 240) { 
			if (!options[4]) sprites[ac].speed = BIKE_SLOW;
			showPlotMovement(s,true);
			return;
		}
		if (openSetN[s] >= 200 * 240) {
			if (!options[4]) sprites[ac].speed = BIKE_SLOW;
			showPlotMovement(s,true);
			return;
		}
		setCurrentF(s);
		if (abs((apple.x ) - current[s].x) < 3 && abs((apple.y ) - current[s].y) < 3) {
			sprites[ac].speed = BIKE_NORMAL;
			showPathToApple(s);
			return;
		}
		/*hidScanInput();
		if (hidKeysDown() & KEY_START) { 
			sprites[s].speed = 90;
			showPlotMovement(s,true);
			return;
		}*/
		remOpenSet(current[s].x,current[s].y,s);
		addClosedSet(current[s].x,current[s].y,s);
		//up
		int myGScore = gscore[s][current[s].x][current[s].y] + 2;
		memset(directions,1,sizeof(directions[0]) * 4);
		int m = 0;
		while (haveDirection() && m < 4) {
			m++;
			int d = getDirectionToApple(s);
			/*snprintf(mystring,sizeof(mystring),"d: %d",d);
			myprintf(mystring);
			keepConsole();*/
			if (((!getColor(getDirectionX(d,s),getDirectionY(d,s)) && !getColor(sanitizeX(getDirectionX(d,s) + 1),sanitizeY(getDirectionY(d,s) + 1)) && !(x == getDirectionX(d,s) && y == getDirectionY(d,s)))) || getColor(getDirectionX(d,s),getDirectionY(d,s)) == colors[8] || getColor(sanitizeX(getDirectionX(d,s) + 1),sanitizeY(getDirectionY(d,s) + 1)) == colors[8]) 
			{
				if (!inClosedSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
					/*bool cflag = false;
					for (int a = 0; a < numPlayers(); a++) {
						if (a == s) continue;
						if (abs(getDirectionX(d,s) - ((sprites[a].x + sprites[a].dx) )) < 2 && abs(getDirectionY(d,s) - ((sprites[a].y + sprites[a].dy) )) < 2) {
							//addClosedSet(getDirectionX(d,s),getDirectionY(d,s),s);
							//myprintf("...");
							cflag = true;
							break;
						}
					}
					if (cflag) { directions[d] = false; continue; }*/
					if (!inOpenSet(getDirectionX(d,s),getDirectionY(d,s),s)) {
							addOpenSet(getDirectionX(d,s),getDirectionY(d,s),s);
							addNodeToApple(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
					} else if (gscore[s][getDirectionX(d,s)][getDirectionY(d,s)] == 1 || myGScore < gscore[s][getDirectionX(d,s)][getDirectionY(d,s)]) addNodeToApple(current[s].x,current[s].y,getDirectionX(d,s),getDirectionY(d,s), myGScore, s);
				}
				directions[d] = false;
			}
			directions[d] = false;
		}
		if (openSetN[s] == 0) break;
	}
	if (!options[4]) sprites[ac].speed = BIKE_SLOW;
	showPlotMovement(s,true);
	return;
}
bool checkPath(int s) {
	int totalDanger = 0;
	int max = totalPathN[s] - 5;
	if (max < 0) max = 0;
	int ac = getBot(s);
	for (int i = totalPathN[s] - 1; i > max; i--) {
		if (!totalPath[s][i].x && !totalPath[s][i].y) continue;
		if (abs(totalPath[s][i].x - sprites[ac].x + bots[s].fudge_x) < 2 && abs(totalPath[s][i].y - sprites[ac].y + bots[s].fudge_y) < 2) { continue; }
		u32 check = getColor(totalPath[s][i].x + bots[s].fudge_x,totalPath[s][i].y + bots[s].fudge_y);
		if (check != colors[8] && check != 0) {
			//setTextColor(0xff0000ff);
			//snprintf(mystring,sizeof(mystring),"!.ryep (%d) (%d %d)%" PRIu64 "!.w",i,sprites[getBot(s)].dx ,sprites[getBot(s)].dy ,(u64)svcGetSystemTick());
			//myprintf(mystring);

			/*current[s].x = 0;
			current[s].y = 0;
			plotting[s] = false;
			totalPathN[s] = 0;*/
			plotCourse(s);
			if (!options[4]) sprites[getBot(s)].speed = BIKE_SLOW;
			else sprites[getBot(s)].speed = BIKE_NORMAL;
			bots[s].last_speed_change = svcGetSystemTick();
			return true;
		}
		totalDanger += dangerousNeighbors(totalPath[s][i].x,totalPath[s][i].y,s);
	}
	if (totalDanger < 2 && sprites[ac].speed == BIKE_NORMAL) {
		int a = getAlive();
		if ((getDist(sprites[a].x,sprites[a].y,apple.x,apple.y) < getDist(sprites[ac].x,sprites[ac].y,apple.x,apple.y) || svcGetSystemTick() - bots[s].last_speed_change > TICKS_PER_MS * 15) && rand() % 100 < bots[s].can_go_fast && (getHighestScore() != ac || bots[s].can_go_fast >= 100)) {
			if (!options[3]) sprites[getBot(s)].speed = BIKE_FAST;
			bots[s].last_speed_change = svcGetSystemTick();
		} else if (getDist(sprites[ac].x,sprites[ac].y,apple.x,apple.y) > 400) { //its far away, we should speed up maybe?
				if (rand() % 100 < bots[s].can_go_fast * 2 && !options[3]) sprites[ac].speed = BIKE_FAST; //twice as likely to go fast because it's far away
				else sprites[ac].speed = BIKE_NORMAL;
		} 
	} else if (totalDanger > 12 && sprites[ac].speed == BIKE_FAST) {
		sprites[ac].speed = BIKE_NORMAL;
	}
	else if (sprites[ac].speed == BIKE_SLOW && svcGetSystemTick() - bots[s].last_speed_change > TICKS_PER_SEC) sprites[ac].speed = BIKE_NORMAL;
	return false;
}
static void setApple(int player, int x, int y) {
	if (abs(player) > num_bikes) return;
	if (autoPilot) {
		totalPathN[0] = 0;
		plotCourse(0);
	}
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx , oldy , 2 , 2, 9);
	drawSprite(apple.x , apple.y , 2, 2, 8);
	//score[player]++;
	if (options[8]) growth[player] += sprites[player].length;
	else growth[player] += growthRate;

	if (sprites[player].length >= 120 * 200 - 1) sprites[player].length = 120 * 200 - 1;
	//sprites[player].length += growthRate;
	for (int b = 0; b < numBots; b++) {
		usedSpecial[b] = false;
	}
}
void eraseLine(int n) {
	if (erased[n]) return;
	erased[n] = true;
	int i = pathPos[n];
	int k = 0;
	while (i != currentPath[n]) {
		hidScanInput();
		if (hidKeysDown() & KEY_START) return;
		overwriteSprite(path[i][n].x , path[i][n].y , 2, 2, 9);
		k++;
		if (k > 40) {
			k = 0;
			C3D_FrameEnd(0);
			gfxFlushBuffers();
			gfxSwapBuffers();
			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
		}
		i++;
		if (i >= 120 * 200) i = 0;
	}
	overwriteSprite(path[i][n].x , path[i][n].y , 2, 2, 9);
}
static int lagMult() {
	if (num_bikes <= 4) return 1;
	int r = (num_bikes - 4) / 2;
	return r > 0 ? r : 1;
}
static void UDSResend(bool replied[], Message msg) {
	if (!uds_enabled || num_bikes <= 1) return;
	msg.sender = myNum;
	sentMsg = msg;
	ret=0;
	if (msg.sprite.speed == 77) msg.timestamp = lastScore;
	else if (msg.sprite.speed == 66) msg.timestamp = lastChange;
	else if (msg.sprite.speed == 2020) msg.timestamp = lastDeadmsg;
	else if (msg.sprite.speed == 5050) msg.timestamp = lastScreenScore;
	else msg.timestamp = lastSprite;
	if(conntype!=UDSCONTYPE_Spectator)
	{
		/*if (debugging) {
			char replies[10];
			clearString(); snprintf(mystring,sizeof(mystring),"replies: ");
			for (int i = 0; i < num_bikes; i++) {
				if (i == myNum) snprintf(replies,sizeof(replies),"-");
				else snprintf(replies,sizeof(replies),"%d",replied[i]);
				strcat(mystring,replies);
			}
			myprintf(mystring);
		}*/
		for (int i = 0; i < num_bikes; i++) {
			if (!replied[i] && i != myNum && sprites[i].node) {
				//if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"resending to... %d: %d",i,sprites[i].node); myprintf(mystring); snprintf(mystring,sizeof(mystring),"sending img: %d speed: %d node: %d",msg.sprite.image,msg.sprite.speed,msg.sprite.node); myprintf(mystring); }
				ret = udsSendTo(sprites[i].node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
				if (UDS_CHECK_SENDTO_FATALERROR(ret))
				{
					if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"Error: UDSResend() returned 0x%08x.",(unsigned int)ret); myprintf(mystring); }
				}
			}
		}
	}
}

static bool allReplied(bool replied[]) {
	for (int i = 0; i < num_bikes; i++) {
		if (!replied[i] && i != myNum) return false;
	}
	return true;
}
static int UDSDirect(int node, Message msg) {
	if (!uds_enabled || num_bikes <= 1) return 0;
	msg.sender = myNum;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		//if (debugging) { snprintf(mystring,sizeof(mystring),"direct to %d: img: %d speed: %d",node,msg.sprite.image,msg.sprite.speed); myprintf(mystring); }
		ret = udsSendTo(node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			snprintf(mystring,sizeof(mystring),"Error: UDSDirect() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			return 1;
		}
	}
	return 0;
}
bool itsATie() {
	int s = score[0];
	int winner = 0;
	for (int i = 0; i < numPlayers(); i++) {
		if (score[i] > s) { s = score[i]; winner = i; }
	}
	for (int i = 0; i < numPlayers(); i++) {
		if (score[i] == s && i != winner) return true;
	}
	return false;
}
int getHighestScore() {
	int highestScore = 0;
	if (itsATie()) return 0;
	int r = 0;
	for (int i = 0; i < numPlayers(); i++) {
		if (score[i] > highestScore) {
			highestScore = score[i];
			r = i;
		}
	}
	return r;
}
int theHighest() {
	int r = 0;
	for (int i = 0; i < numPlayers(); i++) {
		if (r < score[i]) r = score[i];
	}
	return r;
}
bool allReady() {
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) return false;
	}
	return true;
}
int notReadies() {
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) r++;
	}
	return r;
}
int getKiller(u32 color) {
	for (int i = 0; i < NUM_SPRITES; i++) {
		if (color == colors[i]) return i;
	}
	for (int i = 0; i < NUM_SPRITES; i++) {
		if (strstr(sprites[i].username,"!.u") != NULL) return i;
	}
	return 0;
}
bool hasCommonY(int num) {
	if (sprites[num].y % 2 || sprites[num].x % 2) return true;
	if (sprites[num].y < 2 || sprites[num].y > 396) return true;
	if (abs(sprites[num].y - (apple.y )) < 3) return true;
	for (int i = 0; i < num; i++) {
		if (abs(sprites[i].y - sprites[num].y) < 3) return true;
	}
	return false;
}
static void setSprites() {
	for (int b = 0; b < numBots; b++) {
		totalPathN[b] = 0;
		clearOpenSet(b);
		clearClosedSet(b);
		usedSpecial[b] = false;
		giveUpTimer[b] = (u64)0;
	}
	memset(path, 0, sizeof(path[0][0]) * 120 * 200 * 10);
	apple.x = ((rand() % (400 - 64)) + 30);
	apple.y = ((rand() % (240 - 64)) + 30);
	while ((apple.x ) % 2 || (apple.y ) % 2) {
		apple.x = ((rand() % (400 - 64)) + 30);
		apple.y = ((rand() % (240 - 64)) + 30);
	}
	for(int i = 0; i < NUM_SPRITES; i++) {
		//random place and speed
		sprites[i].x = ((rand() % (400 - 64)) + 30);
		sprites[i].y = ((rand() % (240 - 64)) + 30);
		while (hasCommonY(i)) {
			sprites[i].x = ((rand() % (400 - 64)) + 30);
			sprites[i].y =((rand() % (240 - 64)) + 30);
		}
		sprites[i].hole = 0;
		sprites[i].dx = (2);
		sprites[i].dy = 0;
		sprites[i].image = i;
		sprites[i].speed = BIKE_NORMAL;
		sprites[i].dead = false;
		sprites[i].diag = 0;
		sprites[i].forwards = true;


		if (i > currentBots) memset(sprites[i].username,0,sizeof(sprites[i].username));
		else if (i != 0) { 
			if (i < numBots) plotting[i] = false;
			snprintf(sprites[i].username,sizeof(sprites[i].username),"Bot %c",('A' + i - 1));
		}

		if (!options[1]) sprites[i].length = 40;
		else sprites[i].length = 120 * 200 - 1;
		growth[i] = 0;
		currentPath[i] = 120 * 200 - 20;
		pathPos[i] = 120 * 200 - 21;

		path[pathPos[i]][i].x = sprites[i].x;
		path[pathPos[i]][i].y = sprites[i].y;

		if(rand() & 1)
			sprites[i].dx = -sprites[i].dx;
		if(rand() & 1)
			sprites[i].dy = -sprites[i].dy;
		if(options[0]) {
			if (sprites[i].x < 100) sprites[i].dx = abs(sprites[i].dx);
			if (sprites[i].x > 300 && sprites[i].dx) sprites[i].dx = abs(sprites[i].dx) * -1;
		}
	}
	if (options[7]) {
		apple.x = 500;
		apple.y = 500;
	}
}
void print_constatus()
{
	ret=0;
	

	//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
	ret = udsGetConnectionStatus(&constatus);
	if(R_FAILED(ret))
	{
		myprintf("udsGetConnectionStatus() returned 0x%08x.", (unsigned int)ret);
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
}
u64 debugLastSent;
u64 debugUDSSent;
//---------------------------------------------------------------------------------
static void sceneInit(void) {
//---------------------------------------------------------------------------------
	for (int i = 0; i < 30; i++) {
		memset(consoleBuffer[i],0,sizeof(consoleBuffer[i]));
	}
	for (int i = 0; i < 11; i++) {
		options[i] = 0;
		erased[i] = 0;
	}
	bots[0].can_go_fast = 0; //autopilot
	bots[0].precision = 100;
	bots[0].patience = 30;
	bots[0].fudge_x = 0;
	bots[0].fudge_y = 0;
	bots[0].fudge_factor = 0;
	bots[0].difficulty = 0;
	bots[0].last_speed_change = 0;
	for (int i = 1; i < numBots; i++) {
		bots[i].can_go_fast = 30;
		bots[i].precision = 60;
		bots[i].patience = 30;
		bots[i].fudge_x = 0;
		bots[i].fudge_y = 0;
		bots[i].fudge_factor = 0;
		bots[i].last_speed_change = 0;
		bots[i].difficulty = 1;
	}
	memset(path,0,sizeof(path[0][0]) * 200 * 120 * NUM_SPRITES);
	// Load the vertex shader, create a shader program and bind it
	vshader_dvlb = DVLB_ParseFile((u32*)vshader_shbin, vshader_shbin_size);
	shaderProgramInit(&program);
	shaderProgramSetVsh(&program, &vshader_dvlb->DVLE[0]);
	C3D_BindProgram(&program);

	// Get the location of the uniforms
	uLoc_projection = shaderInstanceGetUniformLocation(program.vertexShader, "projection");


	/*textshader_dvlb = DVLB_ParseFile((u32*)textshader_shbin, textshader_shbin_len);
	shaderProgramInit(&textprogram);
	shaderProgramSetVsh(&textprogram, &textshader_dvlb->DVLE[0]);
	C3D_BindProgram(&textprogram);

	// Get the location of the uniforms
	textuLoc_projection = shaderInstanceGetUniformLocation(textprogram.vertexShader, "textprojection");*/

	// Configure attributes for use with the vertex shader
	// Attribute format and element count are ignored in immediate mode
	C3D_AttrInfo* attrInfo = C3D_GetAttrInfo();
	AttrInfo_Init(attrInfo);
	AttrInfo_AddLoader(attrInfo, 0, GPU_FLOAT, 3); // v0=position
	AttrInfo_AddLoader(attrInfo, 1, GPU_FLOAT, 2); // v2=texcoord

	// Compute the projection matrix
	// Note: we're setting top to 240 here so origin is at top left.
	Mtx_OrthoTilt(&projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0, true);


	// Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);

	unsigned char* image;
	unsigned width, height;

	lodepng_decode32(&image, &width, &height, bike_png, bike_png_size);
	u8 *gpusrc = linearAlloc(width*height*4);

	// GX_DisplayTransfer needs input buffer in linear RAM
	u8* src=image; u8 *dst=gpusrc;

	// lodepng outputs big endian rgba so we need to convert
	for(int i = 0; i<width*height; i++) {
		int r = *src++;
		int g = *src++;
		int b = *src++;
		int a = *src++;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, width*height*4);

	// Load the texture and bind it to the first texture unit
	C3D_TexInit(&spritesheet_tex, width, height, GPU_RGBA8);

	// Convert image to 3DS tiled texture format
	GX_DisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(width,height), (u32*)spritesheet_tex.data, GX_BUFFER_DIM(width,height), TEXTURE_TRANSFER_FLAGS);
	gspWaitForPPF();

	C3D_TexSetFilter(&spritesheet_tex, GPU_LINEAR, GPU_NEAREST);
	C3D_TexBind(0, &spritesheet_tex);

	lodepng_decode32(&image, &width, &height, qrcode_png, qrcode_png_size);
	gpusrc = linearAlloc(width*height*4);

	// GX_DisplayTransfer needs input buffer in linear RAM
	src=image; dst=gpusrc;

	// lodepng outputs big endian rgba so we need to convert
	for(int i = 0; i<width*height; i++) {
		int r = *src++;
		int g = *src++;
		int b = *src++;
		int a = *src++;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, width*height*4);

	// Load the texture and bind it to the first texture unit
	C3D_TexInit(&qrcode_tex, width, height, GPU_RGBA8);

	// Convert image to 3DS tiled texture format
	GX_DisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(width,height), (u32*)qrcode_tex.data, GX_BUFFER_DIM(width,height), TEXTURE_TRANSFER_FLAGS);
	gspWaitForPPF();

	C3D_TexSetFilter(&qrcode_tex, GPU_LINEAR, GPU_NEAREST);

	//C3D_TexBind(0, &qrcode_tex);
	free(image);
	linearFree(gpusrc);

	// Configure the first fragment shading substage to just pass through the texture color
	// See https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnv.xml for more insight
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, GPU_PRIMARY_COLOR, GPU_PRIMARY_COLOR);
    C3D_TexEnvOp(env, C3D_Both, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR);
    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
	


	setSprites();
	// Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
	C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);

	Mtx_OrthoTilt(&textprojection, 0.0, 320.0, 240.0, 0.0, 0.0, 1.0, true);
	int i;
	TGLP_s* glyphInfo = fontGetGlyphInfo();
	glyphSheets = malloc(sizeof(C3D_Tex)*glyphInfo->nSheets);
	for (i = 0; i < glyphInfo->nSheets; i ++)
	{
		C3D_Tex* tex = &glyphSheets[i];
		tex->data = fontGetGlyphSheetTex(i);
		tex->fmt = glyphInfo->sheetFmt;
		tex->size = glyphInfo->sheetSize;
		tex->width = glyphInfo->sheetWidth;
		tex->height = glyphInfo->sheetHeight;
		tex->param = GPU_TEXTURE_MAG_FILTER(GPU_LINEAR) | GPU_TEXTURE_MIN_FILTER(GPU_LINEAR)
			| GPU_TEXTURE_WRAP_S(GPU_CLAMP_TO_EDGE) | GPU_TEXTURE_WRAP_T(GPU_CLAMP_TO_EDGE);
	}

	// Create the text vertex array
	textVtxArray = (textVertex_s*)linearAlloc(sizeof(textVertex_s)*TEXT_VTX_ARRAY_COUNT);

	frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);


}
static void reversePath(int n) {
	Path temp;
	int start = pathPos[n];
	int end = currentPath[n];
    while (abs(start - end) > 1)
    {
        temp = path[start][n];   
        path[start][n] = path[end][n];
        path[end][n] = temp;
        start++;
        end--;
        if (start >= 120 * 200 - 1) start = 0;
        if (end < 0) end = 120 * 200 - 1;
    }

    /*int tempPath = currentPath[n];
    currentPath[n] = pathPos[n];
    pathPos[n] = tempPath;*/
    while (path[currentPath[n]][n].x == 0 && path[currentPath[n]][n].y == 0) {
    	currentPath[n]--;
    	if (currentPath[n] < 0) currentPath[n] = 240 * 400 - 1;
    }
    int tempPath = currentPath[n];
    sprites[n].x = path[tempPath][n].x;
    sprites[n].y = path[tempPath][n].y;
    tempPath--;
    if (tempPath < 0) tempPath = 120 * 200 - 1;
    sprites[n].dx *= -1;
    sprites[n].dy *= -1;
    if (path[tempPath][n].x == path[currentPath[n]][n].x) {
    	sprites[n].dx = 0;
    	if (path[tempPath][n].y > path[currentPath[n]][n].y) sprites[n].dy = bikeSpeed * -1;
    	else sprites[n].dy = bikeSpeed;
    } else if (path[tempPath][n].y == path[currentPath[n]][n].y) {
    	sprites[n].dy = 0;
    	if (path[tempPath][n].x > path[currentPath[n]][n].x) sprites[n].dx =  bikeSpeed * -1;
    	else sprites[n].dx = bikeSpeed;
    }
}
static void printScore() {
	if (!options[7]) {
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[0;0HScore: ");
		char scores[12];
		for (int i = 0; i < numPlayers(); i++) {
			if (sprites[i].dead) snprintf(scores,sizeof(scores),"%s%d", GREY,score[i]);
			else snprintf(scores,sizeof(scores),"%s%d", textColors[i],score[i]);
			strcat(mystring,scores);
			if (i < numPlayers() - 1) { snprintf(scores,sizeof(scores)," %s- ",WHITE); strcat(mystring,scores); }
		}
		myprintf(mystring);
	} else {
		clearString();
		snprintf(mystring,sizeof(mystring),"\x1b[0;0HAlive: ");
		char living[50];
		for (int i = 0; i < numPlayers(); i++) {
			if (!sprites[i].dead) {
				memset(living,0,sizeof(living));
				if (sprites[i].dead) snprintf(living,sizeof(living),"%s%s%s",GREY,sprites[i].username,WHITE);
				else snprintf(living,sizeof(living),"%s%s%s",textColors[i],sprites[i].username,WHITE);
				if (strlen(mystring) < 140) {
					strcat(mystring,living);
					if (i < numPlayers() - 1) strcat(mystring,", ");
				}
			}
		}
		myprintf(mystring);
	}
	death = dead;
	if (!death) death = dead2;
	if (sprites[myNum].dead) { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sYou are %sdead%s (%s%s%s)",WHITE,RED,WHITE,textColors[getKiller(death)],sprites[getKiller(death)].username,WHITE); myprintf(mystring); }
	else { 
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sYou are %salive%s! ",WHITE,GREEN,WHITE);
		myprintf(mystring);
	}
	if (!sprites[myNum].dead) {
		if (!options[3]) {
			clearString(); snprintf(mystring,sizeof(mystring),"\x1b[2;0HHold %s%s to move Faster.",RED,WHITE);
			myprintf(mystring);
		}
		if (!options[4]) {
			clearString(); snprintf(mystring,sizeof(mystring),"\x1b[3;0HHold %s%s to move Slower.",YELLOW,WHITE);
			myprintf(mystring);
		}
	} else {
		if (actual_bikes == 1) {
			snprintf(mystring,sizeof(mystring),"\x1b[2;0HPress %s%s to forfeit.",RED,WHITE);
			myprintf(mystring);
			myprintf("\x1b[3;0H");
		}
	}
	if (!options[5]) {
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[4;0HPress %s%s to teleport the apple once.",GREEN,WHITE);
		myprintf(mystring);
	}
	if (options[6]) {
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[5;0HPress  to go in reverse."); myprintf(mystring);
	}
	if (everyoneElseIsDead(myNum)) { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[6;0HGet %d more points!",theHighest() - score[myNum] + 1); myprintf(mystring); }
	int x = 8;
	if (options[6]) x = 9;
	for (int i = actual_bikes; i < numPlayers(); i++) {
		clearString(); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s has joined the game.",x + i - actual_bikes,textColors[i],sprites[i].username,WHITE);
		myprintf(mystring);
	}
	int screenScore = totalSpace;
	if (options[4]) screenScore *= 1.25;
	if (options[5]) screenScore *= 1.25;
	snprintf(mystring,sizeof(mystring),"\x1b[7;0H%sScreen Score: %d",WHITE,screenScore);
	if ((unsigned int)screenScore > highScore) snprintf(mystring,sizeof(mystring),"\x1b[7;0HScreen Score: %s%d",RAINBOW,screenScore);
	myprintf(mystring);
	if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[5;0Hpathpos: %d currentpath: %d",pathPos[myNum],currentPath[myNum]); myprintf(mystring); }
	//myprintf("\x1b[5;0Hdead: 0x%08x, 0x%08x",dead,dead2);
	//myprintf("\x1b[6;0Hnum_bikes: %d, myNum: %d",num_bikes,myNum);
	//myprintf("\x1b[7;0Hgrowth: %d length: %d (%d)",growth[myNum],sprites[myNum].length,getLength(myNum));
	//myprintf("\x1b[8;0HpathPos: %d currentPath: %d",pathPos[myNum],currentPath[myNum]);
}
/*static void drawLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, int img) {
	int w = (dx ) - (sx );
	int h = (dy ) - (sy );
	int x = sx;
	int y = sy;
	if (w < 0 || h < 0) { 
		x = dx;
		y = dy;
	}
	w = abs(w);
	h = abs(h);
	//drawSprite(x , y , w, h, img);
	if (w <= 2) { h = 2; w = 0; }
	else { h = 0; w = 2; }
	while (pathnum != currentPath[img]) {
		drawSprite(path[pathnum][img].x , path[pathnum][img].y , 2, 2, 9);
		drawSprite(x , y , 2, 2, img);
		path[pathnum][img].x = x;
		x += w;
		path[pathnum][img].y = y;
		y += h;
		pathnum++;
		if (pathnum >= 120 * 200) pathnum = 0;
	}
	path[pathnum][img].x = x;
	path[pathnum][img].y = y;
	drawSprite(x , y , 2, 2, img);
}*/
static void fixLength(int img) {
	int oldpathn = pathPos[img];
	int pathn = currentPath[img];
	int i = 0;
	while (getLength(img) <= sprites[img].length + 1 - growth[img] && i < 20 && path[oldpathn][img].x && path[oldpathn][img].y) {
		i++;
		if (path[oldpathn][img].x && path[oldpathn][img].y) overwriteSprite(path[oldpathn][img].x , path[oldpathn][img].y , 2, 2, img);
		oldpathn--;
		if (oldpathn < 0) oldpathn = 120 * 200 - 1;
		pathPos[img] = oldpathn;
	}
	if (!path[oldpathn][img].x || !path[oldpathn][img].y) return;
	currentPath[img] = pathn;
	pathPos[img] = oldpathn;
	sprites[img].x = path[currentPath[img]][img].x;
	sprites[img].y = path[currentPath[img]][img].y;
}
static void finishLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, Sprite msg, int img) {
	if (sx == dx && sy == dy) {
		overwriteSprite(dx,dy,2,2,getImg(img));
		return;
	}
	if (msg.diag && sprites[img].diag) {
		if (sprites[img].diag == SOUTHWEST && msg.diag == NORTHEAST) return;
		else if (sprites[img].diag == SOUTHEAST && msg.diag == NORTHWEST) return;
		else if (sprites[img].diag == NORTHEAST && msg.diag == SOUTHWEST) return;
		else if (sprites[img].diag == NORTHWEST && msg.diag == SOUTHEAST) return;
	}
	int udx = dx;
	int udy = dy;
	int x = sx;
	int y = sy;
	int w = udx - x;
	int h = udy - y;
	if (abs(w) > 100 || abs(h) > 100) return;



	//drawSprite(x , y , w, h, img);
	int pathn = currentPath[img] - 1;
	if (pathn < 0) pathn = 120 * 200 - 1;
	int prevx = path[pathn][img].x;
	int prevy = path[pathn][img].y;
	pathn--;
	if (pathn < 0) pathn = 120 * 200 - 1;
	int prevx2 = path[pathn][img].x;
	int prevy2 = path[pathn][img].y;
	pathn = currentPath[img];
	int i = 0;
	if (x != udx && y != udy) {
		int tx, ty;
		if (w < 0) tx = -2;
		else tx = 2;
		if (h < 0) ty = -2;
		else ty = 2;
		if ((prevx - prevx2 > 0 && w > 0) || (prevx - prevx2 < 0 && w < 0) || (prevy - prevy2 > 0 && h > 0) || (prevy - prevy2 < 0 && h < 0)) {//draw
			if (x != udx && y != udy && sprites[img].x + sprites[img].dx != udx && sprites[img].y + sprites[img].dy != udy) {
				if (msg.diag || sprites[img].diag) { //they are going diagonal or have been going diagonal...
					if (!sprites[img].diag && msg.diag) {
						if (debugging) myprintf("not diag to diag");
						while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x; y = path[pathn][img].y; }
						i = 0;
						currentPath[img] = pathn;
						while ((x != udx || y != udy) && i < 20) {
							i++;
							x += tx;
							overwriteSprite(x,y,2,2,img);
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x;
							path[pathn][img].y = y;
							if (x == udx && y == udy) break;
							y += ty;
							overwriteSprite(x,y,2,2,img);
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x;
							path[pathn][img].y = y;
						}
						currentPath[img] = pathn;
					} else if (sprites[img].diag && !msg.diag) {
						if (debugging) myprintf("diag to not diag");
						while (x != udx && y != udy && i < 20) { i++; overwriteSprite(x,y,2,2,9); path[pathn][img].x = 500; path[pathn][img].y = 500; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x; y = path[pathn][img].y; }
						i = 0;
						currentPath[img] = pathn;
						if (x == udx) while (y != udy && i < 20) { i++; overwriteSprite(x,y,2,2,img); y += ty; pathn++; if (pathn >= 120 * 200) pathn = 0; path[pathn][img].x = x; path[pathn][img].y = y; }
						else if (y == udy) while (x != udx && i < 20) { i++; overwriteSprite(x,y,2,2,img); x += tx; pathn++; if (pathn >= 120 * 200) pathn = 0;  path[pathn][img].x = x; path[pathn][img].y = y; }
						currentPath[img] = pathn;
					}
					else {
						if (debugging) myprintf("diag to diag");
						while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x; y = path[pathn][img].y; }
						if (udx - x < 0) tx = -2;
						else tx = 2;
						if (udy - y < 0) ty = -2;
						else ty = 2;
						i = 0;
						currentPath[img] = pathn;
						while ((x != udx || y != udy) && i < 20) {
							i++;
							x += tx;
							overwriteSprite(x,y,2,2,img);
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x;
							path[pathn][img].y = y;
							if (x == udx && y == udy) break;
							y += ty;
							overwriteSprite(x,y,2,2,img);
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x;
							path[pathn][img].y = y;
						}
						currentPath[img] = pathn;
					}
				} else { //They are further than where they were, and are not in line with their previous line.
					if (debugging) myprintf("further than where they were, not in line with previous line");
					if (prevx == prevx2) {
						if (debugging) myprintf("prevx == prevx2");
						while (y != udy && i < 20) { //first branch. draw the y
							i++;
							overwriteSprite(x,y,2,2,img);
							y += ty;
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x;
							path[pathn][img].y = y;
						}
						i = 0;
						while (x != udx && i < 20) { //second branch. draw the x
							i++;
							overwriteSprite(x,y,2,2,img);
							x += tx;
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x;
							path[pathn][img].y = y;
						}
					} else if (prevy == prevy2) {
						if (debugging) myprintf("prevy == prevy2");
						while (x != udx && i < 20) { //first branch. draw the x
							i++;
							overwriteSprite(x,y,2,2,img);
							x += tx;
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x;
							path[pathn][img].y = y;
						}
						i = 0;
						while (y != udy && i < 20) { //second branch. draw the y
							i++;
							overwriteSprite(x,y,2,2,img);
							y += ty;
							pathn++;
							if (pathn >= 120 * 200) pathn = 0;
							path[pathn][img].x = x;
							path[pathn][img].y = y;
						}
					}
				}
				currentPath[img] = pathn;
				i = 0;
				sprites[img].x = path[currentPath[img]][img].x;
				sprites[img].y = path[currentPath[img]][img].y;
				return;
			}

		} 
		else { //erase
			if (debugging) myprintf("!!!!");
			if (msg.diag || sprites[img].diag) { //they are going diagonal or have been going diagonal...
				if (!sprites[img].diag && msg.diag) {
					if (debugging) myprintf("slow not diag to diag");
					if (prevx == prevx2) ty *= -1;
					else if (prevy == prevy2) tx *= -1;
					while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x; y = path[pathn][img].y; }
					i = 0;
					currentPath[img] = pathn;
					while ((x != udx || y != udy) && i < 20) {
						i++;
						x += tx;
						overwriteSprite(x,y,2,2,img);
						pathn++;
						if (pathn >= 120 * 200) pathn = 0;
						path[pathn][img].x = x;
						path[pathn][img].y = y;
						if (x == udx && y == udy) break;
						y += ty;
						overwriteSprite(x,y,2,2,img);
						pathn++;
						if (pathn >= 120 * 200) pathn = 0;
						path[pathn][img].x = x;
						path[pathn][img].y = y;
					}
					currentPath[img] = pathn;
				} else if (sprites[img].diag && !msg.diag) {
					if (debugging) myprintf("slow diag to not diag");
					while ((x != udx && y != udy) && i < 20) {
						i++;
						overwriteSprite(x,y,2,2,9);
						pathn--;
						if (pathn < 0) pathn = 120 * 200 - 1;
						x = path[pathn][img].x;
						y = path[pathn][img].y;
						path[pathn][img].x = 500;
						path[pathn][img].y = 500;
					}
					i = 0;
					path[pathn][img].x = x;
					path[pathn][img].y = y;
					if (x == udx) while (y != udy && i < 20) { i++; overwriteSprite(x,y,2,2,img); y += ty; pathn++; if (pathn >= 120 * 200) pathn = 0; path[pathn][img].x = x; path[pathn][img].y = y; }
					else if (y == udy) while (x != udx && i < 20) { i++; overwriteSprite(x,y,2,2,img); x += tx; pathn++; if (pathn >= 120 * 200) pathn = 0; path[pathn][img].x = x; path[pathn][img].y = y; }
					currentPath[img] = pathn;
				}
				else {
					if (debugging) myprintf("slow diag to diag");
					if (msg.diag == SOUTHEAST) {
						tx = 2;
						ty = 2;
					} else if (msg.diag == SOUTHWEST) {
						tx = -2;
						ty = 2;
					} else if (msg.diag == NORTHWEST) {
						tx = -2;
						ty = -2;
					} else if (msg.diag == NORTHEAST) {
						tx = 2;
						ty = -2;
					}
					while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x; y = path[pathn][img].y; }
					if (udx - x < 0) tx = -2;
					else tx = 2;
					if (udy - y < 0) ty = -2;
					else ty = 2;
					i = 0;
					currentPath[img] = pathn;
					while ((x != udx || y != udy) && i < 20) {
						i++;
						x += tx;
						overwriteSprite(x,y,2,2,img);
						pathn++;
						if (pathn >= 120 * 200) pathn = 0;
						path[pathn][img].x = x;
						path[pathn][img].y = y;
						if (x == udx && y == udy) break;
						y += ty;
						overwriteSprite(x,y,2,2,img);
						pathn++;
						if (pathn >= 120 * 200) pathn = 0;
						path[pathn][img].x = x;
						path[pathn][img].y = y;
					}
					currentPath[img] = pathn;
				}
			}
			else if (prevx == prevx2) {
				while ((path[pathn][img].y ) != udy && i < 20) { i++; overwriteSprite(path[pathn][img].x ,path[pathn][img].y ,2,2,9); path[pathn][img].x = 500; path[pathn][img].y = 500; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; }
				x = path[pathn][img].x;
				y = path[pathn][img].y;
				i = 0;
				//overwriteSprite(x,y,2,2,img);
				while ((path[pathn][img].x ) != udx && i < 20) { i++; x += tx; pathn++; overwriteSprite(x,y,2,2,getAndDecImg(img)); path[pathn][img].x = x; path[pathn][img].y = y; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] >= 120 * 200) currentPath[img] = 0; if (pathn >= 120 * 200) pathn = 0; }
				//if (pathn == currentPath[img]) currentPath[img]++;
				if (currentPath[img] >= 120 * 200) currentPath[img] = 0;
			}
			else if (prevy == prevy2) {
				while ((path[pathn][img].x ) != udx && i < 20) { i++; overwriteSprite(path[pathn][img].x ,path[pathn][img].y ,2,2,9); path[pathn][img].x = 500; path[pathn][img].y = 500; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; }
				x = path[pathn][img].x;
				y = path[pathn][img].y;
				i = 0;
				//overwriteSprite(x,y,2,2,img);
				while ((path[pathn][img].y ) != udy && i < 20) { i++; y += ty; overwriteSprite(x,y,2,2,getAndDecImg(img)); pathn++; path[pathn][img].x = x; path[pathn][img].y = y; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] >= 120 * 200) currentPath[img] = 0; if (pathn >= 120 * 200) pathn = 0; }
				//if (pathn == currentPath[img]) currentPath[img]++;
				if (currentPath[img] >= 120 * 200) currentPath[img] = 0;
			} else if (sprites[img].diag) {
				if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"%sYEP%s",RED,WHITE); myprintf(mystring); }
			}
			overwriteSprite(dx,dy,2,2,getAndDecImg(img));
		}
		sprites[img].x = path[currentPath[img]][img].x;
		sprites[img].y = path[currentPath[img]][img].y;
	}


	if (w == 0) { 
		if (h < 0) h = -2; 
		else h = 2; 
		w = 0; 
	}
	else { 
		h = 0; 
		if (w < 0) w = -2; 
		else w = 2; 
	}


	dx = dx;
	dy = dy;
	if ((udx - x > 0 && sprites[img].dx  < 0) || (udx - x < 0 && sprites[img].dx  > 0) || (udy - y < 0 && sprites[img].dy  > 0) || (udy - y > 0 && sprites[img].dy  < 0)) { //Erase overshoot.
		i = 0;
		if (udx == x) { 
			if (abs(udy - y) > 2) {
				while (path[pathn][img].y != udy && i < 20) { i++; overwriteSprite(path[pathn][img].x , path[pathn][img].y , 2, 2, 9); path[pathn][img].x = 500; path[pathn][img].y = 500; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; } 
				//drawSprite(path[pathn][img].x , path[pathn][img].y , 2, 2, 9); 
				i = 0;
				currentPath[img] = pathn; 
				//growth[img] += i;
				int oldpathn = pathPos[img]; //fix the length we removed
				while (getLength(img) <= sprites[img].length + 1 - growth[img] && i < 20) {
					i++;
					overwriteSprite(path[oldpathn][img].x , path[oldpathn][img].y , 2, 2, img);
					oldpathn--;
					if (oldpathn < 0) oldpathn = 120 * 200 - 1;
					pathPos[img] = oldpathn;
				}
				overwriteSprite(udx, udy, 2, 2, img);
				sprites[img].x = path[currentPath[img]][img].x;
				sprites[img].y = path[currentPath[img]][img].y;
				return; 
			}
		}
		else if (udy == y) { 
			if (abs(udx - x) > 2) {
				while (path[pathn][img].x  != udx && i < 20) { i++; overwriteSprite(path[pathn][img].x , path[pathn][img].y , 2, 2, 9); path[pathn][img].x = 500; path[pathn][img].y = 500; pathn--; if (pathn < 0) pathn = 120 * 200 - 1; } 
				//drawSprite(path[pathn][img].x , path[pathn][img].y , 2, 2, 9); 
				currentPath[img] = pathn; 
				//growth[img] += i; 
				i = 0;
				int oldpathn = pathPos[img]; //fix the length we removed
				while (getLength(img) <= sprites[img].length + 1 - growth[img] && i < 20) {
					i++;
					overwriteSprite(path[oldpathn][img].x , path[oldpathn][img].y , 2, 2, img);
					oldpathn--;
					if (oldpathn < 0) oldpathn = 120 * 200 - 1;
					pathPos[img] = oldpathn;
				}
				overwriteSprite(udx, udy, 2, 2, img);
				sprites[img].x = path[currentPath[img]][img].x;
				sprites[img].y = path[currentPath[img]][img].y;
				return; 
			}
		}
	} else { //draw undershoot
		i = 0;
		int oldpathn = pathPos[img];
		if (udx == x) { 
			overwriteSprite(x, y, 2, 2, img); 
			while (y != udy && i < 20) { 
				i++; 
				y += h; 
				overwriteSprite(x, y, 2, 2, img); 
				overwriteSprite(path[oldpathn][img].x , path[oldpathn][img].y , 2, 2, 9); 
				pathn++; 
				oldpathn++; 
				if (pathn >= 120 * 200) pathn = 0; 
				if (oldpathn >= 120 * 200) oldpathn = 0; 
				path[pathn][img].x = x;
				path[pathn][img].y = y;
			} 
			pathPos[img] = oldpathn; 
			currentPath[img] = pathn; 
			sprites[img].x = path[currentPath[img]][img].x; 
			sprites[img].y = path[currentPath[img]][img].y; 
		}
		else if (udy == y) { 
			overwriteSprite(x, y, 2, 2, img); 
			while (x != udx && i < 20) { 
				i++; 
				x += w; 
				overwriteSprite(x, y, 2, 2, img); 
				overwriteSprite(path[oldpathn][img].x , path[oldpathn][img].y , 2, 2, 9); 
				pathn++; 
				oldpathn++; 
				if (pathn >= 120 * 200) pathn = 0; 
				if (oldpathn >= 120 * 200) oldpathn = 0; 
				path[pathn][img].x = x; 
				path[pathn][img].y = y; 
			} 
			pathPos[img] = oldpathn; 
			currentPath[img] = pathn; 
			sprites[img].x = path[currentPath[img]][img].x; 
			sprites[img].y = path[currentPath[img]][img].y; 
		}
	}
	//if (x != udx && y != udy && (sprites[img].x + sprites[img].dx != udx || sprites[img].y + sprites[img].dy != udy)) return;
	i = 0;

	if (w != 0 && h != 0) {
		return;
	}
	//Now fill in shortcomings.
	int c = rand() % 9;
	if (udx == prevx && udy == prevy) {
		if (debugging) {
			while (c == img) c = rand() % 9;
			overwriteSprite(sx ,sy ,2,2,c);
			overwriteSprite(dx, dy, 2, 2, c);
		}
		sprites[img].x = path[currentPath[img]][img].x;
		sprites[img].y = path[currentPath[img]][img].y;
		return;
	}
	if (debugging) {
		while (c == img) c = rand() % 9;
		clearString(); snprintf(mystring,sizeof(mystring),"%sok.%s",textColors[c],WHITE);
		myprintf(mystring);
	}
	//drawSprite(sx,sy,2,2,c);
	if (msg.diag || sprites[img].diag) {
		int tx = 2;
		int ty = 2;
		if (msg.diag == SOUTHEAST) {
			tx = 2;
			ty = 2;
		} else if (msg.diag == SOUTHWEST) {
			tx = -2;
			ty = 2;
		} else if (msg.diag == NORTHWEST) {
			tx = -2;
			ty = -2;
		} else if (msg.diag == NORTHEAST) {
			tx = 2;
			ty = -2;
		}
		while ((udx - x) / tx != (udy - y) / ty && i < 20) { i++; overwriteSprite(x,y,2,2,9); pathn--; if (pathn < 0) pathn = 120 * 200 - 1; x = path[pathn][img].x; y = path[pathn][img].y; }
		if (udx - x < 0) tx = -2;
		else tx = 2;
		if (udy - y < 0) ty = -2;
		else ty = 2;
		i = 0;
		currentPath[img] = pathn;
		while ((x != udx || y != udy) && i < 20) {
			i++;
			x += tx;
			overwriteSprite(x,y,2,2,img);
			pathn++;
			if (pathn >= 120 * 200) pathn = 0;
			path[pathn][img].x = x;
			path[pathn][img].y = y;
			if (x == udx && y == udy) break;
			y += ty;
			overwriteSprite(x,y,2,2,img);
			pathn++;
			if (pathn >= 120 * 200) pathn = 0;
			path[pathn][img].x = x;
			path[pathn][img].y = y;
		}
		currentPath[img] = pathn;
		return;
	}
	i = 0;
	while ((x != dx || y != dy) && (i < 8)) {
		i++;	

		path[currentPath[img]][img].y = (y );
		path[currentPath[img]][img].x = (x );
		overwriteSprite(x, y, 2, 2, getAndDecImg(img));
		currentPath[img]++;
		if (currentPath[img] >= 120 * 200) currentPath[img] = 0;
		x += w;
		
		y += h;
		
	}
	path[currentPath[img]][img].y = (y );
	path[currentPath[img]][img].x = (x );
	sprites[img].x = path[currentPath[img]][img].x;
	sprites[img].y = path[currentPath[img]][img].y;
}
static void eraseOvershoot(Sprite sprite) {
	int img = sprite.image;
	int cx = path[currentPath[img]][img].x;
	int cy = path[currentPath[img]][img].y;
	int udx = sprite.x;
	int udy = sprite.y;
	if (udx == cx && udy == cy) { fixLength(img); return; }
	if ((path[currentPath[img]][img].x + sprites[img].dx)  == udx && (path[currentPath[img]][img].y + sprites[img].dy)  == udy) { finishLine(currentPath[img],sprites[img].x,sprites[img].y,sprite.x,sprite.y,sprite,img); fixLength(img); return; }
	if ((udx - cx > 0 && sprite.dx > 0) || (udx - cx < 0 && sprite.dx < 0) || (udy - cy < 0 && sprite.dy < 0) || (udy - cy > 0 && sprite.dy > 0)) { 
		finishLine(currentPath[img],sprites[img].x,sprites[img].y,sprite.x,sprite.y,sprite,img);
		fixLength(img); 
		return;
	}
	if (udx != cx && udy != cy) { finishLine(currentPath[img],sprites[img].x,sprites[img].y,sprite.x,sprite.y,sprite,img); fixLength(img); return; }
	/*snprintf(mystring,sizeof(mystring),"%d %d != %d %d",cx,cy,udx,udy);
	myprintf(mystring);*/
	int pathn = currentPath[img];
	int oldpathn = pathPos[img];
	int i = 0;
	while (((path[pathn][img].x ) != udx || (path[pathn][img].y ) != udy) && pathn != pathPos[img] && i < 40) {
		i++;
		drawSprite(path[pathn][img].x , path[pathn][img].y , 2, 2, 9);
		pathn--;
		overwriteSprite(path[oldpathn][img].x , path[oldpathn][img].y , 2, 2, img);
		oldpathn--;
		if (pathn < 0) pathn = 120 * 200 - 1;
		if (oldpathn < 0) oldpathn = 120 * 200 - 1;
	}
	currentPath[img] = pathn;
	pathPos[img] = oldpathn;
	i = 0;
	while (getLength(img) <= sprites[img].length + 1 - growth[img] && i < 20) {
		i++;
		overwriteSprite(path[oldpathn][img].x , path[oldpathn][img].y , 2, 2, img);
		oldpathn--;
		if (oldpathn < 0) oldpathn = 120 * 200 - 1;
		pathPos[img] = oldpathn;
	}
	currentPath[img] = pathn;
	pathPos[img] = oldpathn;
	sprites[img].x = path[currentPath[img]][img].x;
	sprites[img].y = path[currentPath[img]][img].y;
}
void pushScene(void (*initialization)(), void (*update)(), void (*draw)(), void (*finish)()) {
    Scene *newScene = malloc(sizeof(Scene)); //allocate memory for a new scene in the SceneStack
    if (newScene == NULL) {
        showMemoryError();
        return;
    }
    newScene->initialized = false;
    newScene->init = initialization; //initialization function for the scene
    newScene->update = update; //input/update function for the scene
    newScene->draw = draw; //draw function for the scene
    newScene->finish = finish; //clean up function once the scene is popped
    if (scenes == NULL) newScene->next = NULL;
    else newScene->next = scenes; //next scene in the stack
 
    scenes = newScene; //push this new scene to the top of the stack
    numScenes++;
}
void clearScenes() {
	if (scenes == NULL) return;
	Scene *c = scenes;
	Scene *temp = NULL;
	while (c != NULL) {
		temp = c;
		c = c->next;
		free(temp);
	}
	scenes = NULL;
	numScenes = 0;
}
void popScene() {
	if (scenes == NULL) return;
    Scene *temp = scenes;
    if (scenes->finish != NULL) scenes->finish(); //if there is a finish function, execute it
    if (scenes->next != NULL) scenes = scenes->next; //set the top of the stack to be the next scene
    else scenes = NULL;
    temp->next = NULL;
    free(temp); //free the current scene
    temp = NULL;
    numScenes--;
}
void failure_message_init() {
	myprintf("CATASTROPHIC_FAILURE");
}
void failure_message_update() {
	keepConsole();
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_A || !debugging) {
		CATASTROPHIC_FAILURE = true;
		return;
	} 
	if (kDown & KEY_START) {
		CATASTROPHIC_FAILURE = true;
		return;
	}
}
void failure_message_finish() {
	myconsoleClear();
}
void displayMessageInit() {
	myprintf("testing one two three...");
}
void displayMessage() {
	keepConsole();
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_A) {
		popScene();
		return;
	} 
	if (kDown & KEY_START) {
		popScene();
		return;
	}
}
void displayMessageFinish() {
	myconsoleClear();
}
void options_menu_init() {
	myconsoleClear();
	gselected = 0;
	gload = 0;
	glastLoad = svcGetSystemTick();
}
void options_menu_update() {
	myprintf("\x1b[0;0HOptions Menus:");
	if (gselected == 0) myprintf("\x1b[2;0H!.yGame Modes");
		else myprintf("\x1b[2;0H!.wGame Modes");
	if (gselected == 1) myprintf("\x1b[3;0H!.yBot Opponents");
		else myprintf("\x1b[3;0H!.wBot Opponents");
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_A) {
		if (gselected == 0) {
			pushScene(gameOptions_init,gameOptions,NULL,NULL);
			return;
		} else {
			pushScene(difficulty_menu_init,difficulty_menu_update,difficulty_menu_draw,difficulty_menu_finish);
			return;
		}
	}
	if (kDown & KEY_B || kDown & KEY_SELECT || kDown & KEY_START) {
		popScene();
		return;
	}
	if (kDown & KEY_DDOWN || kDown & KEY_CPAD_DOWN) {
		gselected++;
		if (gselected > 1) gselected = 0;
	}
	if (kDown & KEY_DUP || kDown & KEY_CPAD_UP) {
		gselected--;
		if (gselected < 0) gselected = 1;
	}
}
void options_menu_draw() {
	keepConsole();
}
void options_menu_finish() {
	ignoreB = true;
}
u32 oldKHeld = 0;
u64 lastHeld = 0;
void opponent_options_init() {
	myconsoleClear();
	snprintf(gselectedColor,sizeof(gselectedColor)," ");
	snprintf(botsColor,sizeof(botsColor),"%s",WHITE);
	specialSelection = -1;
	gselected = 0;
	gload = 0;
	glastLoad = svcGetSystemTick();
}
void opponent_options_update() {
	if (gselected == 0) {
		snprintf(gselectedColor,sizeof(gselectedColor),"%s",YELLOW);
	}
	else {
		snprintf(gselectedColor,sizeof(gselectedColor),"%s",WHITE);
	}
	if (specialSelection == 0) { snprintf(botsColor,sizeof(botsColor),"%s",RED); }
	else { snprintf(botsColor,sizeof(botsColor),"%s",WHITE); }
	snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sNumber of Bots: %s%d",gselectedColor,botsColor,numOpponents);
	myprintf(mystring);
	for (int i = 0; i < numOpponents; i++) {
		//Bot #
		if (gselected == i * 4 + 1) snprintf(gselectedColor,sizeof(gselectedColor),"%s",YELLOW);
		else snprintf(gselectedColor,sizeof(gselectedColor),"%s",WHITE);
		snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%sBot %c",i * 4 + 1,textColors[i + 1],('A' + i));
		myprintf(mystring);

		//	Allow A:
		if (gselected == i * 4 + 2) snprintf(gselectedColor,sizeof(gselectedColor),"%s",YELLOW);
		else snprintf(gselectedColor,sizeof(gselectedColor),"%s",WHITE);
		if (specialSelection == i * 4 + 2) snprintf(botsColor,sizeof(botsColor),"%s",RED);
		else snprintf(botsColor,sizeof(botsColor),"%s",WHITE);
		snprintf(mystring,sizeof(mystring),"\x1b[%d;0H   %s%s%sAggressiveness: %s%d%%",i * 4 + 2,BLACK,loading[gload],gselectedColor, botsColor, bots[i + 1].can_go_fast);
		myprintf(mystring);

		//  Precision: 80%
		if (gselected == i * 4 + 3) snprintf(gselectedColor,sizeof(gselectedColor),"%s",YELLOW);
		else snprintf(gselectedColor,sizeof(gselectedColor),"%s",WHITE);
		if (specialSelection == i * 4 + 3) snprintf(botsColor,sizeof(botsColor),"%s",RED);
		else snprintf(botsColor,sizeof(botsColor),"%s",WHITE);
		snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s   %s%s%sPrecision: %s%d%%",i * 4 + 3,gselectedColor,BLACK,loading[gload],gselectedColor,botsColor,bots[i + 1].precision);
		myprintf(mystring);

		//  Patience: 30
		if (gselected == i * 4 + 4) snprintf(gselectedColor,sizeof(gselectedColor),"%s",YELLOW);
		else snprintf(gselectedColor,sizeof(gselectedColor),"%s",WHITE);
		if (specialSelection == i * 4 + 4) snprintf(botsColor,sizeof(botsColor),"%s",RED);
		else snprintf(botsColor,sizeof(botsColor),"%s",WHITE);
		snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s   %s%s%sPatience: %s%d",i * 4 + 4,gselectedColor,BLACK,loading[gload],gselectedColor,botsColor,bots[i + 1].patience);
		myprintf(mystring);
	}

	hidScanInput();
	u32 kDown = hidKeysDown();
	u32 kHeld = hidKeysHeld();
	if (kHeld != oldKHeld) {
		oldKHeld = kHeld;
		lastHeld = svcGetSystemTick();
	}
	if (kDown & KEY_A) {
		if (specialSelection != gselected) {
			specialSelection = gselected;
		} else specialSelection = -1;
	}
	if (kDown & KEY_B) {
		if (specialSelection != -1) {
			specialSelection = -1;
		} else {
			popScene();
			return;
		}
	}
	if (kDown & KEY_DRIGHT || kDown & KEY_CPAD_RIGHT || ((kHeld & KEY_DRIGHT || kHeld & KEY_CPAD_RIGHT) && (svcGetSystemTick() - lastHeld > TICKS_PER_SEC / 2))) {
		if (gselected == 0) {
			numOpponents++;
			if (numOpponents >= numBots) numOpponents = 0;
			myconsoleClear();
		}
		if ((gselected - 2) % 4 == 0) {
			int s = (gselected - 2) / 4 + 1;
			if (bots[s].can_go_fast <= 98) bots[s].can_go_fast += 2;
		} 
		else if ((gselected - 3) % 4 == 0) {
			int s = (gselected - 3) / 4 + 1;
			if (bots[s].precision <= 98) bots[s].precision += 2;
		}
		else if ((gselected - 4) % 4 == 0) {
			int s = (gselected - 4) / 4 + 1;
			if (bots[s].patience <= 98) bots[s].patience += 2;
		} 
	}
	if (kDown & KEY_DLEFT || kDown & KEY_CPAD_LEFT || ((kHeld & KEY_DLEFT || kHeld & KEY_CPAD_LEFT) && (svcGetSystemTick() - lastHeld > TICKS_PER_SEC / 2))) {
		if (gselected == 0) {
			numOpponents--;
			if (numOpponents < 0) numOpponents = numBots - 1;
			myconsoleClear();
		}
		if ((gselected - 2) % 4 == 0) {
			int s = (gselected - 2) / 4 + 1;
			if (bots[s].can_go_fast >= 2) bots[s].can_go_fast -= 2;
		}
		else if ((gselected - 3) % 4 == 0) {
			int s = (gselected - 3) / 4 + 1;
			if (bots[s].precision >= 22) bots[s].precision -= 2;
		}
		else if ((gselected - 4) % 4 == 0) {
			int s = (gselected - 4) / 4 + 1;
			if (bots[s].patience >= 2) bots[s].patience -= 2;
		}
	}
	if (kDown & KEY_DUP || kDown & KEY_CPAD_UP || ((kHeld & KEY_DUP || kHeld & KEY_CPAD_UP) && (svcGetSystemTick() - lastHeld > TICKS_PER_SEC / 2))) {
		if (specialSelection == 0) {
			numOpponents++;
			if (numOpponents >= numBots) numOpponents = 0;
			myconsoleClear();
		}
		if (specialSelection != -1) {
			if ((gselected - 3) % 4 == 0) {
				int s = (gselected - 3) / 4 + 1;
				if (bots[s].precision <= 98) bots[s].precision += 2;
			}
			else if ((gselected - 4) % 4 == 0) {
				int s = (gselected - 4) / 4 + 1;
				if (bots[s].patience <= 98) bots[s].patience += 2;
			} 
		} else {
			gselected--;
			if ((gselected - 1) % 4 == 0) gselected--;
			if (gselected < 0) gselected = numOpponents * 4;
		}
	}
	if (kDown & KEY_DDOWN || kDown & KEY_CPAD_DOWN || ((kHeld & KEY_DDOWN || kHeld & KEY_CPAD_DOWN) && (svcGetSystemTick() - lastHeld > TICKS_PER_SEC / 2))) {
		if (specialSelection == 0) {
			numOpponents--;
			if (numOpponents < 0) numOpponents = numBots - 1;
			myconsoleClear();
		}
		if (specialSelection != -1) {
			if ((gselected - 3) % 4 == 0) {
				int s = (gselected - 3) / 4 + 1;
				if (bots[s].precision >= 22) bots[s].precision -= 2;
			}
			else if ((gselected - 4) % 4 == 0) {
				int s = (gselected - 4) / 4 + 1;
				if (bots[s].patience >= 2) bots[s].patience -= 2;
			} 
		} else {
			gselected++;
			if ((gselected - 1) % 4 == 0) gselected++;	
			if (gselected > numOpponents * 4) gselected = 0;
		}
	}
	if (kDown & KEY_START || kDown & KEY_SELECT) {
		popScene();
		return;
	}
}
void opponent_options_draw() {
	if (svcGetSystemTick() - glastLoad > TICKS_PER_MS * 30) { gload++; glastLoad = svcGetSystemTick(); }
	if (gload > 7) gload = 0;
	keepConsole();
}
void difficulty_menu_finish() {
	for (int i = 0; i < numOpponents; i++) {
		int s = i + 1;
		if (bots[s].difficulty == 0) {
			bots[s].precision = 50;
			bots[s].patience = 30;
			bots[s].can_go_fast = 30;
		} else if (bots[s].difficulty == 1) {
			bots[s].precision = 80;
			bots[s].patience = 30;
			bots[s].can_go_fast = 70;
		} else if (bots[s].difficulty == 2) {
			bots[s].precision = 90;
			bots[s].patience = 50;
			bots[s].can_go_fast = 90;
		} else if (bots[s].difficulty == 3) {
			bots[s].precision = 100;
			bots[s].patience = 100;
			bots[s].can_go_fast = 100;
		}
	}
	currentBots = numOpponents + 1;
}
void difficulty_menu_init() {
	myconsoleClear();
	snprintf(gselectedColor,sizeof(gselectedColor)," ");
	snprintf(botsColor,sizeof(botsColor),"%s",WHITE);
	specialSelection = -1;
	gselected = 0;
	gload = 0;
	glastLoad = svcGetSystemTick();
}
void difficulty_menu_update() {
	char leftBracket[2];
	char rightBracket[2];
	if (gselected == 0) {
		snprintf(gselectedColor,sizeof(gselectedColor),"%s",YELLOW);
	}
	else {
		snprintf(gselectedColor,sizeof(gselectedColor),"%s",WHITE);
	}
	if (specialSelection == 0) { 
		snprintf(leftBracket,sizeof(leftBracket),"[");
		snprintf(rightBracket,sizeof(rightBracket),"]");
		snprintf(botsColor,sizeof(botsColor),"%s",RED); 
	}
	else { 
		memset(leftBracket,0,sizeof(leftBracket));
		memset(rightBracket,0,sizeof(rightBracket));
		snprintf(botsColor,sizeof(botsColor),"%s",WHITE); 
	}
	snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sNumber of Bots: %s%d",gselectedColor,botsColor,numOpponents);
	myprintf(mystring);
	char easy[10];
	char medium[10];
	char hard[10];
	char insane[10];
	for (int i = 0; i < numOpponents; i++) {
		//Bot #
		if (gselected == i + 1) snprintf(gselectedColor,sizeof(gselectedColor),"%s",YELLOW);
		else snprintf(gselectedColor,sizeof(gselectedColor),"%s",WHITE);
		if (specialSelection == i + 1) {
			snprintf(gselectedColor,sizeof(gselectedColor),"!.r");
		} 
		snprintf(easy,sizeof(easy),"!.zEASY");
		snprintf(medium,sizeof(medium),"!.zMEDIUM");
		snprintf(hard,sizeof(hard),"!.zHARD");
		snprintf(insane,sizeof(insane),"!.zINSANE");
		if (bots[i + 1].difficulty == 0) {
			snprintf(easy,sizeof(easy),"!.gEASY");
		} else if (bots[i + 1].difficulty == 1) {
			snprintf(medium,sizeof(medium),"!.yMEDIUM");
		} else if (bots[i + 1].difficulty == 2) {
			snprintf(hard,sizeof(hard),"!.rHARD");
		} else if (bots[i + 1].difficulty == 3) {
			snprintf(insane,sizeof(insane),"!.uINSANE");
		}
		snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%sBot %s%c: %s %s %s %s",i + 2,gselectedColor,darkColors[i + 1],('A' + i),easy,medium,hard,insane);
		myprintf(mystring);
	}

	hidScanInput();
	u32 kDown = hidKeysDown();
	u32 kHeld = hidKeysHeld();
	if ((kHeld & KEY_L && kDown & KEY_R) || (kHeld & KEY_R && kDown & KEY_L)) {
		popScene(); //hidden menu for modifying individual values of the AI opponents
		pushScene(opponent_options_init,opponent_options_update,opponent_options_draw,opponent_options_finish);
	}
	if (kHeld != oldKHeld) {
		oldKHeld = kHeld;
		lastHeld = svcGetSystemTick();
	}
	if (kDown & KEY_A) {
		if (specialSelection != gselected) {
			specialSelection = gselected;
		} else specialSelection = -1;
	}
	if (kDown & KEY_B) {
		if (specialSelection != -1) {
			specialSelection = -1;
		} else {
			popScene();
			return;
		}
	}
	if (kDown & KEY_DRIGHT || kDown & KEY_CPAD_RIGHT || ((kHeld & KEY_DRIGHT || kHeld & KEY_CPAD_RIGHT) && (svcGetSystemTick() - lastHeld > TICKS_PER_SEC / 2))) {
		if (gselected == 0) {
			numOpponents++;
			if (numOpponents >= numBots) numOpponents = 1;
			myconsoleClear();
		}
		else {
			int s = gselected;
			bots[s].difficulty++;
			if (bots[s].difficulty > 3) bots[s].difficulty = 0;
		} 
	}
	if (kDown & KEY_DLEFT || kDown & KEY_CPAD_LEFT || ((kHeld & KEY_DLEFT || kHeld & KEY_CPAD_LEFT) && (svcGetSystemTick() - lastHeld > TICKS_PER_SEC / 2))) {
		if (gselected == 0) {
			numOpponents--;
			if (numOpponents < 1) numOpponents = numBots - 1;
			myconsoleClear();
		}
		else {
			int s = gselected;
			bots[s].difficulty--;
			if (bots[s].difficulty < 0) bots[s].difficulty = 3;
		}
	}
	if (kDown & KEY_DUP || kDown & KEY_CPAD_UP || ((kHeld & KEY_DUP || kHeld & KEY_CPAD_UP) && (svcGetSystemTick() - lastHeld > TICKS_PER_SEC / 2))) {
		if (specialSelection == 0) {
			numOpponents++;
			if (numOpponents >= numBots) numOpponents = 1;
			myconsoleClear();
		}
		if (specialSelection != -1) {
			int s = specialSelection;
			bots[s].difficulty++;
			if (bots[s].difficulty > 3) bots[s].difficulty = 0;
		} else {
			gselected--;
			if (gselected < 0) gselected = numOpponents + 1;
		}
	}
	if (kDown & KEY_DDOWN || kDown & KEY_CPAD_DOWN || ((kHeld & KEY_DDOWN || kHeld & KEY_CPAD_DOWN) && (svcGetSystemTick() - lastHeld > TICKS_PER_SEC / 2))) {
		if (specialSelection == 0) {
			numOpponents--;
			if (numOpponents < 1) numOpponents = numBots - 1;
			myconsoleClear();
		}
		if (specialSelection != -1) {
			int s = specialSelection;
			bots[s].difficulty--;
			if (bots[s].difficulty < 0) bots[s].difficulty = 3;
		} else {
			gselected++;
			if (gselected > numOpponents + 1) gselected = 0;
		}
	}
	if (kDown & KEY_START || kDown & KEY_SELECT) {
		popScene();
		return;
	}
}
void difficulty_menu_draw() {
	if (svcGetSystemTick() - glastLoad > TICKS_PER_MS * 30) { gload++; glastLoad = svcGetSystemTick(); }
	if (gload > 7) gload = 0;
	keepConsole();
}
void opponent_options_finish() {
	currentBots = numOpponents + 1;
}
void gameOptions_init() { 
	myconsoleClear();
	gselected = 0;
	gload = 0;
	glastLoad = svcGetSystemTick();
	snprintf(gselectedColor,sizeof(gselectedColor),"%s",YELLOW);
}
void gameOptions() {
	keepConsole();
	for (int i = 0; i < numOptions; i++) {
		if (options[i]) snprintf(gonOrOff,sizeof(gonOrOff),RAINBOW);
		else snprintf(gonOrOff,sizeof(gonOrOff),BLACK);
		if (gselected == i) snprintf(gselectedColor,sizeof(gselectedColor),YELLOW);
		else snprintf(gselectedColor,sizeof(gselectedColor),WHITE);
		snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s%s%s",i,gonOrOff,loading[gload],gselectedColor,optionNames[i],WHITE);
		myprintf(mystring);
	}
	if (svcGetSystemTick() - glastLoad > TICKS_PER_MS * 30) { gload++; glastLoad = svcGetSystemTick(); }
	if (gload > 7) gload = 0;
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_DUP || kDown & KEY_CPAD_UP) gselected--;
	else if (kDown & KEY_DDOWN || kDown & KEY_CPAD_DOWN) gselected++;
	if (gselected >= numOptions) gselected = 0;
	else if (gselected < 0) gselected = numOptions - 1;
	if (kDown & KEY_A) {
		if (options[gselected]) options[gselected] = false;
		else options[gselected] = true;
	}
	if (kDown & KEY_START || kDown & KEY_SELECT || kDown & KEY_B) { popScene(); return; }
}
//---------------------------------------------------------------------------------
static void moveSprites() {
//---------------------------------------------------------------------------------
	int i;
	for(i = 0; i < numPlayers(); i++) {
		if (sprites[i].dead || !timeDiff(i)) continue;
		int times = (int)timeDiff(i);
		if (times > 50) {
			times = 50;
		}
		for (; times > 0 && !sprites[i].dead; times--) {
			frameTicks[i] = svcGetSystemTick();
			int oldxdx = sprites[i].dx;
			int oldydy = sprites[i].dy;
			int bc = toBot(i);
			if ((i > 0 && i != myNum && i < currentBots) || (autoPilot && i == myNum)) {
				if (totalPathN[bc] < 2 && plotting[bc]) {
					showPlotMovement(bc, false);
				}
				if (totalPathN[bc] > 0) {
					totalPathN[bc]--;
					while (totalPath[bc][totalPathN[bc]].x == 0 && totalPath[bc][totalPathN[bc]].y == 0 && totalPathN[bc] > 0) {
						totalPathN[bc]--;
					}
					if (totalPathN[bc] == 0) {
						showPlotMovement(bc,false); 
						totalPathN[bc]--;
					} 
					int myx = totalPath[bc][totalPathN[bc]].x - sprites[i].x + bots[bc].fudge_x;
					int myy = totalPath[bc][totalPathN[bc]].y - sprites[i].y + bots[bc].fudge_y;
					if (myx == 0 && myy == 0) {
						totalPathN[bc]--;
						myx = totalPath[bc][totalPathN[bc]].x - sprites[i].x + bots[bc].fudge_x;
						myy = totalPath[bc][totalPathN[bc]].y - sprites[i].y + bots[bc].fudge_y;
					}
					if (myx == 0 || myy == 0) {
						if (myx == 2) {
							sprites[i].dy = 0;
							sprites[i].dx = bikeSpeed;
						} else if (myx == -2) { sprites[i].dy = 0; sprites[i].dx = -1 * bikeSpeed; }
						else if (myy == 2) { sprites[i].dx = 0; sprites[i].dy = bikeSpeed; }
						else if (myy == -2) { sprites[i].dx = 0; sprites[i].dy = -1 * bikeSpeed; }
					}
					else {
						if (abs(myx) != 2 && abs(myy) != 2) { 
							//sprites[i].speed = 90;
							if (abs(myx) >= 390) {
								sprites[i].dy = 0;
								if (sprites[i].x  <= 2) sprites[i].dx = bikeSpeed * -1;
								else if (sprites[i].x  >= 398) sprites[i].dx = bikeSpeed;
							} else if (abs(myy) >= 230) {
								if (sprites[i].y  <= 2) sprites[i].dy = bikeSpeed * -1;
								else if (sprites[i].y  >= 237) sprites[i].dy = bikeSpeed;
							} else {
								//snprintf(mystring,sizeof(mystring),"myx: %d myy: %d",myx,myy);
								//myprintf(mystring);
								//if (everyoneElseIsDead(bc)) useSpecialIfICan(bc);
								//showCameFrom(bc);
								totalPathN[bc] = 0;
								plotting[bc] = false;
							}
						}
					}
				}
				/*if (sprites[i].dy == oldydy * -1 || sprites[i].dx == oldxdx * -1) {
					sprites[i].dy = oldydy;
					sprites[i].dx = oldxdx;
				}*/
				if (oldxdx != sprites[i].dx || oldydy != sprites[i].dy) {
					if (sprites[i].speed == BIKE_FAST && (bots[bc].can_go_fast < 91 || getHighestScore() == i)) {
						bots[bc].last_speed_change = svcGetSystemTick();
						sprites[i].speed = BIKE_NORMAL;
					}
					if (oldxdx == sprites[i].dx * -1 && oldydy == sprites[i].dy * -1) {
						totalPathN[bc] = 0;
						plotting[bc] = 0;
						sprites[i].dx = oldxdx;
						sprites[i].dy = oldydy;
					}
					else if (abs(bots[bc].fudge_x) + abs(bots[bc].fudge_y) <= 4) {
						float mult = 1.0f;
						if (sprites[i].speed == BIKE_SLOW) mult += 0.1f;
						if (bots[bc].fudge_factor > 2 && rand() % 100 > bots[bc].precision * mult) {
							bots[bc].fudge_x += oldxdx - sprites[i].dx;
							bots[bc].fudge_y += oldydy - sprites[i].dy;
							sprites[i].dx = oldxdx;
							sprites[i].dy = oldydy;
							/*snprintf(mystring,sizeof(mystring),"woops... (%d %d)",bots[bc].fudge_x,bots[bc].fudge_y);
							myprintf(mystring);*/
						} 
					} else if (bots[bc].fudge_factor > 6) {
						bots[bc].fudge_x = 0;
						bots[bc].fudge_y = 0;
						bots[bc].fudge_factor = 0;
						showPlotMovement(bc,false);
					}
					else bots[bc].fudge_factor += 2;
				}
			}
			if (options[10] && (i == myNum || (i < currentBots && actual_bikes == 1)) && rand() % 40 < 3) {
				sprites[i].hole = (rand() % 3) + 1;
				hole = sprites[i].hole;
				if (i == myNum) {
					msg.sprite = sprites[i];
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
			}
			else if (sprites[i].hole > 0) {
				sprites[i].hole--;
			}
			if (cheats && !autoPilot) {
				int ox = sprites[myNum].x + sprites[myNum].dx;
				int oy = sprites[myNum].y + sprites[myNum].dy;
				if (ox >= 400) ox = 0;
				else if (ox < 0) ox = 396;
				if (oy >= 240) oy = 0;
				else if (oy < 0) oy = 236;
				if (getColor(ox,oy) != colors[8] && getColor(ox,oy)) {
					if (sprites[myNum].dx > 0) nextMove = MOVE_RIGHT;
					else if(sprites[myNum].dx < 0) nextMove = MOVE_LEFT;
					else if (sprites[myNum].dy > 0) nextMove = MOVE_DOWN;
					else if (sprites[myNum].dy < 0) nextMove = MOVE_UP;
					ox = sprites[myNum].x;
					oy = sprites[myNum].y;
					int x = ox;
					int y = oy;
					x += 2;
					if (x > 398) x = 0;
					if (!sprites[myNum].dx && getColor(x,y) == 0) {
						sprites[myNum].diag = 0;
						sprites[myNum].dx = 2;
						sprites[myNum].dy = 0;
						lastSprite = svcGetSystemTick();
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						msg.sprite = sprites[myNum];
						UDSSend(msg);
					} 
					x = ox;
					y += 2;
					if (y > 238) y = 0;
					if (!sprites[myNum].dy && getColor(x,y) == 0) {
						sprites[myNum].diag = 0;
						sprites[myNum].dx = 0;
						sprites[myNum].dy = 2;
						lastSprite = svcGetSystemTick();
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						msg.sprite = sprites[myNum];
						UDSSend(msg);
					}
					y = oy;
					x -= 2;
					if (x < 0) x = 396;
					if (!sprites[myNum].dx && getColor(x,y) == 0) {
						sprites[myNum].diag = 0;
						sprites[myNum].dx = -1 * 2;
						sprites[myNum].dy = 0;
						lastSprite = svcGetSystemTick();
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						msg.sprite = sprites[myNum];
						UDSSend(msg);
					}
					x = ox;
					y -= 2;
					if (y < 0) y = 236;
					if (!sprites[myNum].dy && getColor(x,y) == 0) {
						sprites[myNum].diag = 0;
						sprites[myNum].dx = 0;
						sprites[myNum].dy = -1 * 2;
						lastSprite = svcGetSystemTick();
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						msg.sprite = sprites[myNum];
						UDSSend(msg);
					}
				}
			}
			if (i != myNum && sprites[i].diag && !autoPilot) { //auto diagonals for cpad
				if (sprites[i].diag == NORTHEAST) {
					if (sprites[i].dx) {
						sprites[i].dy = sprites[i].dx * -1;
						sprites[i].dx = 0;
					} else {
						sprites[i].dx = sprites[i].dy * -1;
						sprites[i].dy = 0;
					}
				} else if (sprites[i].diag == SOUTHEAST) {
					if (sprites[i].dx) {
						sprites[i].dy = sprites[i].dx;
						sprites[i].dx = 0;
					} else {
						sprites[i].dx = sprites[i].dy;
						sprites[i].dy = 0;
					}
				} else if (sprites[i].diag == SOUTHWEST) {
					if (sprites[i].dx) {
						sprites[i].dy = sprites[i].dx * -1;
						sprites[i].dx = 0;
					} else {
						sprites[i].dx = sprites[i].dy * -1;
						sprites[i].dy = 0;
					}
				} else if (sprites[i].diag == NORTHWEST) {
					if (sprites[i].dx) {
						sprites[i].dy = sprites[i].dx;
						sprites[i].dx = 0;
					} else {
						sprites[i].dx = sprites[i].dy;
						sprites[i].dy = 0;
					}
				}
			}
			fixCameFroms(i);

			if (bc < currentBots && bc > 0) {
				bots[bc].fudge_factor++;
			}
			sprites[i].x += sprites[i].dx;
			sprites[i].y += sprites[i].dy;
			
			if (autoPilot) {
				if (oldBotSpeed != sprites[myNum].speed || sprites[myNum].dy != oldydy || sprites[myNum].dx != oldxdx) {
					oldBotSpeed = sprites[myNum].speed;
					msg.sprite = sprites[myNum];
					lastSprite = svcGetSystemTick();
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					UDSSend(msg);
				}
			}
			//if (sprites[i].x  != totalPath[totalPathN].x && sprites[i].y  != totalPath[totalPathN].y) totalPathN--;
			/*bool deadflag = false;
			for (int i = 0; i < actual_bikes; i++) {
				if (i != myNum && !sprites[i].dead && sprites[i].x + (sprites[i].dx ) == sprites[myNum].x && sprites[i].y + (sprites[i].dy ) == sprites[myNum].y) {
					deadflag = true;
					break;
				}
			}
			if (deadflag) {
				sprites[myNum].dead = true;
				msg.sprite = sprites[myNum];
				memset(replySprite,0,sizeof(replySprite[0]) * 10);
				lastSprite = svcGetSystemTick();
				UDSSend(msg);
			}*/
			if(sprites[i].x < 2) sprites[i].x = 396; //screen wrap
			else if (sprites[i].x > (396 )) sprites[i].x = 2;

			if(sprites[i].y < 2) sprites[i].y = 236; //screen wrap
			else if (sprites[i].y > (236 )) sprites[i].y = 2;

			/*while (getLength(i) > sprites[i].length) { //fix length: erase
				drawSprite(path[pathPos[i]][i].x , path[pathPos[i]][i].y , 2, 2, 9);
				pathPos[i]++;
			}*/
			if (growth[i]) growth[i]--;
			else if (getLength(i) >= sprites[i].length) { //move tail
				overwriteSprite(path[pathPos[i]][i].x , path[pathPos[i]][i].y , 2, 2, 9);
				pathPos[i]++;
				if (pathPos[i] >= 200 * 120) pathPos[i] = 0;
			}
			overwriteSprite(path[pathPos[i]][i].x, path[pathPos[i]][i].y, 2, 2, 9);
			currentPath[i]++;
			if (pathPos[i] >= 200 * 120) pathPos[i] = 0;
			if (currentPath[i] >= 200 * 120) currentPath[i] = 0;
			path[currentPath[i]][i].x = sprites[i].x;
			path[currentPath[i]][i].y = sprites[i].y;
			overwriteSprite(sprites[i].x,sprites[i].y,2,2,i);
			if (((i > 0 && i < currentBots) || i == myNum) && !sprites[i].dead) { //check my snake getting apple and collisions
				u32 color1 = getColor(sprites[i].x , sprites[i].y );
				u32 color2 = getColor(sprites[i].x + 1, sprites[i].y + 1);
				if (abs(sprites[i].x - (apple.x )) <= 2 && abs(sprites[i].y - (apple.y )) <= 2) {
					if (svcGetSystemTick() - lastApple > TICKS_PER_MS * 15 * 6 * lagMult()) {
						lastApple = svcGetSystemTick();
						score[i]++;
						if (options[8]) {
							growth[i] += sprites[i].length;
							sprites[i].length *= 2;
						}
						else {
							growth[i] += growthRate;
							sprites[i].length += growthRate;
						}
						if (sprites[i].length >= 120 * 200) sprites[i].length = 120 * 200 - 1;
						if (i == myNum) {
							memset(replyScore,0,sizeof(replyScore[0]) * 10);
							flash = svcGetSystemTick();
							moveApple();
						}
						else { 
							changeApple(); 
							for (int b = 0; b < numBots; b++) {
								usedSpecial[b] = false;
							}
			 			}
						if ((i < currentBots) || (i == myNum && autoPilot)) { plotting[bc] = false; totalPathN[bc] = 0; }
						if (debugging) myprintf("Got apple.");
						overwriteSprite(sprites[i].x,sprites[i].y,2,2,i);
						//ignoreDeath = true;
					}
				}
				else if (getLength(i) < 10) {} //don't die if game just started
				else if ((color1 != colors[8] && color2 != colors[8]) && (color1 > 0 || color2 > 0) && !ignoreDeath) {
					dead = color1;
					dead2 = color2;
					/*snprintf(mystring,sizeof(mystring),"dx: %d dy: %d",sprites[i].dx,sprites[i].dy);
					myprintf(mystring);
					snprintf(mystring,sizeof(mystring),"death: %" PRIu32,color1);
					myprintf(mystring);
					snprintf(mystring,sizeof(mystring),"death2: %" PRIu32,color2);
					myprintf(mystring);*/

					overwriteSprite(sprites[i].x + 1,sprites[i].y,1,1,6);
					overwriteSprite(sprites[i].x,sprites[i].y + 1,1,1,6);
					lastDead = i;
					sprites[i].dead = true;
					if (i == myNum) {
						msg.sprite = sprites[i];
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						lastSprite = svcGetSystemTick();
						UDSSend(msg); //dead
					}
					if (options[9]) { 
						eraseLine(i); 
						for (int b = 0; b < currentBots; b++) {
							if (!sprites[b].dead) { //a snake died and disappeared, so the bots need to rescan the area.
								totalPathN[b] = 0;
								plotting[b] = false;
							}
						}
					}
				}
				else { overwriteSprite(sprites[i].x , sprites[i].y , 2, 2, i); ignoreDeath = false; }
			}
		}
	}
}

static void drawWall(int img) {
	drawSprite(2,2,2,236,img);
	drawSprite(2,2,394,2,img);
	drawSprite(396,2,2,236,img);
	drawSprite(2,236,396,2,img);
}
static void drawPoint(int img) {
	drawSprite(0,0,2,239,img);
	drawSprite(0,0,399,2,img);
	drawSprite(398,0,2,238,img);
	drawSprite(0,238,399,2,img);
}
//---------------------------------------------------------------------------------
static void sceneRender(void) {
//---------------------------------------------------------------------------------
	int i;
	// Update the uniforms
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);

	if (flash != 0) {
		if (svcGetSystemTick() - flash < TICKS_PER_MS * 30 * 7) drawPoint(8);
		else { flash = 0; drawPoint(9); }
		if (options[0]) drawWall(7);
	}
	if (!options[7] && getColor(apple.x , apple.y ) == 0) drawSprite(apple.x , apple.y , 2, 2, 8);
	for(i = 0; i < numPlayers(); i++) {
		if (i < numPlayers()) { 
			if (!sprites[i].dead) drawSprite( sprites[i].x , sprites[i].y , 2, 2, getImg(i));
			if ((path[currentPath[i]][i].x ) != sprites[i].x || (path[currentPath[i]][i].y ) != sprites[i].y) {
				currentPath[i]++;
				path[currentPath[i]][i].x = sprites[i].x;
				path[currentPath[i]][i].y = sprites[i].y;
			}
		}
		int x = path[pathPos[i]][i].x;
		int y = path[pathPos[i]][i].y;
		for (int b = 0; b < currentBots; b++) {
			if (!inOpenSet(x,y,b)) {
				for (int k = 4; k < 8; k++) {
					int nx = getDirectionXTo(k,x,b);
					int ny = getDirectionYTo(k,y,b);
					if (!getColor(nx,ny) && cameFrom[b][nx][ny].x && cameFrom[b][nx][ny].y) {
						addOpenSet(x,y,b);
						cameFrom[b][x][y].x = nx;
						cameFrom[b][x][y].y = ny;
						break;
					}
				}
			}
		}
		drawSprite(path[pathPos[i]][i].x , path[pathPos[i]][i].y , 2, 2, 9);
	}

}
//---------------------------------------------------------------------------------
static void sceneExit(void) {
//---------------------------------------------------------------------------------

	// Free the shader program
	free(glyphSheets);
	shaderProgramFree(&program);
	DVLB_Free(vshader_dvlb);
	//shaderProgramFree(&textprogram);
	//DVLB_Free(textshader_dvlb);
}
static SwkbdCallbackResult wrongName(void* user, const char** ppMessage, const char* text, size_t textlen)
{

	if(strstr(text,"\x1b["))
	{
		*ppMessage = "Nope.";
		return SWKBD_CALLBACK_CONTINUE;
	}
	if(strstr(text, "!."))
	{
		*ppMessage = "Nice try.";
		return SWKBD_CALLBACK_CONTINUE;
	}
	if (strstr(text, "host"))
	{
		*ppMessage = "Just no.";
		return SWKBD_CALLBACK_CONTINUE;
	}

	return SWKBD_CALLBACK_OK;
}
void setHighscore(u32 score) {
	highScore = score;
	snprintf(mystring,sizeof(mystring),"%sNew High Score: %" PRIu32,RAINBOW,highScore);
	myprintf(mystring);
	msg.sprite = sprites[myNum];
	msg.sprite.speed = 3030;
	msg.sprite.dx = highScore;
	lastHighscore = svcGetSystemTick();
	memset(replyHighscore,0,sizeof(replyHighscore[0]) * 10);
	UDSSend(msg);
	writeUsername();
}
void send_quit_init() {
	sprites[myNum].node = myNode;
	memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
	snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
	sprites[myNum].image = myNode;
	sprites[myNum].node = myNode;
	msg.sprite = sprites[myNum];
	msg.sprite.speed = 999; 
	lastSprite = svcGetSystemTick(); 
	UDSSend(msg);
	memset(replySprite,0,sizeof(replySprite[0]) * 10);
	if (debugging) myprintf("Sending quit message...");
}
void send_quit_update() {
	keepConsole();
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_START) {
		if (debugging) myprintf("...you stopped?");
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
	if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
		sprites[myNum].node = myNode;
		memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
		snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
		sprites[myNum].image = myNode;
		sprites[myNum].node = myNode;
		msg.sprite = sprites[myNum]; 
		msg.sprite.speed = 999;
		lastSprite = svcGetSystemTick();
		UDSSend(msg);
	}
	memset(tmpbuf, 0, tmpbuf_size);
	actual_size = 0;
	src_NetworkNodeID = 0;
	if (uds_enabled) {
		ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
		if(R_FAILED(ret))
		{
			clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.You failed to leave the game. Press start.", (unsigned int)ret);
			myprintf(mystring);
			replay = false;
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			return;
		}
		if(actual_size >= sizeof(msg))//If no data frame is available, udsPullPacket() will return actual_size=0.
		{
			memcpy(&msg,tmpbuf,sizeof(msg));
			if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"image: %d sender: %d node: %d speed: %d", msg.sprite.image, msg.sender, msg.sprite.node, msg.sprite.speed); myprintf(mystring); }
			if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.timestamp == lastSprite) { if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"%d leaving: %d",myNode,msg.sprite.node); myprintf(mystring); } replySprite[msg.sprite.node] = true; }
			int responded = 0;
			for (int i = 0; i <= NUM_SPRITES; i++) {
				if (i != myNode && replySprite[i]) responded++;
			}
			if (responded >= num_bikes - 1) {
				popScene();
				return;
			}
		}
	}
}
void send_quit_finish() {
	disconnectNetwork();
	myNum = 0;
	was_in_game = false;
	networks = NULL;
	network = NULL;
}
void start_screen_init()
{ 
	keepConsole();
	if (was_in_game) {
		currentBots = numOpponents + 1;
		if (myNum) {
			pushScene(send_quit_init,send_quit_update,NULL,send_quit_finish);
			return;
		}
		disconnectNetwork();
		was_in_game = false;
		networks = NULL;
		network = NULL;
	}
	num_bikes = 1;
	actual_bikes = 1;
	ret = 0;
	memset(overwriteName,0,sizeof(overwriteName));
	ret=0;
	con_type=0;


	for (int i = 0; i < NUM_SPRITES; i++) {
		memset(sprites[i].username,0,sizeof(sprites[i].username));
	}
	total_networks = 0;


	conntype = UDSCONTYPE_Client;

	//u32 tmp=0;




	//myprintf("Successfully initialized.");

	hosting = 0;
	readyToJoin = 0;

	//gspWaitForVBlank();
	//snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sg %sy %sb %sm %sc %sdg %so %sp",GREEN, YELLOW, BLUE, MAGENTA, CYAN, DARKGREEN, ORANGE, PINK);
	//myprintf(mystring);
	clearString();
	myconsoleClear();
	//snprintf(mystring,sizeof(mystring),"%d",patchConsole);
	//myprintf(mystring);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
	gfxFlushBuffers();
	gfxSwapBuffers();
	snprintf(mystring,sizeof(mystring),"Version %s",VERSION);
	myprintf(mystring);
	myprintf("\x1b[2;0HHold  to host"); myprintf("Press  to scan for a host."); myprintf("Press  to change name."); myprintf("Press + to reset high score."); myprintf("Press SELECT for options."); myprintf("Press START to exit."); myprintf(" ");
	importUsername();
}
void start_screen_draw() {
	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
		C3D_FrameDrawOn(target);
		if (qrcode) C3D_TexBind(0, &qrcode_tex);
		else C3D_TexBind(0, &spritesheet_tex);
		//if (kDown & KEY_L || kHeld & KEY_L) writeColor(10,10,HSL2RGB(rainbow,0.5,0.5));
		C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
		if (qrcode) drawSprite(72,0,240,240,11);
		else drawSprite(72,0,256,256,10);
	C3D_FrameEnd(0);

	keepConsole();
}
void scan_init() { 
	myprintf("Scanning...");
}
void scan_update() {
	//gspWaitForVBlank();
	hidScanInput();

	total_networks = 0;
	keepConsole();
	u32 kHeld = hidKeysHeld();
	if (!(kHeld & KEY_B)) { popScene(); return; }
	memset(beacon_msg, 0, beacon_size);
	ret = udsScanBeacons(beacon_msg, beacon_size, &networks, &total_networks, wlancommID, 0, NULL, false);
	keepConsole();
	if(total_networks) { network = &networks[0]; readyToJoin = 1; myprintf("finishing..."); popScene(); pushScene(NULL,scan_finish,NULL,NULL); }
}
void choose_network_init() { 
	selected = 0;
	myconsoleClear();
	myprintf("Please choost a host by 3ds name:");
}
void choose_network_update() {
	network = &networks[0];
	keepConsole();
	if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"network: total nodes = %u.", (unsigned int)network->network.total_nodes); myprintf(mystring); }


	for(u32 pos=0; pos<total_networks; pos++)
	{
		network = &networks[pos];
		if(!udsCheckNodeInfoInitialized(&network->nodes[0])) continue;
		if (network->network.total_nodes >= 8) continue;
		memset(tmpstr, 0, sizeof(tmpstr));

		ret = udsGetNodeInfoUsername(&network->nodes[0], tmpstr);
		if(R_FAILED(ret))
		{
			clearString(); snprintf(mystring,sizeof(mystring),"udsGetNodeInfoUsername() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			free(networks);
			return;
		}

		if (pos == selected) { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s", (unsigned int)(pos + 1), YELLOW, tmpstr, WHITE); myprintf(mystring); }
		else { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s",(unsigned int)(pos + 1),tmpstr); myprintf(mystring); }
	}
	hidScanInput();
	u32 kDown = hidKeysDown();
	if ((kDown & KEY_DUP) || (kDown & KEY_CPAD_UP)) selected--;
	if ((kDown & KEY_DDOWN) || (kDown & KEY_CPAD_DOWN)) selected++;
	if (kDown & KEY_A) { readyToJoin = true; network = &networks[selected]; total_networks = 1; popScene(); pushScene(NULL,connect_update,NULL,NULL); return; }
	if (selected < 0 || selected >= total_networks) selected = 0;
}
void send_request_init() { 
	currentBots = 1;
	myNum = constatus.total_nodes - 1;
	num_bikes = constatus.total_nodes;

	setSprites();
	if (debugging) {
		snprintf(mystring,sizeof(mystring),"Sending request to join... (%d %d)",myNum,myNode);
		myprintf(mystring);
	}
	sprites[myNum].speed = 1111;
	sprites[myNum].node = myNode;
	snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
	msg.sprite = sprites[myNum];
	msg.sprite.speed = 1111;
	UDSSend(msg);
	memset(replySprite,0,sizeof(replySprite[0]) * 10);
	lastSprite = svcGetSystemTick();
}
void send_request_update() {
	keepConsole();
	hidScanInput();
	if (hidKeysDown() & KEY_START) { myprintf("ENDING..."); pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish); return; }
	if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
		if (debugging) myprintf("Resending request...");
		memset(replySprite,0,sizeof(replySprite[0]) * 10);
		sprites[myNum].node = myNode;
		msg.sprite = sprites[myNum]; 
		msg.sprite.speed = 1111; 
		lastSprite = svcGetSystemTick();
		UDSSend(msg);
	}
	memset(tmpbuf, 0, tmpbuf_size);
	actual_size = 0;
	src_NetworkNodeID = 0;
	if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
	if(R_FAILED(ret))
	{
		clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
		myprintf(mystring);
		replay = false;
		popScene();
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
	if(actual_size >= sizeof(msg))//If no data frame is available, udsPullPacket() will return actual_size=0.
	{
		memcpy(&msg,tmpbuf,sizeof(msg));
		if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"speed: %d image: %d myNum: %d",msg.sprite.speed, msg.sprite.image, myNum); myprintf(mystring); }
		if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; sprites[myNum] = msg.sprite; sprites[myNum].node = myNode; msg.sprite = sprites[myNum]; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; memset(replySprite,0,sizeof(replySprite[0]) * 10); popScene(); pushScene(roundEnd_init,roundEnd_update,NULL,NULL); return; } //joined game in score screen
		else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].dead = true; sprites[myNum].node = myNode; sprites[myNum].speed = BIKE_NORMAL; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); popScene(); pushScene(setup_init,setup_update,NULL,NULL); return; } // joined game in progress
		else if(msg.sprite.speed == 1211 && msg.sprite.image == myNum) { popScene(); pushScene(setup_init, setup_update,NULL,NULL); }
	}
}
void player_crashed_init() { 
	numLeft++;
	clearString(); snprintf(mystring,sizeof(mystring),"A player has crashed...");
	myprintf(mystring);
	errorQuit = svcGetSystemTick();
}
void player_crashed_update() {
	keepConsole();
	gfxFlushBuffers();
	gfxSwapBuffers();
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_START) {
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
	if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 4) {
		numLeft++;
		if (numLeft >= 15) { myconsoleClear(); numLeft = 0; }
		clearString(); snprintf(mystring,sizeof(mystring),"%sError: unknown person left. Removing a color...%s",RED,WHITE);
		myprintf(mystring);
		num_bikes = constatus.total_nodes;
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replySprite,1,sizeof(replySprite[0]) * 10);
		if (myNum >= num_bikes) {
			currentBots = 1;
			myNum = num_bikes - 1;
			clearString(); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE);
			myprintf(mystring);
		}
		errorQuit = 0;
		popScene();
		return;
	}
	memset(tmpbuf, 0, tmpbuf_size);
	actual_size = 0;
	src_NetworkNodeID = 0;
	if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
	if(R_FAILED(ret))
	{
		clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
		myprintf(mystring);
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		replay = false;
		return;
	}
	if(actual_size >= sizeof(msg))//If no data frame is available, udsPullPacket() will return actual_size=0.
	{

		memcpy(&msg,tmpbuf,sizeof(msg));
		if (msg.sprite.speed == 999 && msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
			joinedNum = 0;
			for (int i = 0; i < num_bikes; i++) {
				if (sprites[i].node == msg.sprite.node) { quit = i; popScene(); return; }
			}
			if (quit < 0) {
				pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
				popScene();
				return;
			}
			memset(quitName,0,sizeof(quitName));
			snprintf(quitName,sizeof(quitName),"%s",msg.sprite.username);
			msg.sprite.image = msg.sprite.node;
			msg.sprite.node = myNode;
			UDSDirect(msg.sprite.image,msg);
			oldQuit = quit;
			numLeft++;
			if (numLeft + num_bikes - quit >= 15) { myconsoleClear(); numLeft = 0; }
			clearString(); snprintf(mystring,sizeof(mystring),"%s%s has left the game.%s",textColors[quit],quitName,WHITE);
			myprintf(mystring);
			if (quit > 0 && quit < num_bikes - 1) {
				if (quit < myNum) myNum--;
				for (int i = quit; i < num_bikes - 1; i++) {
					numLeft++;
					if (i == myNum) { clearString(); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE); }
					else { clearString(); snprintf(mystring,sizeof(mystring),"  %s%s%s is now %s%s%s!", textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE); }
					myprintf(mystring);
					sprites[i] = sprites[i+1];
					sprites[i].image = i;
				}
			}
			num_bikes = constatus.total_nodes;
			memset(replyChange,1,sizeof(replyChange[0]) * 10);
			memset(replySprite,1,sizeof(replySprite[0]) * 10);
			quit = -1;
			oldQuit = -1;
			popScene();
			return;
		}
	}
}
void player_crashed_finish() {
	num_bikes = constatus.total_nodes;
	memset(replyScore,0,sizeof(replyScore[0]) * 10);
	memset(replyChange,1,sizeof(replyChange[0]) * 10);
}
void endRoundGameOptions_Finish() {
	ignoreB = true;
	myconsoleClear(); 
	msg.sprite = sprites[myNum];
	msg.sprite.speed = 2020;
	msg.sprite.dx = optionsToInt();
	lastDeadmsg = svcGetSystemTick();
	memset(replyDead,0,sizeof(replyDead[0]) * 10);
	UDSSend(msg);
}
void send_bike_init() {
	ret = 0;
	if (debugging) myprintf("Sending bike information");
	redo = true;
	lastSprite = svcGetSystemTick();
	lastChange = svcGetSystemTick();
	memset(replySprite,0,sizeof(replySprite[0]) * 10);
	memset(replyChange,0,sizeof(replyChange[0]) * 10);
	load = 0;
	lastLoad = svcGetSystemTick();
}
void send_bike_update() {
	if (!(redo && num_bikes > 1)) {
		popScene();
		pushScene(game_init,game_update,NULL,NULL); 
		return;
	}
	snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sPreparing room...",loading[load]);
	myprintf(mystring);
	if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
	if (load > 7) load = 0;
	keepConsole();
	for (int i = 0; i < num_bikes; i++) {
		snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sPreparing room...",loading[load]);
		myprintf(mystring);
		if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
		if (load > 7) load = 0;
		keepConsole();
		msg.sprite = sprites[i];
		UDSResend(replySprite,msg);
	}
	if (!allReplied(replySprite)) lastSprite = svcGetSystemTick();
	if (!allReplied(replyChange)) lastChange = svcGetSystemTick();
	msg.sprite.image = 0;
	msg.sprite.speed = 66;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	msg.sprite.dx = optionsToInt();
	UDSResend(replyChange,msg);
	pushScene(NULL,prepare_room_update,NULL,prepare_room_finish);
}
void send_bike_finish() {
	gspWaitForVBlank();
}
void receive_bike_init() { 
	if (debugging) myprintf("Receiving bike information...");
	memset(replySprite,1,sizeof(replySprite[0]) * 10);
	lastSprite = svcGetSystemTick();
	oldspeed = 0;
	load = 0;
	lastLoad = svcGetSystemTick();
}
void receive_bike_update() {
	snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sLoading...",loading[load]);
	myprintf(mystring);
	snprintf(mystring,sizeof(mystring),"\x1b[1;0HYou are %s%s%s!",textColors[myNum],colorNames[myNum],WHITE);
	myprintf(mystring);
	if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
	if (load > 7) load = 0;
	keepConsole();
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_START) {
		was_in_game = true;
		popScene();
		return;
	}
	memset(tmpbuf, 0, tmpbuf_size);
	actual_size = 0;
	src_NetworkNodeID = 0;

	if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
	{
		

		//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
		ret = udsGetConnectionStatus(&constatus);
		if(R_FAILED(ret))
		{
			clearString(); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			return;
		}
		else
		{
			if (!hosting) {
				currentBots = 1;
				myNum = constatus.cur_NetworkNodeID - 1;
				num_bikes = constatus.total_nodes;
				sprites[myNum].image = myNum;
				sprites[myNum].node = myNode;
				memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
				snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 1111;
				UDSDirect(1,msg);
			}
		}
	}
	memset(tmpbuf, 0, tmpbuf_size);
	actual_size = 0;
	src_NetworkNodeID = 0;
	//myprintf("tmpbuf_size: 0x%08x (0x%08x)",tmpbuf_size,sizeof(msg));
	if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
	if(R_FAILED(ret))
	{
		clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
		myprintf(mystring);
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
	if(actual_size >= sizeof(msg))//If no data frame is available, udsPullPacket() will return actual_size=0.
	{
		memcpy(&msg,tmpbuf,sizeof(msg));
		if (debugging) if (msg.sprite.speed != oldspeed) { clearString(); snprintf(mystring,sizeof(mystring),"image: %d speed: %d myNum: %d myNode: %d",msg.sprite.image, msg.sprite.speed, myNum, myNode); myprintf(mystring); }
		oldspeed = msg.sprite.speed;
		
		if (msg.sprite.speed == 123) {} //ignore
		else if (msg.sprite.speed == 777) {} //ignore
		else if (msg.sprite.speed == 555) { if (msg.sender == 0) UDSSend(msg); } //make sure host realizes we are waiting for him!
		else if (msg.sprite.speed == 1111) { sprites[msg.sprite.image] = msg.sprite; snprintf(sprites[msg.sprite.image].username,sizeof(sprites[msg.sprite.image].username),"%s",msg.sprite.username); oldbikes--; } //ignore
		else if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; msg.sprite.speed = BIKE_NORMAL; sprites[myNum] = msg.sprite; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; popScene();  pushScene(game_init,game_update,NULL,NULL); return; } //joined game in score screen
		else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].speed = BIKE_NORMAL; sprites[myNum].node = myNode; sprites[myNum].dead = true; memset(sprites[myNum].username,0,sizeof(sprites[myNum].username)); snprintf(sprites[msg.sprite.image].username,sizeof(sprites[msg.sprite.image].username),"%s",msg.sprite.username); popScene();  pushScene(game_init,game_update,NULL,NULL); return; } // joined game in progress
		else if (msg.sprite.speed == 66) {
			if (msg.sender == 0) {
				apple.x = msg.sprite.x;
				apple.y = msg.sprite.y;
				setOptions((unsigned int)msg.sprite.dx);
				UDSDirect(1,msg);
			}
		} else if (msg.sprite.speed == 101) { if (msg.sender == 0) UDSSend(msg); popScene(); pushScene(game_init,game_update,NULL,NULL); return; }
		else if (msg.sender == 0 && (msg.sprite.speed == BIKE_NORMAL || msg.sprite.speed == 1211)) {
			path[0][msg.sprite.image].x = msg.sprite.x;
			path[0][msg.sprite.image].y = msg.sprite.y;
			sprites[msg.sprite.image] = msg.sprite;
			sprites[msg.sprite.image].speed = BIKE_NORMAL;
			if (msg.sprite.image >= num_bikes - 1) {
				msg.sprite.speed = 100;
				UDSDirect(1,msg);
			}
		}
	} 
}
void setup_init() {
	//myprintf("Press A to stop data transfer.");
	memset(quitName,0,sizeof(quitName));
	debugHold = false;
	errorQuit = 0;
	if (num_bikes < 1) num_bikes = 1;
	for (int i = 0; i < numPlayers(); i++) {
		score[i] = 0;
	}
	setSprites();
}
void setup_update() {
	keepConsole();
	if (hosting == 1) { //hosting, wait for connection
		popScene();
		pushScene(send_bike_init,send_bike_update,NULL,send_bike_finish);
		pushScene(wait_for_player_init,wait_for_player_update,NULL,NULL);
		return;
	} else if (!inGame) { //guest connection
		popScene();
		pushScene(receive_bike_init,receive_bike_update,NULL,NULL);
		return;
	} else { //in game. need to go to game
		popScene();
		pushScene(game_init,game_update,NULL,NULL);
		return;
	}
}
void roundEnd_init() { 

	myconsoleClear();
	memset(replyChange,1,sizeof(replyChange[0]) * 10);
	memset(replyScore,0,sizeof(replyScore[0]) * 10);
	memset(replyDead,1,sizeof(replyDead[0]) * 10);
	memset(replySprite,0,sizeof(replySprite[0]) * 10);
	memset(replyHighscore,1,sizeof(replyHighscore[0]) * 10);
	memset(replyScreenScore,0,sizeof(replyScreenScore[0]) * 10);
	memset(receivedScreenScore,0,sizeof(receivedScreenScore[0]) * 10);
	msg.sprite = sprites[myNum];
	msg.sprite.speed = 5050;
	if (options[4]) totalSpace *= 1.25;
	if (options[5]) totalSpace *= 1.25;
	msg.sprite.dx = totalSpace;
	lastScreenScore = svcGetSystemTick();
	UDSSend(msg);
	lastScore = 0;
	oldQuit = 0;
	numLeft = 0;
	errorQuit = 0;
	for (int i = 0; i < NUM_SPRITES; i++) {
		ready[i] = false;
	}
	joinedNum = 0;
	waitForFinish = 0;
	readyLock = svcGetSystemTick();
	inGame = false;
	saveReady = false;
	displayedHS = false;
	iWin = false;
}
void roundEnd_update() {
	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
	C3D_FrameDrawOn(target2);
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &textprojection);
	myprintf("\x1b[2;0H "); //clear the 3rd line in case we scroll text
	keepSConsole();
	if (num_bikes == 1) {
		currentBots = numOpponents + 1;
	}
	if (totalSpace >= 120 * 200) { //entire screen is filled... wow.
		snprintf(mystring,sizeof(mystring),"\x1b[6;0H%sThe screen is completely filled!",RAINBOW);
		myprintf(mystring);
		snprintf(mystring,sizeof(mystring),"\x1b[7;0H%sI can't even.%s",RAINBOW,WHITE);
		myprintf(mystring);
	}
	//Be sure to still resend my death msg if someone hasn't gotten it
	if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
		sprites[myNum].image = myNum;
		sprites[myNum].dead = true;
		sprites[myNum].node = myNode;
		msg.sprite = sprites[myNum];
		lastSprite = svcGetSystemTick();
		UDSResend(replySprite,msg);
	}

	if (!allReplied(replyDead) && svcGetSystemTick() - lastDeadmsg > TICKS_PER_MS * 15 * 6 * lagMult()) {
		msg.sprite = sprites[myNum];
		msg.sprite.speed = 2020;
		msg.sprite.dx = optionsToInt();
		lastDeadmsg = svcGetSystemTick();
		UDSResend(replyDead,msg);
	}
	if (!allReplied(replyHighscore) && svcGetSystemTick() - lastHighscore > TICKS_PER_MS * 15 * 6 * lagMult()) {
		msg.sprite = sprites[myNum];
		msg.sprite.speed = 3030;
		msg.sprite.dx = highScore;
		lastHighscore = svcGetSystemTick();
		UDSResend(replyHighscore,msg);
	}
	if (!allReplied(replyScreenScore) && svcGetSystemTick() - lastScreenScore > TICKS_PER_MS * 15 * 6 * lagMult()) {
		msg.sprite = sprites[myNum];
		msg.sprite.speed = 5050;
		msg.sprite.dx = totalSpace;
		lastScreenScore = svcGetSystemTick();
		UDSResend(replyScreenScore,msg);
	}
	//if it's not survival mode
	if (!options[7]) {
		if (itsATie()) myprintf("\x1b[0;0HIt's a TIE!");
		else if (getHighestScore() == myNum ) { 
			if (forfeit) {
				snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sYou forfeit the match!",WHITE);
				myprintf(mystring);
			}
			else {
				iWin = true; 
				snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sA winner is YOU!%s",RAINBOW,WHITE);
				myprintf(mystring); 
			}
		}
		else { clearString(); snprintf(mystring,sizeof(mystring),"\x1b[0;0HYou LOSE! %s%s wins the game!%s",textColors[getHighestScore()],sprites[getHighestScore()].username,WHITE); myprintf(mystring); }
	} else {
		if (myNum == lastDead) { 
			if (forfeit) {
				snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sYou forfeit the match!",WHITE);
				myprintf(mystring);
			}
			else {
				iWin = true; 
				snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sA winner is YOU!%s",RAINBOW,WHITE); 
				myprintf(mystring); 
			}
		}
		else { snprintf(mystring,sizeof(mystring),"\x1b[0;0HYou LOSE! %s%s wins the game!%s",textColors[lastDead],sprites[lastDead].username,WHITE); myprintf(mystring); }
	}
	clearString(); snprintf(mystring,sizeof(mystring),"\x1b[1;0HScore: ");
	char scores[10];
	float widths[10];
	float h;
	char te[100];
	char k[10];
	memset(te,0,sizeof(te));
	snprintf(te,sizeof(te),"Score: ");
	memset(scores,0,sizeof(scores));
		for (int i = 0; i < NUM_SPRITES; i++) {
			memset(scores,0,sizeof(scores));
			memset(k,0,sizeof(k));
			if (i < numPlayers() || i == 0) snprintf(scores,sizeof(scores),"%s%d ",textColors[i],score[i]);
			snprintf(k,sizeof(k),"%d ",score[i]);
			//else snprintf(scores,sizeof(scores),"  ");
			screen_get_string_size_wrap(&widths[i], &h, te, 0.5f, 0.5f, 320);
			strcat(mystring,scores);
			strcat(te,k);
		}
	myprintf(mystring);
	//clearString(); snprintf(mystring,sizeof(mystring),"\x1b[2;0H%sScore: ", BLACK);
		for (int i = 0; i < NUM_SPRITES; i++) {
			memset(scores,0,sizeof(scores));
			if (i < num_bikes) {
				if (ready[i]) snprintf(scores,sizeof(scores),"%sR",GREEN);
				else snprintf(scores,sizeof(scores),"%s-",WHITE);
				rText(widths[i],h * 2 + 10.0,.5f,.5f,true,scores);
			}
		}
	C3D_FrameEnd(0);
	if (allReplied(replyScore) && myNum == 0 && num_bikes > 1) { if (debugging) myprintf("Everyone got the message. Sending bike information.."); popScene(); pushScene(setup_init,setup_update,NULL,NULL); return; }
	clearString(); snprintf(mystring,sizeof(mystring),"\x1b[3;0H%sPress A if you're ready!",WHITE);
	myprintf(mystring);
	myprintf("\x1b[4;0HPress START to quit.");
	if (!myNum) myprintf("\x1b[5;0HPress SELECT to set game modes!");



	snprintf(mystring,sizeof(mystring),"\x1b[5;0HScreen score: %d",totalSpace);
	myprintf(mystring);
	if (iWin && allReplied(receivedScreenScore)) {
		if ((unsigned int)totalSpace > highScore) setHighscore((unsigned int)totalSpace);
	}
	if (num_bikes == 1 && actual_bikes > 1) { currentBots = numOpponents + 1; numLeft++; num_bikes--; clearString(); snprintf(mystring,sizeof(mystring),"Everyone has left the game!"); myprintf(mystring); }
	
	//Trigger to resend dropped packet of "Ready"
	if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
		sprites[myNum].node = myNode;
		snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
		msg.sprite = sprites[myNum];
		msg.sprite.speed = 123;
		//memset(replyChange,0,sizeof(replyChange[0]) * 10);
		UDSResend(replyChange,msg);
	}

	//Trigger to resend dropped packet of "Start game"
	if (myNum == 0 && lastScore && !allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 30 * lagMult()) {
		sprites[myNum].node = myNode;
		snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
		msg.sprite = sprites[myNum];
		msg.sprite.speed = 555;
		UDSResend(replyScore,msg);
		lastScore = svcGetSystemTick();
	}


	hidScanInput();
	u32 kDown = hidKeysDown();
	memset(tmpbuf, 0, tmpbuf_size);
	actual_size = 0;
	src_NetworkNodeID = 0;
	if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
	if(R_FAILED(ret))
	{
		clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
		myprintf(mystring);
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		replay = false;
		return;
	}
	if(actual_size >= sizeof(msg))//If no data frame is available, udsPullPacket() will return actual_size=0.
	{
		//Message msg;
		memcpy(&msg,tmpbuf,sizeof(msg));
		if (debugging) {
			numLeft++;
			/*clearString(); snprintf(mystring,sizeof(mystring),"sender: %d, image: %d, speed: %d node: %d",msg.sender,msg.sprite.image,msg.sprite.speed, msg.sprite.node);
			myprintf(mystring);*/
		}
		if (msg.sprite.speed == 999) { //death message
			if (msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
				memset(quitName,0,sizeof(quitName));
				snprintf(quitName,sizeof(quitName),"%s",msg.sprite.username);
				for (int i = 0; i < num_bikes; i++) {
					if (sprites[i].node == msg.sprite.node && i != oldQuit) { quit = i; oldQuit = quit; }
				}
				msg.sprite.image = msg.sprite.node;
				msg.sprite.node = myNode;
				UDSDirect(msg.sprite.image,msg);
			}
		}
		/*if (msg.sprite.speed == 999 && msg.sprite.image != quit) {
			if (msg.sender <= num_bikes) {
				lastQuit = msg.timestamp;
				quit = msg.sprite.image;
				quitNum = msg.sender;
				if (quit < myNum) myNum--;
				num_bikes--;
				replyChange--;
			}
		} //connection killed by guest*/
		else if (msg.sprite.speed == 1011) { } //ignore
		else if (msg.sprite.speed == 3030) {
			if (msg.sprite.image != myNum) {
				if (!displayedHS) { snprintf(mystring,sizeof(mystring),"%s%s%s's new High Score: %s%u",textColors[msg.sprite.image],msg.sprite.username,WHITE,RAINBOW,(unsigned int)msg.sprite.dx); myprintf(mystring); }
				displayedHS = true;
				UDSDirect(msg.sprite.node,msg);
			} else if (msg.sprite.image == sprites[myNum].image) replyHighscore[msg.sender] = true;
		}
		else if (msg.sprite.speed == 5050) {
			if (msg.sprite.image != myNum) {
				if (msg.sprite.dx > totalSpace) totalSpace = msg.sprite.dx;
				receivedScreenScore[msg.sender] = true;
				UDSDirect(msg.sprite.node,msg);
			} else if (msg.sprite.image == sprites[myNum].image) replyScreenScore[msg.sender] = true;
		}
		else if (msg.sprite.speed == 2020) {
			if (msg.sender == 0) {
				saveReady = false;
				memset(replyChange,1,sizeof(replyChange[0]) * 10);
				for (int k = 0; k < NUM_SPRITES; k++) {
					ready[k] = false;
				}
				if (lastDeadmsg != msg.timestamp) {
					lastDeadmsg = msg.timestamp;
					int n = msg.sprite.dx;
					snprintf(mystring,sizeof(mystring),"%s%s%s was in game options...",textColors[0],sprites[0].username,WHITE);
					myprintf(mystring);
					bool flag = false;
					for (unsigned int i = 0; i != numOptions; ++i)
					{
						if (options[i] && !(n & 1)) {
							flag = true;
						  	snprintf(mystring,sizeof(mystring),"    %s%s%s is now %soff%s.",DARKYELLOW,optionNames[i],WHITE,RED,WHITE);
						  	myprintf(mystring);
						}
					 	n /= 2;
					}
					n = msg.sprite.dx;
					for (unsigned int i = 0; i != numOptions; ++i)
					{
						if (!options[i] && n & 1) {
							flag = true;
						  	snprintf(mystring,sizeof(mystring),"    %s%s%s is now %son%s.",YELLOW,optionNames[i],WHITE,GREEN,WHITE);
						  	myprintf(mystring);
						}
					 	n /= 2;
					}
					if (!flag) myprintf("    but nothing was changed...");
					setOptions(msg.sprite.dx);
				}
				UDSDirect(msg.sprite.node,msg);
			} else {
				replyDead[msg.sender] = true;
			}
		}
		else if (msg.sprite.speed == 1111) { //join message
			sprites[msg.sprite.image] = msg.sprite;
			sprites[msg.sprite.image].node = msg.sprite.node;
			currentBots = 1;
			if (joinedNum != msg.sprite.image) { clearString(); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s",textColors[msg.sprite.image],msg.sprite.username,colorNames[msg.sprite.image],WHITE); myprintf(mystring); }
			joinedNum = msg.sprite.image;
			if (myNum == 0) {
				sprites[myNum].node = myNode;
				msg.sprite = sprites[msg.sprite.image];
				msg.sprite.dead = true;
				msg.sprite.speed = 1001;
				UDSSend(msg);
			}
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			sprites[myNum].node = myNode;
			memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
			snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
			sprites[myNum].node = myNode;
			msg.sprite = sprites[myNum];
			UDSSend(msg);
		}
		//ready message
		else if (msg.sprite.speed == 123) { 
			if (!ready[msg.sender]) { 
				numLeft++;  
				clearString(); 
				snprintf(mystring,sizeof(mystring),"%s%s%s is ready!",textColors[msg.sender],msg.sprite.username,WHITE);
				if (notReadies() - 1) snprintf(mystring,sizeof(mystring),"%s%s%s is ready! Waiting on %d more...", textColors[msg.sender], msg.sprite.username, WHITE, notReadies() - 1); 
				myprintf(mystring); 
			} 
			ready[msg.sender] = true; 
			if (msg.sprite.node != myNode) { 
				msg.sprite.image = msg.sender; 
				msg.sprite.speed = 777; 
				UDSDirect(msg.sprite.node,msg); 
			} 
		}
		//response to ready message
		else if (msg.sprite.speed == 777) {
			if (msg.sprite.node == myNode) replyChange[msg.sender] = true;

			//game start message
		} else if(msg.sprite.speed == 555) {
			if (msg.sender == 0) {
				UDSDirect(msg.sprite.node,msg); 
				popScene();
				pushScene(setup_init,setup_update,NULL,NULL);
				return;
			} else if (myNum == 0) {
				replyScore[msg.sender] = true;
			}
		} else { //or its a sprite change
			if (msg.sprite.image == myNum && msg.sprite.dead && lastSprite == msg.timestamp) replySprite[msg.sender] = true;
			else if (msg.sprite.image == msg.sender) {
				sprites[msg.sprite.image] = msg.sprite;
				UDSDirect(msg.sprite.node,msg);
			}
		}
	}
	if (allReady() && num_bikes > 1 && !lastScore) { 
		clearString(); snprintf(mystring,sizeof(mystring),"Starting game....");  
		myprintf(mystring);
		if (myNum == 0) { 
			msg.sprite = sprites[myNum]; 
			msg.sprite.speed = 555;
			memset(replyScore,0,sizeof(replyScore[0]) * 10);
			UDSSend(msg);
		}
		lastScore = svcGetSystemTick();
	}



	if (kDown & KEY_L) {
		if (autoPilot) {
			autoPilot = false;
			myprintf("Autopilot disengaged.");
		} else {
			autoPilot = true;
			myprintf("Autopilot engaged");
		}
	}
	if (myNum == 0 && kDown & KEY_SELECT) {
		if (!ready[0]) { 
			pushScene(options_menu_init,options_menu_update,options_menu_draw,endRoundGameOptions_Finish);
			return;
		}
		else myprintf("Can't edit modes when you are ready!");
	}
	//player pressed A
	if (kDown & KEY_A || saveReady || (autoPilot && actual_bikes > 1)) {
		if (num_bikes <= 1) { popScene(); pushScene(setup_init,setup_update,NULL,NULL); return; }
		if (!ready[myNum] && svcGetSystemTick() - readyLock > TICKS_PER_SEC) { 
			sprites[myNum].node = myNode; 
			snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
			msg.sprite = sprites[myNum]; 
			msg.sprite.speed = 123; 
			lastChange = svcGetSystemTick(); 
			memset(replyChange,0,sizeof(replyChange[0]) * 10); 
			UDSSend(msg); 
			numLeft++; 
			clearString(); snprintf(mystring,sizeof(mystring),"%s%s%s is ready! Waiting on %d more...",textColors[myNum],sprites[myNum].username,WHITE,notReadies() - 1); 
			myprintf(mystring);
			ready[myNum] = true;  
		} else saveReady = true;
	}

	//leaving the game
	if (kDown & KEY_START) { popScene(); if (myNum) pushScene(send_quit_init,send_quit_update,NULL,send_quit_finish); return; }

	//someone left or joined
	if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
	{
		connectionEstablished = true;
		readyLock = svcGetSystemTick();
		for (int i = 0; i < 10; i++) {
			ready[i] = false;
		}
		ret = udsGetConnectionStatus(&constatus);
		ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
		if (constatus.total_nodes >= num_bikes) {
			num_bikes = constatus.total_nodes;
			memset(sprites[num_bikes].username,0,sizeof(sprites[num_bikes - 1].username));
			udsGetNodeInfoUsername(&tmpnode,sprites[num_bikes - 1].username);
			msg.sprite = sprites[num_bikes - 1];
			memset(replyScore,0,sizeof(replyScore[0]) * 10);
			memset(replyChange,1,sizeof(replyChange[0]) * 10);
			numLeft++;
		} else {
				numLeft++;
				if (quit < 0) {
					pushScene(player_crashed_init,player_crashed_update,NULL,player_crashed_finish);
					return;
				}
				else {
					joinedNum = 0;
					clearString(); snprintf(mystring,sizeof(mystring),"%s%s has left the game.%s",textColors[quit],quitName,WHITE);
					myprintf(mystring);
					if (quit > 0 && quit < num_bikes - 1) {
						if (quit < myNum) myNum--;
						for (int i = quit; i < num_bikes - 1; i++) {
							numLeft++;
							if (i == myNum) { clearString(); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE); }
							else { clearString(); snprintf(mystring,sizeof(mystring),"  %s%s%s is now %s%s%s!", textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE); }
							myprintf(mystring);
							sprites[i] = sprites[i+1];
							sprites[i].image = i;
						}
						quit = -1;
					}
					oldQuit = -1;
					quit = -1;
				}
			/*int foundNum = -1;
			for (int i = 0; i < constatus.total_nodes; i++) {
				numLeft++;
				ret = udsGetNodeInformation(i,&tmpnode);
				udsGetNodeInfoUsername(&tmpnode,&sprites[i - 1].username);
				if (!strcmp(sprites[i].username,myname)) foundNum = i;
				myprintf("\x1b[%d;0H%s == %s? (%d)",numLeft + 5, sprites[i].username, myname,i);
			}
			if (foundNum == -1) myNum = constatus.total_nodes - 1;*/
			num_bikes = constatus.total_nodes;
			memset(replyScore,0,sizeof(replyScore[0]) * 10);
			memset(replyChange,1,sizeof(replyChange[0]) * 10);
		}
	}
}
void game_init() { 
	was_in_game = true;
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
	gfxFlushBuffers();
	gfxSwapBuffers();
	C3D_RenderTargetSetClear(target, 0, 0, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
	gfxFlushBuffers();
	gfxSwapBuffers();
	for (int i = 0; i < 10; i++) oldscore[i] = 0;
	oldbikes = num_bikes;
	myconsoleClear();
	// Main loop
	for (int i = 0; i < numPlayers(); i++) {
		frameTicks[i] = svcGetSystemTick();
	}
	oldApplex = 0;
	oldAppley = 0;
	oldDx = 15;
	C3D_RenderTargetSetClear(target, 0, 0, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
	UDSSent = svcGetSystemTick();
	memset(replyChange,1,sizeof(replyChange[0]) * 10);
	memset(replyScore,1,sizeof(replyScore[0]) * 10);
	if (myNum) memset(replyChange,1,sizeof(replyChange[0]) * 10);
	frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);
	if (!inGame && myNum != 0) memset(replySprite,1,sizeof(replySprite[0]) * 10);
	quit = -1;
	if (!inGame) actual_bikes = num_bikes;
	printScore();
	death = 0;
	for (int i = numPlayers(); i < NUM_SPRITES; i++) {
		sprites[i].dead = true;
	}
	oldCPos.dx = 0;
	oldCPos.dy = 0;
	nextMove = 0;
	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
		C3D_FrameDrawOn(target);
		C3D_TexBind(0, &spritesheet_tex);
		C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
		if (options[0]) {
			drawWall(7);
		}
		drawSprite(apple.x , apple.y , 2, 2, 8);
	C3D_FrameEnd(0);
	gfxFlushBuffers();
	lastDead = 0;
	totalSpace = 0;
	ignoreDeath = true;
	for (int i = 0; i < NUM_SPRITES; i++) {
		erased[i] = false;
	}
	goDiag = false;
	for (int b = 0; b < currentBots; b++) {
		if (b != 0) plotCourse(b);
		else if (autoPilot && b == myNum) plotCourse(b);
	}
	forfeit = false;
	movingApple = false;
}
void game_update() {
	if (cheats || autoPilot) forfeit = true;
	if (actual_bikes > 1) {
		for (int b = 0; b < currentBots; b++) {
			if (b != 0 && !sprites[b].dead) {
				sprites[b].dead = true;
				lastDead = b;
				snprintf(mystring,sizeof(mystring),"%s%s%s has left the game.",textColors[b],sprites[b].username,WHITE);
				myprintf(mystring);
			}
		}
		currentBots = 1;
	}
	totalSpace = 0;
	for (int i = 0; i < numPlayers(); i++) {
		totalSpace += getLength(i);
	}
	if (totalSpace >= 200 * 120) {
		int sanityCheck = 0;
		for (int i = 0; i < numPlayers(); i++) {
			sanityCheck += sprites[i].length;
		}
		if (sanityCheck >= 120 * 200) { //Wow, the screen is actually filled.
			sprites[myNum].dead = true;
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick();
			msg.sprite = sprites[myNum];
			UDSSend(msg);
		}
	}
	if (everyoneElseIsDead(myNum) && sprites[myNum].dead) { popScene(); pushScene(roundEnd_init,roundEnd_update,NULL,NULL); return; }
	if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 3) {
		return;
	}
	/*if (myNum == 0) {
		if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
		{
			
			ret = udsGetConnectionStatus(&constatus);
			ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
			if (constatus.total_nodes >= num_bikes) {
				replyScore[msg.sender] = true;
				replyChange[msg.sender] = true;
				num_bikes = constatus.total_nodes;
			} else {
				errorQuit = svcGetSystemTick();
			}
		}
	}*/
	if (!wakeup) { //wakeup is true when everyone has started the round
		if (!allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 6 * lagMult()) {
			msg.sprite = sprites[myNum];
			msg.sprite.image = myNum;
			msg.sprite.speed = 77;
			msg.sprite.dx = score[myNum];
			msg.sprite.x = apple.x;
			msg.sprite.y = apple.y;
			UDSResend(replyScore,msg);
		}
		else if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 6 * lagMult()) {
			msg.sprite = sprites[myNum];
			msg.sprite.image = myNum;
			msg.sprite.speed = 66;
			msg.sprite.x = apple.x;
			msg.sprite.y = apple.y;
			UDSResend(replyChange,msg);
		}
		if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
			if (sprites[myNum].speed == 1011) {
				memset(replySprite,1,sizeof(replySprite[0]) * 10);
			} else {
				sprites[myNum].node = myNode;
				memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
				snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
				msg.sprite = sprites[myNum];
				lastSprite = svcGetSystemTick();
				UDSResend(replySprite,msg);
			}
		}
	} else { //not everyone has started the round yet.
		if (!allReplied(replySprite) && svcGetSystemTick() -  lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
			msg.sprite = sprites[myNum];
			msg.sprite.speed = 101;
			UDSResend(replySprite,msg);
			lastSprite = svcGetSystemTick();
		}
		if (allReplied(replySprite)) {
			wakeup = false;
		}
	}
	hidScanInput();

	// Respond to user input
	u32 kDown = hidKeysDown();
	u32 kHeld = hidKeysHeld();
	u32 kUp = hidKeysUp();
	if (debugging && kDown & KEY_SELECT) showCameFrom(1);
	hidCircleRead(&cpos);

	//Read the touch screen coordinates
	hidTouchRead(&touch);

	float px = (float)touch.px / 312.0f;
	float py = (float)touch.py / 235.0f;
	px *= 400.0f;
	py *= 240.0f;

	//Read the CirclePad position
	if (kDown & KEY_START) {
		replay = false;
		popScene();
		if (myNum) {
			pushScene(send_quit_init,send_quit_update,NULL,send_quit_finish);
		}
		return; // break in order to return to hbmenu
	}
	u32 msgtype = 0;
	float dvd = fabs(cpos.dx) / fabs(cpos.dy);
	if (fabs(cpos.dy) > fabs(cpos.dx)) dvd = fabs(cpos.dy) / fabs(cpos.dx);
	if (goDiag || ((abs(cpos.dy) > 20 || abs(cpos.dx) > 20) && !(oldCPos.dx == 0 && oldCPos.dy == 0))) {
		if (dvd < 3.5 && !options[2]) {
			if (cpos.dy > 0 && cpos.dx > 0) {
				goDiag = true;
				sprites[myNum].diag = NORTHEAST;
				if (oldMove == MOVE_UP) kDown |= KEY_CPAD_RIGHT;
				else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_UP;
				else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
				else kDown |= KEY_CPAD_RIGHT;
			} else if (cpos.dx < 0 && cpos.dy < 0) {
				goDiag = true;
				sprites[myNum].diag = SOUTHWEST;
				if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_LEFT;
				else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_DOWN;
				else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
				else kDown |= KEY_CPAD_LEFT;
			} else if (cpos.dx < 0 && cpos.dy > 0) {
				goDiag = true;
				sprites[myNum].diag = NORTHWEST;
				if (oldMove == MOVE_UP) kDown |= KEY_CPAD_LEFT;
				else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_UP;
				else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
				else kDown |= KEY_CPAD_LEFT;
			} else if (cpos.dx > 0 && cpos.dy < 0) {
				goDiag = true;
				sprites[myNum].diag = SOUTHEAST;
				if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_RIGHT;
				else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_DOWN;
				else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
				else kDown |= KEY_CPAD_RIGHT;
			} 
		} else if (cpos.dx != oldCPos.dx || cpos.dy != oldCPos.dy) {
			goDiag = false;
			if (cpos.dx < 0 && abs(cpos.dx) > abs(cpos.dy)) { msgtype = MOVE_LEFT; kDown |= KEY_CPAD_LEFT; }
			else if (cpos.dx > 0 && abs(cpos.dx) > abs(cpos.dy)) { msgtype = MOVE_RIGHT; kDown |= KEY_CPAD_RIGHT; }
			else if (cpos.dy < 0 && abs(cpos.dy) > abs(cpos.dx)) { msgtype = MOVE_DOWN; kDown |= KEY_CPAD_DOWN; } 
			else if (cpos.dy > 0 && abs(cpos.dy) > abs(cpos.dx)) { msgtype = MOVE_UP; kDown |= KEY_CPAD_UP; }
			sprites[myNum].diag = 0;
		} else if (goDiag) {
			if (sprites[myNum].diag == NORTHEAST) {
				if (oldMove == MOVE_UP) kDown |= KEY_CPAD_RIGHT;
				else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_UP;
				else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
				else kDown |= KEY_CPAD_RIGHT;
			} else if (sprites[myNum].diag == SOUTHWEST) {
				if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_LEFT;
				else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_DOWN;
				else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
				else kDown |= KEY_CPAD_LEFT;
			} else if (sprites[myNum].diag == NORTHWEST) {
				if (oldMove == MOVE_UP) kDown |= KEY_CPAD_LEFT;
				else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_UP;
				else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
				else kDown |= KEY_CPAD_LEFT;
			} else if (sprites[myNum].diag == SOUTHEAST) {
				if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_RIGHT;
				else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_DOWN;
				else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
				else kDown |= KEY_CPAD_RIGHT;
			} else if (oldDiag) {
				goDiag = false;
				msgtype = MOVE_LEFT;
				sprites[myNum].diag = 0;
			}
		}
	} else if (oldDiag) {
		goDiag = false;
		sprites[myNum].diag = 0;
		msgtype = MOVE_LEFT;
		if (sprites[myNum].dx > 0) msgtype = MOVE_RIGHT;
		else if (sprites[myNum].dx < 0) msgtype = MOVE_LEFT;
		else if (sprites[myNum].dy > 0) msgtype = MOVE_UP;
		else if (sprites[myNum].dy < 0) msgtype = MOVE_DOWN;
	}
	oldCPos = cpos;
	if (debugging && (kDown & KEY_X || kHeld & KEY_X)) {
		debugHold = true;
	}
	if (debugging && kUp & KEY_X) debugHold = false;
	if (kDown & KEY_L) {
		if (autoPilot) { myprintf("Autopilot disengaged."); autoPilot = false; }
		else { autoPilot = true; myprintf("Autopilot engaged."); plotCourse(myNum); }
	}
	if (!options[3] && !autoPilot) { //A is enabled
		if (kDown & KEY_A || kHeld & KEY_A) sprites[myNum].speed = BIKE_FAST;
		else if (kUp & KEY_A) sprites[myNum].speed = BIKE_NORMAL;
	}
	if (actual_bikes == 1 && sprites[myNum].dead && kDown & KEY_A) {
		forfeit = true;
		for (int b = 1; b < currentBots; b++) {
			sprites[b].dead = true;
		}
	}
	if (!options[4] && !autoPilot) { //B is enabled
		if (kDown & KEY_B || kHeld & KEY_B) sprites[myNum].speed = BIKE_SLOW;
		else if (kUp & KEY_B) sprites[myNum].speed = BIKE_NORMAL;
	}
	int prevn = currentPath[myNum] - 1;
	if (prevn < 0) prevn = 120 * 200 - 1;
	if (goDiag && (kDown & KEY_DUP || kDown & KEY_DDOWN || kDown & KEY_DLEFT || kDown & KEY_DRIGHT)) {
		goDiag = false;
		sprites[myNum].diag = 0;
		nextMove = 0;
		if (kDown & KEY_DUP) {
			sprites[myNum].dx = 0;
			sprites[myNum].dy = bikeSpeed * -1;
			msgtype = MOVE_UP;
		} else if (kDown & KEY_DDOWN) {
			sprites[myNum].dx = 0;
			sprites[myNum].dy = bikeSpeed;
			msgtype = MOVE_DOWN;
		} else if(kDown & KEY_DLEFT) {
			sprites[myNum].dx = bikeSpeed * -1;
			sprites[myNum].dy = 0;
			msgtype = MOVE_LEFT;
		} else if(kDown & KEY_DRIGHT) {					
			sprites[myNum].dx = bikeSpeed;
			sprites[myNum].dy = 0;
			msgtype = MOVE_RIGHT;
		}
	}
	else if ((kDown & KEY_CPAD_UP || kDown & KEY_DUP || nextMove == MOVE_UP) && !sprites[myNum].dy) { //they want to move up
		if (kDown & KEY_DUP) sprites[myNum].diag = 0;
		if (path[prevn][myNum].x == sprites[myNum].x) nextMove = MOVE_UP;
		else {
			sprites[myNum].dx = 0;
			sprites[myNum].dy = bikeSpeed * -1;
			msgtype = MOVE_UP;
			nextMove = 0;
		}
	} else if((kDown & KEY_CPAD_DOWN || kDown & KEY_DDOWN || nextMove == MOVE_DOWN)  && !sprites[myNum].dy) { //they want to move down
		if (kDown & KEY_DDOWN) sprites[myNum].diag = 0;
		if (path[prevn][myNum].x == sprites[myNum].x) nextMove = MOVE_DOWN;
		else {
			sprites[myNum].dx = 0;
			sprites[myNum].dy = bikeSpeed;
			msgtype = MOVE_DOWN;
			nextMove = 0;
		}
	} else if ((kDown & KEY_CPAD_LEFT || kDown & KEY_DLEFT || nextMove & MOVE_LEFT)  && !sprites[myNum].dx) { //they want to move left
		if (kDown & KEY_DLEFT) sprites[myNum].diag = 0;
		if (path[prevn][myNum].y == sprites[myNum].y) nextMove = MOVE_LEFT;
		else {
			sprites[myNum].dx = bikeSpeed * -1;
			sprites[myNum].dy = 0;
			msgtype = MOVE_LEFT;
			nextMove = 0;
		}
	} else if ((kDown & KEY_CPAD_RIGHT || kDown & KEY_DRIGHT || nextMove == MOVE_RIGHT)  && !sprites[myNum].dx) { //they want to move right
		if (kDown & KEY_DRIGHT) sprites[myNum].diag = 0;
		if (path[prevn][myNum].y == sprites[myNum].y) nextMove = MOVE_RIGHT;
		else {
			sprites[myNum].dx = bikeSpeed;
			sprites[myNum].dy = 0;
			msgtype = MOVE_RIGHT;
			nextMove = 0;
		}
	}
	if (msgtype != 0 || oldDx != sprites[myNum].speed) { //there has been some kind of change, lets send an update
		oldMove = msgtype;
		if (oldDiag != sprites[myNum].diag || !sprites[myNum].diag || oldDx != sprites[myNum].speed) {
			oldDiag = sprites[myNum].diag;
			sprites[myNum].node = myNode;
			memset(sprites[myNum].username,0,sizeof(sprites[myNum].username));
			snprintf(sprites[myNum].username,sizeof(sprites[myNum].username),"%s",myName);
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			msg.sprite = sprites[myNum];
			lastSprite = svcGetSystemTick();
			UDSSend(msg);
		}
		oldDx = sprites[myNum].speed;
	}
	//send my sprite info
	//Message msg;
	

	//receive other sprite's info
	memset(tmpbuf, 0, tmpbuf_size);
	actual_size = 0;
	src_NetworkNodeID = 0;
	if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
	if(R_FAILED(ret))
	{
		clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
		myprintf(mystring);
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
	if (wakeup) {
		if(actual_size >= sizeof(msg))//If no data frame is available, udsPullPacket() will return actual_size=0.
		{
			memcpy(&msg,tmpbuf,sizeof(msg));
			if (msg.sprite.speed == 101) {
				replySprite[msg.sender] = true; //need to know if they have all joined the game.
			}
		}
	}
	/*for (int i = 0; i < num_bikes; i++) {
		if (score[i] != oldscore[i]) clearFlag = true;
	}
	if (sprites[myNum].dead && !olddead) clearFlag = true;
	if (oldbikes != num_bikes) { clearFlag = true; oldbikes = num_bikes; }*/
	printScore();
	/*if (clearFlag) {
		//if (!debugging) myconsoleClear();
		printScore();
		for (int i = 0; i < num_bikes; i++) oldscore[i] = score[i];
			olddead = sprites[myNum].dead;
		clearFlag = false;
	}*/
	/*gfxFlushBuffers();
	gfxSwapBuffers();*/
	
	//Wait for VBlank
	//gspWaitForVBlank();
	// Render the scene
	if (!wakeup) { //everyone has joined the game, we can draw to the top screen now!
		bool skipPlotting = false;
		for (int b = 0; b < currentBots; b++) {
			if (sprites[getBot(b)].dead) continue;
			if (b != 0 || autoPilot) {
				skipPlotting = checkPath(b);
				if (!skipPlotting) {
					if (everyoneElseIsDead(b) && !itsATie() && getHighestScore() == b) {
						sprites[getBot(b)].dead = true;
						lastDead = b;
					}
					else if (plotting[b]) {
						continuePlotting(b);
					} else {
						if (totalPathN[b] < 1) {
							plotCourse(b);
						}
					}
				}
			}
		}
		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			//player has pressed R with it enabled
			if (options[6] && !sprites[myNum].dead && kDown & KEY_R) {
				reversePath(myNum);
				if (sprites[myNum].forwards) sprites[myNum].forwards = false;
				else sprites[myNum].forwards = true;
				msg.sprite = sprites[myNum];
				lastSprite = svcGetSystemTick();
				memset(replySprite,0,sizeof(replySprite[0]) * 10);
				UDSSend(msg);
				overwriteSprite(sprites[myNum].x , sprites[myNum].y , 2, 2, myNum);
				ignoreDeath = true; //the frame buffer isn't updated from erasing the last piece of the tail...
			}
			if (movingApple) {
				bool oldUsed = usedSpecial[0];
				changeApple();
				movingApple = false;
				usedSpecial[0] = oldUsed;
			}
			//Player has pressed Y and it is not disabled
			if (!options[5] && !options[7]) if (kDown & KEY_Y && !usedSpecial[0]) {
				usedSpecial[0] = true;
				memset(replyChange,0,sizeof(replyChange[0]) * 10);
				changeApple();
			}
			//cheats are activated and player is dragging the apple
			if (cheats && px && py) {
				drawSprite(apple.x , apple.y , 2, 2, 9);
				apple.x = (int)px;
				apple.y = (int)py;
				apple.x = apple.x;
				apple.y = apple.y;
				drawSprite(apple.x , apple.y , 2, 2, 8);
				oldpx = px;
				oldpy = py;
			} else if (oldpx && oldpy) { //player has dropped the apple
				oldpx = 0;
				oldpy = 0;
				msg.sprite.speed = 66;
				msg.sprite.x = apple.x;
				msg.sprite.y = apple.y;
				memset(replyChange,0,sizeof(replyChange[0]) * 10);
				UDSSend(msg);
				if (debugging) {
					snprintf(mystring,sizeof(mystring),"pathfindToApple: %d",pathfindToApple(myNum));
					myprintf(mystring);
				}
			}
			sceneRender();
			moveSprites();
			if(actual_size >= sizeof(msg))//If no data frame is available, udsPullPacket() will return actual_size=0.
			{
				//Message msg;
				memcpy(&msg,tmpbuf,sizeof(msg));
				//if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"sender: %d image: %d speed: %d diag: %d",msg.sender,msg.sprite.image, msg.sprite.speed,msg.sprite.diag); myprintf(mystring); }
				if (msg.sprite.speed == 101 && msg.sender == 0) { UDSSend(msg); } //host is making sure we joined the game.
				else if (msg.sprite.speed == 999) { //quit message
					errorQuit = 0;
					if (msg.sender == msg.sprite.node && msg.sender == msg.sprite.image) {
						for (int i = 0; i < num_bikes; i++) {
							if (sprites[i].node == msg.sprite.node) { quit = i; break; }
						}
						memset(quitName,0,sizeof(quitName));
						snprintf(quitName,sizeof(quitName),"%s",msg.sprite.username);
						
			
						for (int i = 0; i < num_bikes; i++) {
							sprites[i].dead = true;
						}
						msg.sprite.image = msg.sprite.node;
						msg.sprite.node = myNode;
						UDSDirect(msg.sprite.image,msg);
						popScene(); 
						C3D_FrameEnd(0);
						pushScene(roundEnd_init,roundEnd_update,NULL,NULL);
						return;
					}
				}
				else if (msg.sprite.speed == 2020) { } // ignore
				else if (msg.sprite.speed == 1111) { //join message
					sprites[msg.sprite.image] = msg.sprite;
					if (myNum == 0 && msg.sprite.image == msg.sender) {
						msg.sprite = sprites[msg.sprite.image];
						msg.sprite.image = actual_bikes;
						msg.sprite.speed = 1011;
						msg.sprite.dead = true;
						sprites[num_bikes] = msg.sprite;
						oldbikes = 0;
						UDSSend(msg);
					}
				}
				else if (msg.sprite.speed == 5050) {} //ignore
				else if (msg.sprite.speed == 123) {} //ignore
				else if (msg.sprite.speed == 1011 && myNum != 0) {} // ignore
				else if (msg.sprite.speed == 66) { //change apple message
					if (msg.sprite.image == myNum) { 
						if (msg.timestamp == lastChange) replyChange[msg.sender] = true; 
						else if (debugging) { 
							clearString(); 
							snprintf(mystring,sizeof(mystring),"replyChange from %d: 0x%" PRIx64 " != 0x%" PRIx64,msg.sender,msg.timestamp,lastChange); 
							myprintf(mystring); 
						} 
					}
					else if (msg.sender == msg.sprite.image) { 
						UDSDirect(msg.sprite.node,msg); 
						if (debugging) myprintf("changing apple..."); 
						if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) updateApple(msg.sprite.x,msg.sprite.y); 
					}
				}
				else if (msg.sprite.speed == 77) { //scored a point message
					if (msg.sprite.image == myNum) { 
						if (msg.timestamp == lastScore) replyScore[msg.sender] = true; 
						else if (debugging) { 
							clearString(); 
							snprintf(mystring,sizeof(mystring),"replyScore from %d: 0x%" PRIx64 " != 0x%" PRIx64,msg.sender,msg.timestamp,lastScore); 
							myprintf(mystring); 
						} 
					}
					else if (msg.sender == msg.sprite.image) { 
						UDSDirect(msg.sprite.node,msg); 
						if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) { 
							sprites[msg.sprite.image].length = msg.sprite.length; 
							setApple(msg.sprite.image, msg.sprite.x, msg.sprite.y); 
						} 
						score[msg.sprite.image] = msg.sprite.dx; 
					}
				}
				else if (msg.sprite.image == myNum) { if (msg.sprite.speed == 1001) { popScene(); pushScene(roundEnd_init,roundEnd_update,NULL,NULL); return; } if (msg.timestamp == lastSprite) replySprite[msg.sender] = true;  else if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"replySprite from %d: 0x%" PRIx64 " != 0x%" PRIx64,msg.sender,msg.timestamp,lastSprite); myprintf(mystring);} }
				else if (msg.sprite.speed == 1001) {} //ignore.
				else {
					
					
					if (msg.sprite.image > num_bikes) { //someone has joined and we missed it...
						num_bikes = msg.sprite.image + 1; 
						for (int i = actual_bikes; i < NUM_SPRITES; i++) { 
							sprites[i].dead = true; 
						} 
						if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
						if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
						if (sprites[myNum].dead) { 
							sprites[myNum].image = myNum; 
							sprites[myNum].node = myNode; 
							msg.sprite = sprites[myNum]; 
							replySprite[num_bikes - 1] = false; 
							UDSSend(msg); 
						} 
					}
					if (msg.sprite.image == num_bikes) { //someone has joined and we missed it
						sprites[num_bikes].dead = true; 
						if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
						if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
						num_bikes++; 
						if (sprites[myNum].dead) { 
							sprites[myNum].image = myNum; 
							sprites[myNum].node = myNode; 
							msg.sprite = sprites[myNum]; 
							replySprite[num_bikes - 1] = false; 
							UDSSend(msg); 
						} 
					}
					//this is someone's movement. lets update their sprite information
					if (msg.sender == msg.sprite.image) UDSDirect(msg.sprite.node,msg);
					if (msg.sprite.dead && options[9]) eraseLine(msg.sprite.image);
					int img = msg.sprite.image;
					//they haven't gone in reverse yet.
					//let's clean up any graphical artifacts and fill any holes from teleporting
					if (sprites[img].forwards == msg.sprite.forwards) if (msg.sprite.image < actual_bikes && msg.sender == msg.sprite.image) {
						
						if (abs(currentPath[img] - pathPos[img]) >= 10) {
							
							if (msg.sprite.dead && !options[9]) {
								lastDead = msg.sprite.image;
								eraseOvershoot(msg.sprite);
							}
							else if (!msg.sprite.dead) finishLine(currentPath[img],sprites[img].x, sprites[img].y, msg.sprite.x, msg.sprite.y, msg.sprite, img);
						}
					}
					//this is definitely a message of movement change
					if (msg.sender == msg.sprite.image) {
						//they sent a message showing they have gone in reverse
						if (msg.sprite.forwards != sprites[msg.sprite.image].forwards) {
							reversePath(msg.sprite.image);
							int cp = currentPath[img];
							int x = path[cp][img].x;
							int y = path[cp][img].y;
							int cx = 0;
							int cy = 0;
							if ((path[cp][img].y ) == (msg.sprite.y )) {
								if ((path[cp][img].x ) < (msg.sprite.x )) cx = 2;
								else cx = -2;
							} else if ((path[cp][img].x ) == (msg.sprite.x )) {
								if ((path[cp][img].y ) < (msg.sprite.y )) cy = 2;
								else cy = -2;
							}
							int i = 0;
							if (!msg.sprite.dead) {
								if (x == (msg.sprite.x ) || y == (msg.sprite.y )) while ((path[cp][img].x ) != (msg.sprite.x ) || (path[cp][img].y ) != (msg.sprite.y )) {
									overwriteSprite(x, y, 2, 2, img);
									cp++;
									x += cx;
									y += cy;
									if (cp >= 120 * 200) cp = 0;
									path[cp][img].x = x;
									path[cp][img].y = y;
									i++;
								}
								overwriteSprite(x , y , 2, 2, img);
								currentPath[img] = cp;
							}
						}
						sprites[msg.sprite.image] = msg.sprite;
					}
					if (everyoneElseIsDead(myNum)) {
						//if it's No apple mode...
						if (options[7] && !sprites[myNum].dead) {
							lastDead = myNum;
							sprites[myNum].dead = true;
							msg.sprite = sprites[myNum];
							memset(replySprite,0,sizeof(replySprite[0]) * 10);
							lastSprite = svcGetSystemTick();
							UDSSend(msg);
						}
						//or it's normal, and we have the highest score while everyone else is dead...
						else if (getHighestScore() == myNum && allReplied(replyScore)) { lastDead = myNum; sprites[myNum].dead = true; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); lastSprite = svcGetSystemTick(); UDSSend(msg); }
					}
				}
			}
			//redraw the apple, it has moved
			if (oldApplex != apple.x && oldAppley != apple.y) { 
				drawSprite(apple.x , apple.y , 2, 2, 8);
				oldApplex = apple.x;
				oldAppley = apple.y;
			}
		C3D_FrameEnd(0);
		gfxFlushBuffers();
		/*gfxFlushBuffers();
		gfxSwapBuffers();*/
	}
	keepConsole();
	if (everyoneElseIsDead(myNum)) {
		//no apple mode
		if (options[7] && !sprites[myNum].dead) {
			lastDead = myNum;
			sprites[myNum].dead = true;
			msg.sprite = sprites[myNum];
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick();
			UDSSend(msg);
		}
		//its normal
		else if (!itsATie() && getHighestScore() == myNum && allReplied(replyScore)) { lastDead = myNum; sprites[myNum].dead = true; sprites[myNum].node = myNode; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); lastSprite = svcGetSystemTick(); UDSSend(msg); }
	}
	if (everyoneElseIsDead(myNum) && sprites[myNum].dead) {
		popScene(); pushScene(roundEnd_init,roundEnd_update,NULL,NULL); return;
	}
}
void prepare_room_update() {
	snprintf(mystring,sizeof(mystring),"\x1b[0;0H%sPreparing room...",loading[load]);
	myprintf(mystring);
	if (svcGetSystemTick() - lastLoad > TICKS_PER_MS * 30) { load++; lastLoad = svcGetSystemTick(); }
	if (load > 7) load = 0;
	keepConsole();
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_START) {
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
	memset(tmpbuf, 0, tmpbuf_size);
	actual_size = 0;
	src_NetworkNodeID = 0;

	if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
	{
		

		//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
		ret = udsGetConnectionStatus(&constatus);
		if(R_FAILED(ret))
		{
			clearString(); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			return;
		}
		else
		{
			if (constatus.total_nodes >= num_bikes) {
				ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
				if (constatus.total_nodes >= num_bikes) {
					memset(sprites[num_bikes].username,0,sizeof(sprites[num_bikes].username));
					udsGetNodeInfoUsername(&tmpnode,sprites[num_bikes].username);
					if (!sprites[num_bikes].node) sprites[num_bikes].node = constatus.total_nodes;
					connectionEstablished = true;
					currentBots = 1;
					clearString(); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
					myprintf(mystring);
				}
			} else {
				myprintf("Lost one!");
			}
			num_bikes = constatus.total_nodes;
			if (num_bikes == 1) currentBots = numOpponents;

		}
	}
	if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
	if(R_FAILED(ret))
	{
		clearString(); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
		myprintf(mystring);
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
	if(actual_size >= sizeof(msg))//If no data frame is available, udsPullPacket() will return actual_size=0.
	{
		memcpy(&msg,tmpbuf,sizeof(msg));
		if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"speed: %d image: %d",msg.sprite.speed, msg.sprite.image); myprintf(mystring); }
		if (msg.sprite.speed == 100) replySprite[msg.sender] = true;
		else if (msg.sprite.speed == 777) {} //ignore
		else if (msg.sprite.speed == 123) {} //ignore
		else if (msg.sprite.speed == 66) replyChange[msg.sender] = true;
		else if (msg.sprite.speed == 1111) { if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"Accepting request to join...(%d)",msg.sender); myprintf(mystring); } sprites[msg.sender].node = msg.sprite.node; replyChange[msg.sender] = false; replySprite[msg.sender] = false; sprites[msg.sender].speed = 1211; msg.sprite = sprites[msg.sender]; UDSSend(msg); } 
		else if (msg.sprite.speed == 999) { pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish); return; } //player quit
	}
	if (allReplied(replySprite) && allReplied(replyChange)) {
		if (debugging) myprintf("Starting game...");
		popScene(); //pop this scene
		popScene(); //pop send_bike
		pushScene(game_init,game_update,NULL,NULL); //go to game
		msg.sprite = sprites[myNum];
		msg.sprite.image = 0;
		msg.sprite.speed = 101;
		UDSSend(msg);
		memset(replySprite,0,sizeof(replySprite[0]) * 10);
		lastSprite = svcGetSystemTick();
		wakeup = true;
	} else if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 30 * lagMult()) {
		popScene(); //go back to previous scene. we need to resend information
	} else if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
		popScene(); //go back to previous scene, we need to resend information
	}
}
void prepare_room_finish() {
	gspWaitForVBlank();
}

void connect_update() {
	if(total_networks && !hosting)
	{

		if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"network: total nodes = %u.", (unsigned int)network->network.total_nodes); myprintf(mystring); }


		/*for(u32 pos=0; pos<NUM_SPRITES; pos++)
		{
			if(!udsCheckNodeInfoInitialized(&network->nodes[pos]))continue;

			memset(tmpstr, 0, sizeof(tmpstr));

			ret = udsGetNodeInfoUsername(&network->nodes[pos], tmpstr);
			if(R_FAILED(ret))
			{
				clearString(); snprintf(mystring,sizeof(mystring),"udsGetNodeInfoUsername() returned 0x%08x.", (unsigned int)ret);
				myprintf(mystring);
				pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
				free(networks);
				popScene();
				return;
			}

			if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"node%u username: %s", (unsigned int)pos, tmpstr); myprintf(mystring); }
		}*/
		u32 pos = 0;
		for(pos=0; pos<10; pos++)
		{
			ret = udsConnectNetwork(&network->network, passphrase, strlen(passphrase)+1, &bindctx, UDS_BROADCAST_NETWORKNODEID, conntype, 1, recv_buffer_size);
			if(R_FAILED(ret))
			{
				clearString(); snprintf(mystring,sizeof(mystring),"udsConnectNetwork() returned 0x%08x.", (unsigned int)ret);
				myprintf(mystring);
				pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
				return;
			}
			else
			{
				break;
			}
		}

		free(networks);

		if(pos==10) { was_in_game = true; popScene(); return; }

		myprintf("Connected.");


		/*tmp = 0;
		ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
		if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"udsGetChannel() returned 0x%08x. channel = %u.", (unsigned int)ret, (unsigned int)tmp); myprintf(mystring); }
		if(R_FAILED(ret))
		{
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			return;
		}*/
		con_type = 1;
	}
	if (hosting && !network_created)
	{
		if (uds_enabled) {
			udsGenerateDefaultNetworkStruct(&networkstruct, wlancommID, 0, 8); //only have room for 8 players.

			myprintf("Creating the network...");
			ret = udsCreateNetwork(&networkstruct, passphrase, strlen(passphrase)+1, &bindctx, 1, recv_buffer_size);
			if(R_FAILED(ret))
			{
				failure = (u32)ret;
				clearString(); snprintf(mystring,sizeof(mystring),"udsCreateNetwork() returned 0x%08x.", (unsigned int)ret);
				myprintf(mystring);
				pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
				return;
			}
			network_created = true;

			/*tmp = 0;
			ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
			if (debugging) { clearString(); snprintf(mystring,sizeof(mystring),"udsGetChannel() returned 0x%08x. channel = %u.", (unsigned int)ret, (unsigned int)tmp); myprintf(mystring); }
			if(R_FAILED(ret))
			{
				udsDestroyNetwork();
				udsUnbind(&bindctx);
				pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
				return;
			}*/
		}
		con_type = 0;
		myNum = 0;
	}
	if(tmpbuf==NULL)
	{
		myprintf("Failed to allocate tmpbuf for receiving data.");

		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		was_in_game = true;
		return;
	}
	if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
	{
		if (debugging) myprintf("Constatus event signaled.");
		ret=0;
		

		//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
		ret = udsGetConnectionStatus(&constatus);
		if(R_FAILED(ret))
		{
			clearString(); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
			return;
		}
		else
		{
			myNode = constatus.cur_NetworkNodeID;
			sprites[myNum].node = myNode;
			memset(tmpstr, 0, sizeof(tmpstr));
			ret = udsGetNodeInformation(constatus.cur_NetworkNodeID,&tmpnode);
			ret = udsGetNodeInfoUsername(&tmpnode,tmpstr);
			if (strlen(overwriteName) == 0) snprintf(myName,sizeof(myName),"%s",tmpstr);
			else snprintf(myName,sizeof(myName),"%s",overwriteName);

			if (!hosting) {
				popScene(); //leave this scene
				pushScene(send_request_init,send_request_update,NULL,NULL); //go to send_request
				return;
			}
		}

	}

	popScene();
	pushScene(setup_init,setup_update,NULL,NULL);
}
void scan_finish() {
	keepConsole();
	if (total_networks == 1) {
		if (network->network.total_nodes >= 8) {
			readyToJoin = false;
			myconsoleClear();
			myprintf("Only one room was found and it was full!");
			myprintf("Press A to go back to main menu");
			popScene(); 
			pushScene(NULL,displayMessage,NULL,displayMessageFinish);
			return;
		}
	}
	if (total_networks > 1) {
		pushScene(choose_network_init,choose_network_update,NULL,NULL);
		return;
	}
	myconsoleClear();
	if (readyToJoin) { popScene(); pushScene(NULL,connect_update,NULL,NULL); return; }
	else {
		popScene(); //nothing found
	}
}
void start_screen_update() {
	hidScanInput();
	u32 kDown = hidKeysDown();
	u32 kHeld = hidKeysHeld();



	//myprintf("Version %sHold A to hostPress B to scan for a host.Press Y to change name.Press X for QRCode to latest release.Press START to exit.",VERSION);
	// Respond to user input
	if (kDown & KEY_START) { popScene(); return; }
	if (kDown & KEY_SELECT) { pushScene(options_menu_init,options_menu_update,options_menu_draw,options_menu_finish); return; }
	if (kDown & KEY_L) { debugging = true; myprintf("Debugging turned on."); }
	if (kDown & KEY_A) { hosting = 1; pushScene(NULL,connect_update,NULL,NULL); return; }
	if (kHeld & KEY_R && kDown & KEY_X) { cheats = true; myprintf("Move the apple with touchscreen!"); snprintf(overwriteName,sizeof(overwriteName),"Cheater"); }
	if (kHeld & KEY_R && kDown & KEY_Y) { highScore = 0; writeUsername(); myprintf("Reset high score."); }
	else if (kDown & KEY_X) qrcode = true;
	else if (kDown & KEY_Y) {
		if (!cheats) {
			static SwkbdState swkbd;
			static char mybuf[50];
			static SwkbdStatusData swkbdStatus;
			static SwkbdLearningData swkbdLearning;
			SwkbdButton button = SWKBD_BUTTON_NONE;
			swkbdInit(&swkbd, SWKBD_TYPE_NORMAL, 3, -1);
			swkbdSetValidation(&swkbd, SWKBD_NOTEMPTY_NOTBLANK, 0, 0);
			swkbdSetFilterCallback(&swkbd, wrongName, NULL);
			swkbdSetInitialText(&swkbd, mybuf);
			swkbdSetHintText(&swkbd, "Please enter your name");
			swkbdSetButton(&swkbd, SWKBD_BUTTON_LEFT, "Cancel", false);
			
			swkbdSetButton(&swkbd, SWKBD_BUTTON_RIGHT, "Done", true);
			swkbdSetFeatures(&swkbd, SWKBD_PREDICTIVE_INPUT);
			SwkbdDictWord words[21];
			swkbdSetDictWord(&words[0], "put table back", "┬──┬ ノ( ゜-゜ノ)");
			swkbdSetDictWord(&words[1], "shrug", "¯\\_(ツ)_/¯");
			swkbdSetDictWord(&words[2], "flip", "(ノ°□°）ノ ~ ┻━┻");
			swkbdSetDictWord(&words[3], "happy", "( ﾟヮﾟ)");
			swkbdSetDictWord(&words[4], "glasses", "(-■_■)");
			swkbdSetDictWord(&words[5], "kiss", "(づ￣ ³￣)づ");
			swkbdSetDictWord(&words[6], "fuck", "凸(-_-)凸");
			swkbdSetDictWord(&words[7], "pig", "（´・ω・ `）");
			swkbdSetDictWord(&words[8], "sun", "");
			swkbdSetDictWord(&words[9], "cloud", "");
			swkbdSetDictWord(&words[10], "umbrella", "");
			swkbdSetDictWord(&words[11], "telephone", "☎");
			swkbdSetDictWord(&words[12], "spade", "♠");
			swkbdSetDictWord(&words[13], "heart", "♥");
			swkbdSetDictWord(&words[14], "clubs", "♣");
			swkbdSetDictWord(&words[15], "diamond", "♦");
			swkbdSetDictWord(&words[16], "happyface", "");
			swkbdSetDictWord(&words[17], "angry", "");
			swkbdSetDictWord(&words[18], "sad", "");
			swkbdSetDictWord(&words[19], "sleepy", "");
			swkbdSetDictWord(&words[20], "snowman", "");

			swkbdSetDictionary(&swkbd, words, sizeof(words)/sizeof(SwkbdDictWord));
			static bool reload = false;
			swkbdSetStatusData(&swkbd, &swkbdStatus, reload, true);
			swkbdSetLearningData(&swkbd, &swkbdLearning, reload, true);
			reload = true;
			button = swkbdInputText(&swkbd, mybuf, sizeof(mybuf));
			if (button != SWKBD_BUTTON_NONE && strlen(mybuf) > 0) { 
				memset(overwriteName,0,sizeof(overwriteName));
				snprintf(overwriteName,sizeof(overwriteName),"%s",mybuf);
				clearString(); snprintf(mystring,sizeof(mystring),"Welcome, %s",overwriteName);
				myprintf(mystring);
				writeUsername();
			} else {
				memset(overwriteName,0,sizeof(overwriteName));
				myprintf("Name set to default.");
				writeUsername();
			}
		} else myprintf("You can't change your name with cheats enabled!");
	}
	else if (!ignoreB) if(kDown & KEY_B) {
		ignoreB = true;
		pushScene(scan_init,scan_update,NULL,NULL);
		return;
	}
	ignoreB = false;
}
void wait_for_player_init() { 
	hidScanInput();
	u32 kUp = hidKeysUp();
	u32 kHeld = hidKeysHeld();
	myconsoleClear();
	if (!connectionEstablished) {
		myprintf("Waiting for connection...");
		myprintf("Let go of A to play by yourself.");
	}
	if (!((kHeld & KEY_A) && !(kUp & KEY_A))) popScene();
}
void wait_for_player_update() {
	keepConsole();
	hidScanInput();

	u32 kDown = hidKeysDown();
	u32 kUp = hidKeysUp();
	if(kDown & KEY_START) {
		pushScene(failure_message_init,failure_message_update,NULL,failure_message_finish);
		return;
	}
	if (kUp & KEY_A) { popScene(); return; }
	if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
	{
		setSprites();
		connectionEstablished = true;
		
		ret = udsGetConnectionStatus(&constatus);
		ret = udsGetNodeInformation(0x1,&tmpnode);
		memset(sprites[0].username,0,sizeof(sprites[0].username));
		udsGetNodeInfoUsername(&tmpnode,sprites[0].username);
		ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
		if (constatus.total_nodes >= num_bikes) {
			memset(sprites[num_bikes].username,0,sizeof(sprites[num_bikes].username));
			udsGetNodeInfoUsername(&tmpnode,sprites[num_bikes].username);
			sprites[num_bikes].node = constatus.total_nodes;
			currentBots = 1;
			clearString(); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
			myprintf(mystring);
			num_bikes = constatus.total_nodes;
		}
		popScene();
		return;
	}
}
void testInit() {
	myconsoleClear();
	myprintf("Uhhhhh....");
}
void testUpdate() {
	hidScanInput();
	u32 kDown = hidKeysDown();
	if (kDown & KEY_A) {
		popScene();
		return;
	}
	keepConsole();
}
void testFinish() {
	myconsoleClear();
}
//---------------------------------------------------------------------------------
int main(int argc, char **argv) {
//---------------------------------------------------------------------------------
	srand(time(NULL));
	// Initialize graphics
	gfxInitDefault();
	C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);

	// Output at 100% on the first pair of left and right channels.


	// Initialize the render target
	target = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	target2 = C3D_RenderTargetCreate(240, 320, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target2, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target2, GFX_BOTTOM, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	bool check = false;
	ret = APT_CheckNew3DS(&check);
	if (!check) patchConsole = true;
	Result res = fontEnsureMapped();

	if (R_FAILED(res))
		return 1;
	//consoleInit(GFX_BOTTOM, NULL); //Print to bottom screen
	// Initialize the scene
	sceneInit();
	sdmcInit();
	pushScene(start_screen_init,start_screen_update,start_screen_draw,NULL);
	ret = udsInit(0x3000, NULL);//The sharedmem size only needs to be slightly larger than the total recv_buffer_size for all binds, with page-alignment.
	if(R_FAILED(ret))
	{
		uds_enabled = false;
		if (ret == 0xc9411002) {
			myprintf("Wi-Fi must be turned on local play!");
			myprintf("Be sure you switch your wifi on");
			myprintf("For old 3ds, its the switch on the right");
			myprintf("\x1b[6;0HPress A or START to play offline.");
		}
		else {
			clearString(); snprintf(mystring,sizeof(mystring),"udsInit failed: 0x%08x.Press A or START to play offline.", (unsigned int)ret);
			myprintf(mystring);
		}
		pushScene(NULL,displayMessage,NULL,displayMessageFinish);
	}
	else uds_enabled = true;

	beacon_size = 0x4000;
	beacon_msg = malloc(beacon_size);
	if (beacon_msg == NULL) {
		myprintf("Unable to allocate memory for beacon data.");
		myprintf("Unable to join games properly!");
		pushScene(NULL,displayMessage,NULL,displayMessageFinish);
	}

	tmpbuf_size = UDS_DATAFRAME_MAXSIZE;
	tmpbuf = malloc(tmpbuf_size);
	if (tmpbuf == NULL) {
		myprintf("Unable to allocate memory for local play messages.");
		pushScene(NULL,displayMessage,NULL,displayMessageFinish);
	}
	while (aptMainLoop()) {
		if (scenes == NULL) break;
		if (oldScene != scenes || !scenes->initialized) {
			scenes->initialized = false;
			oldScene = scenes;
			scenes->initialized = true;
			if (scenes->init != NULL) scenes->init();
		}
		if (oldScene != scenes) continue;
		if (scenes->update != NULL) scenes->update();
		if (scenes == NULL) break;
		if (oldScene != scenes) continue;
		if (scenes->draw != NULL) scenes->draw();
		if (CATASTROPHIC_FAILURE) {
			clearScenes();
			if (ret == 0xc8a113ea || ret == 0xd8e007f7) {
				disconnectNetwork(); 
				udsExit();
				udsInit(0x3000, NULL);
			}
			else if (uds_enabled) {
				disconnectNetwork();
				myNum = 0;
				currentBots = numOpponents + 1;
				num_bikes = 1;
				was_in_game = false;
				network = NULL;
				networks = NULL;
			}
			pushScene(start_screen_init,start_screen_update,start_screen_draw,NULL);
			CATASTROPHIC_FAILURE = false;
		}
	}
	clearScenes();
	if (tmpbuf != NULL) {
		free(tmpbuf);
		tmpbuf = NULL;
	}
	if (beacon_msg != NULL) {
		free(beacon_msg);
		beacon_msg = NULL;
	}
	if (uds_enabled) disconnectNetwork();
	udsExit();


	// Deinitialize the scene
	sceneExit();

	// Deinitialize graphics
	C3D_Fini();
	gfxExit();
	return 0;
}
