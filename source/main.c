/*

	Simple demo of sprites using citro3d, lodepng and immediate mode.

	Citra doesn't yet emulate immediate mode so this is hw only.

*/

#include <3ds.h>
#include <citro3d.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <errno.h>
#include <stdarg.h>
#include <unistd.h>

#include "lodepng.h"

// These headers are generated by the build process
#include "vshader_shbin.h"
#include "splash_png.h"
#include "bike_png.h"


#define TICKS_PER_MS 268123
#define TICKS_PER_SEC 268123480
#define CLEAR_COLOR 0x000000FF

#define MOVE_UP 1
#define MOVE_DOWN 2
#define MOVE_LEFT 3
#define MOVE_RIGHT 4
#define TYPE_DEATH 5

#define NORTHEAST 1
#define SOUTHEAST 2
#define SOUTHWEST 3
#define NORTHWEST 4


// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGBA8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

#define NUM_SPRITES 10


#define SAMPLERATE 22050
#define SAMPLESPERBUF (SAMPLERATE / 30)
#define BYTESPERSAMPLE 4



u64 waitForFinish = 0;
bool uds_enabled = false;
bool readyToStart = false;
bool debugging = false;

int diag = 0;
circlePosition oldCPos;
int wakeup = false;
int myNode = 0;
bool CATASTROPHIC_FAILURE = false;
bool inGame = false;
u16 src_NetworkNodeID;
udsBindContext bindctx;
u64 errorQuit = 0;
bool clearFlag = true;
char myName[50];
char overwriteName[50];
int quit = -1;
u32 dead;
u32 dead2;
bool addedToGame = true;
u64 lastSent = 0;
u64 UDSSent = 0;


bool replay = true;
bool connectionEstablished = false;
udsConnectionStatus constatus;

int oldDiag = 0;
u32 nextMove = NULL;
u32 oldMove = NULL;
bool usedSpecial = false;
u32 death = 0;
int myNum = 0;
int growthRate = 40;
int growth[10] = {40,40,40,40,40,40,40,40,40,40};

u32 pathPos[10] = {0,0,0,0,0,0,0,0,0,0};
u32 currentPath[10] = {1,1,1,1,1,1,1,1,1,1};

bool ready[10] = {false, false, false, false, false, false, false, false, false, false};

int bikeSpeed = (2 << 8);
void fill_buffer(void* audioBuffer, size_t offset, size_t size, int frequency) {
	u32* dest = (u32*) audioBuffer;

	for (int i = 0; i < size; i++) {
		// This is a simple sine wave, with a frequency of `frequency` Hz, and an amplitude 30% of maximum.
		s16 sample = 0.3 * 0x7FFF * sin(frequency * (2 * M_PI) * (offset + i) / SAMPLERATE);

		// Stereo samples are interleaved: left and right channels.
		dest[i] = (sample << 16) | (sample & 0xffff);
	}

	DSP_FlushDataCache(audioBuffer, size);
}
//simple sprite struct
typedef struct {
	int x,y;			// screen co-ordinates 
	int dx, dy;			// velocity
	int image;
	int speed;
	int length;
	bool dead;
	int node;
	int diag;
	char username[50];
}Sprite;

typedef struct {
	int x, y;
}Path;

Path path[400 * 240][10];

typedef struct {
	int x, y;
}Apple;

typedef struct {
	Sprite sprite;
	u64 timestamp;
	int sender;
}Message;

int actual_bikes = 1;
Message sentMsg;
u64 lastScore;
u64 lastChange;
u64 lastSprite;
bool replyDead[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyChange[10] = {0,0,0,0,0,0,0,0,0,0};
bool replySprite[10] = {0,0,0,0,0,0,0,0,0,0};

udsNodeInfo tmpnode;
Result ret=0;


u32 gameOver = 0;
Apple apple;
Message msg;
udsConnectionType conntype;

int num_bikes = 1;
Sprite sprites[NUM_SPRITES];

u32 con_type = 0;


C3D_RenderTarget* target;


u64 frameTicks[10];

int score[10] = {0,0,0,0,0,0,0,0,0,0};
int oldscore[10];

int joinedNum = 0;
int oldbikes;

u8* frameBuf;
int getLength(int num) {
	if (currentPath[num] < pathPos[num]) return ((400 * 240) - pathPos[num]) + currentPath[num];
	else return currentPath[num] - pathPos[num];
}

struct { float left, right, top, bottom; } images[11] = {
	{0.0f, 0.25f, 0.0f, 0.25f}, //bikes
	{0.25f, 0.5f, 0.0f, 0.25f},
	{0.5f, 0.75f, 0.0f, 0.25f},
	{0.75f, 1.0f, 0.0f, 0.25f},
	{0.0f, 0.25f, 0.25f, 0.5f},
	{0.25f, 0.5f, 0.25f, 0.5f},
	{0.5f, 0.75f, 0.25f, 0.5f},
	{0.75f, 1.0f, 0.25f, 0.5f},
	{0.0f, 0.5f, 0.5f, 1.0f}, //apple
	{0.5f, 1.0f, 0.5f, 1.0f}, //erase
	{0.0f, 1.0f, 0.0f, 1.0f}, //splash screen
};
u32 colors[10] = { 0x000cff00, 0x00e4ff00, 0x00004eff, 0x00fc00ff, 0x0000fff0, 0x0025722c, 0x00ff9600, 0x00ff7f82, 0x00ffffff, 0x00000000 };
#define ESC(x) "\x1b[" #x
#define RED     ESC(31;1m)
#define GREEN   ESC(32;1m)
#define YELLOW  ESC(33;1m)
#define BLUE    ESC(34;1m)
#define MAGENTA ESC(35;1m)
#define CYAN    ESC(36;1m)
#define WHITE   ESC(37;1m)
char textColors[8][12] = {GREEN, YELLOW, BLUE, MAGENTA, CYAN, GREEN, YELLOW, RED};
char colorNames[8][12] = {"Green", "Yellow", "Blue", "Magenta", "Cyan", "Dark Green", "Orange", "Pink"};



u32 getColor(int x, int y) {
	if (x > 400) x = 0;
	else if(x < 0) x = 400;
	if (y > 240) y = 0;
	else if (y < 0) y = 240;
	u32 offset = ((x * 240) - y + 239) * 3;
	return (u32) (frameBuf[offset] | frameBuf[offset + 1]  << 8 | frameBuf[offset  + 2] << 16);
}
//---------------------------------------------------------------------------------
void drawSprite( int x, int y, int width, int height, int image ) {
//---------------------------------------------------------------------------------
	u32 color = getColor(x,y);
	if (image != 10) if (image != 9 && color != colors[8] && color) return;
	float left = images[image].left;
	float right = images[image].right;
	float top = images[image].top;
	float bottom = images[image].bottom;

	// Draw a textured quad directly
	C3D_ImmDrawBegin(GPU_TRIANGLES);
		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( left, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);


	C3D_ImmDrawEnd();

}

static DVLB_s* vshader_dvlb;
static shaderProgram_s program;
static int uLoc_projection;
static C3D_Mtx projection;


static C3D_Tex spritesheet_tex;
static C3D_Tex splash_tex;
static int lagMult() {
	if (num_bikes <= 2) return 1;
	return (num_bikes - 2);
}
u32 timeDiff(int num) {
	return (u32)((svcGetSystemTick() - frameTicks[num]) / TICKS_PER_MS / sprites[num].speed);
}
static void UDSResend(bool replied[], Message msg) {
	if (!uds_enabled) return;
	msg.sender = myNum;
	sentMsg = msg;
	ret=0;
	if (msg.sprite.speed == 77) msg.timestamp = lastScore;
	else if (msg.sprite.speed == 66) msg.timestamp = lastChange;
	else msg.timestamp = lastSprite;
	if(conntype!=UDSCONTYPE_Spectator)
	{
		for (int i = 0; i < num_bikes; i++) {
			if (debugging) printf("resending to... %d: %d\n",i,sprites[i].node);
			if (!replied[i] && i != myNum && sprites[i].node) {
				ret = udsSendTo(sprites[i].node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
				if (UDS_CHECK_SENDTO_FATALERROR(ret))
				{
					if (debugging) printf("Error: UDSResend() returned 0x%08x.\n",(unsigned int)ret);
				}
			}
		}
	}
}
static bool allReplied(bool replied[]) {
	for (int i = 0; i < num_bikes; i++) {
		if (!replied[i] && i != myNum) return false;
	}
	return true;
}
static int UDSDirect(int node, Message msg) {
	msg.sender = myNum;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		ret = udsSendTo(node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			printf("Error: UDSSend() returned 0x%08x.\n", (unsigned int)ret);
			CATASTROPHIC_FAILURE = true;
			return 1;
		}
	}
	return 0;
}
static int UDSSend(Message msg) {
	if (!uds_enabled) return;
	msg.sender = myNum;
	if (debugging) printf("sending speed: %d image: %d diag: %d",msg.sprite.speed,msg.sprite.image,msg.sprite.diag);
	if (msg.sprite.image == myNum && msg.sprite.speed == 77) { memset(replySprite,0,sizeof(replyScore[0]) * 10); lastScore = svcGetSystemTick(); msg.timestamp = lastScore; }
	else if (msg.sprite.image == myNum && msg.sprite.speed == 66) { memset(replySprite,0,sizeof(replyScore[0]) * 10); lastChange = svcGetSystemTick(); msg.timestamp = lastChange; }
	else if (msg.sprite.image == myNum) { memset(replySprite,0,sizeof(replySprite[0]) * 10); lastSprite = svcGetSystemTick(); msg.timestamp = lastSprite; }
	else if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.sprite.node == myNode) { msg.timestamp = lastSprite; msg.sender = myNode; }
	sentMsg = msg;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		ret = udsSendTo(UDS_BROADCAST_NETWORKNODEID, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			printf("Error: UDSSend() returned 0x%08x.\n", (unsigned int)ret);
			CATASTROPHIC_FAILURE = true;
			return 1;
		}
	}
	return 0;
}
bool itsATie() {
	int s = score[0];
	int winner = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] > s) { s = score[i]; winner = i; }
	}
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] == s && i != winner) return true;
	}
	return false;
}
int getHighestScore() {
	int highestScore = 0;
	if (itsATie()) return -1;
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] > highestScore) {
			highestScore = score[i];
			r = i;
		}
	}
	return r;
}
int theHighest() {
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (r < score[i]) r = score[i];
	}
	return r;
}
bool everyoneElseIsDead() {
	if (actual_bikes <= 1) {
		if (sprites[0].dead) return true;
		return false;
	}
	for (int i = 0; i < num_bikes; i++) {
		if (i != myNum && !sprites[i].dead) return false;
	}
	return true;
}
bool allReady() {
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) return false;
	}
	return true;
}
int notReadies() {
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) r++;
	}
	return r;
}
int getKiller(u32 color) {
	for (int i = 0; i < NUM_SPRITES; i++) {
		if (color == colors[i]) return i;
	}
	return 0;
}
bool hasCommonY(int num) {
	if (sprites[num].y < (1 << 8) || sprites[num].y > (398 << 8)) return true;
	if (abs((sprites[num].y >> 8) - (apple.y >> 8)) < 3) return true;
	for (int i = 0; i < num; i++) {
		if (abs((sprites[i].y >> 8) - (sprites[num].y >> 8)) < 3) return true;
	}
	return false;
}
static void setSprites() {
	srand(time(NULL));
	usedSpecial = false;
	memset(path, 0, sizeof(path[0][0]) * 240 * 400 * 10);
	for(int i = 0; i < NUM_SPRITES; i++) {
		//random place and speed
		apple.x = (rand() % (400 - 32)) << 8;
		apple.y = (rand() % (240 - 32)) << 8;
		sprites[i].x = (rand() % (400 - 32 )) << 8;
		sprites[i].y = (rand() % (240 - 32 )) << 8 ;
		while (hasCommonY(i)) {
			sprites[i].y = (rand() % (240 - 32 )) << 8 ;
		}
		sprites[i].dx = (2<<8);
		sprites[i].dy = 0;
		sprites[i].image = i;
		sprites[i].speed = 45;
		sprites[i].dead = false;
		sprites[i].diag = 0;

		memset(sprites[i].username,'\0',sizeof(sprites[i].username));
		path[0][i].x = sprites[i].x;
		path[0][i].y = sprites[i].y;

		sprites[i].length = 40;
		growth[i] = 0;
		currentPath[i] = 1;
		pathPos[i] = 0;

		if(rand() & 1)
			sprites[i].dx = -sprites[i].dx;
		if(rand() & 1)
			sprites[i].dy = -sprites[i].dy;
	}
}
static void changeApple() {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = (rand() % (400 - 32)) << 8;
	apple.y = (rand() % (240 - 32)) << 8;
	while (getColor(apple.x >> 8, apple.y >> 8) || hasCommonY(num_bikes - 1)) {
		apple.x = (rand() % (400 - 32)) << 8;
		apple.y = (rand() % (240 - 32)) << 8;
	}
	drawSprite(oldx >> 8, oldy >> 8, 2, 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 66;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
}
static void moveApple() {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = (rand() % (400 - 32)) << 8;
	apple.y = (rand() % (240 - 32)) << 8;
	while (getColor(apple.x >> 8, apple.y >> 8) || hasCommonY(num_bikes - 1)) {
		apple.x = (rand() % (400 - 32)) << 8;
		apple.y = (rand() % (240 - 32)) << 8;
	}
	drawSprite(oldx >> 8, oldy >> 8, 2, 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 77;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
	usedSpecial = false;
}
static void updateApple(int x, int y) {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx >> 8, oldy >> 8, 2 , 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
}
static void setApple(int player, int x, int y) {
	if (abs(player) > num_bikes) return;
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx >> 8, oldy >> 8, 2 , 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	score[player]++;
	growth[player] += growthRate;
	sprites[player].length += growthRate;
	usedSpecial = false;
}
void print_constatus()
{
	ret=0;
	u32 pos;
	

	//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
	ret = udsGetConnectionStatus(&constatus);
	if(R_FAILED(ret))
	{
		printf("udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
		CATASTROPHIC_FAILURE = true;
		return;
	}
	else
	{
		if (debugging) {
			printf("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
			printf("1=0x%x\n", (unsigned int)constatus.unk_x4);
			printf("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
			printf("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
			for(pos=0; pos<(0x20>>2); pos++)printf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
			printf("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
			printf("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
			printf("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
		}
	}
}
u64 debugLastSent;
u64 debugUDSSent;
//---------------------------------------------------------------------------------
static void sceneInit(void) {
//---------------------------------------------------------------------------------

	memset(path,0,sizeof(path[0][0]) * 400 * 240 * 3);
	// Load the vertex shader, create a shader program and bind it
	vshader_dvlb = DVLB_ParseFile((u32*)vshader_shbin, vshader_shbin_len);
	shaderProgramInit(&program);
	shaderProgramSetVsh(&program, &vshader_dvlb->DVLE[0]);
	C3D_BindProgram(&program);

	// Get the location of the uniforms
	uLoc_projection = shaderInstanceGetUniformLocation(program.vertexShader, "projection");

	// Configure attributes for use with the vertex shader
	// Attribute format and element count are ignored in immediate mode
	C3D_AttrInfo* attrInfo = C3D_GetAttrInfo();
	AttrInfo_Init(attrInfo);
	AttrInfo_AddLoader(attrInfo, 0, GPU_FLOAT, 3); // v0=position
	AttrInfo_AddLoader(attrInfo, 1, GPU_FLOAT, 2); // v2=texcoord

	// Compute the projection matrix
	// Note: we're setting top to 240 here so origin is at top left.
	Mtx_OrthoTilt(&projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0, true);

	// Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);

	unsigned char* image;
	unsigned width, height;

	lodepng_decode32(&image, &width, &height, bike_png, bike_png_size);
	u8 *gpusrc = linearAlloc(width*height*4);

	// GX_DisplayTransfer needs input buffer in linear RAM
	u8* src=image; u8 *dst=gpusrc;

	// lodepng outputs big endian rgba so we need to convert
	for(int i = 0; i<width*height; i++) {
		int r = *src++;
		int g = *src++;
		int b = *src++;
		int a = *src++;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, width*height*4);

	// Load the texture and bind it to the first texture unit
	C3D_TexInit(&spritesheet_tex, width, height, GPU_RGBA8);

	// Convert image to 3DS tiled texture format
	GX_DisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(width,height), (u32*)spritesheet_tex.data, GX_BUFFER_DIM(width,height), TEXTURE_TRANSFER_FLAGS);
	gspWaitForPPF();

	C3D_TexSetFilter(&spritesheet_tex, GPU_LINEAR, GPU_NEAREST);
	C3D_TexBind(0, &spritesheet_tex);

	lodepng_decode32(&image, &width, &height, splash_png, splash_png_size);
	gpusrc = linearAlloc(width*height*4);

	// GX_DisplayTransfer needs input buffer in linear RAM
	src=image; dst=gpusrc;

	// lodepng outputs big endian rgba so we need to convert
	for(int i = 0; i<width*height; i++) {
		int r = *src++;
		int g = *src++;
		int b = *src++;
		int a = *src++;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, width*height*4);

	// Load the texture and bind it to the first texture unit
	if (!C3D_TexInit(&splash_tex, width, height, GPU_RGBA8)) printf("Error: failed to initialize splash image.\n");

	// Convert image to 3DS tiled texture format
	GX_DisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(width,height), (u32*)splash_tex.data, GX_BUFFER_DIM(width,height), TEXTURE_TRANSFER_FLAGS);
	gspWaitForPPF();

	C3D_TexSetFilter(&splash_tex, GPU_LINEAR, GPU_NEAREST);

	C3D_TexBind(0, &splash_tex);
	free(image);
	linearFree(gpusrc);

	// Configure the first fragment shading substage to just pass through the texture color
	// See https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnv.xml for more insight
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, 0, 0);
	C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
	C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);

	setSprites();
	// Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
	C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);
	frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);
}
static void printScore() {
	printf("\x1b[0;0HScore: ");
		for (int i = 0; i < num_bikes; i++) {
			printf("%s%d", textColors[i],score[i]);
			if (i < num_bikes - 1) printf(" %s- ",WHITE);
		}
	death = dead;
	if (!death) death = dead2;
	if (sprites[myNum].dead) printf("\x1b[1;0H%sYou are %sdead%s (%s%s%s)",WHITE,RED,WHITE,textColors[getKiller(death)],sprites[getKiller(death)].username,WHITE);
	else { 
		printf("\x1b[1;0H%sYou are %salive%s! ",WHITE,GREEN,WHITE);
		if (everyoneElseIsDead()) printf("\x1b[6;0HGet %d more points!",theHighest() - score[myNum] + 1);
	}
	printf("\x1b[2;0HHold %sA%s to move Faster.",RED,WHITE);
	printf("\x1b[3;0HHold %sB%s to move Slower.",YELLOW,WHITE);
	printf("\x1b[4;0HPress %sY%s to teleport the apple once.",GREEN,WHITE);
	int x = 5;
	for (int i = actual_bikes; i < num_bikes; i++) {
		printf("\x1b[%d;0H%s%s%s has joined the game. (%d.%d)",x + i - actual_bikes,textColors[i],sprites[i].username,WHITE, actual_bikes, num_bikes);
	}
	if (debugging) printf("\x1b[5;0Hactual_bikes: %d mynum: %d %d",actual_bikes, myNum, num_bikes);
	//printf("\x1b[5;0Hdead: 0x%08x, 0x%08x",dead,dead2);
	//printf("\x1b[6;0Hnum_bikes: %d, myNum: %d",num_bikes,myNum);
	//printf("\x1b[7;0Hgrowth: %d length: %d (%d)",growth[myNum],sprites[myNum].length,getLength(myNum));
	//printf("\x1b[8;0HpathPos: %d currentPath: %d",pathPos[myNum],currentPath[myNum]);
}
static void drawLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, int img) {
	int w = (dx >> 8) - (sx >> 8);
	int h = (dy >> 8) - (sy >> 8);
	int x = sx;
	int y = sy;
	if (w < 0 || h < 0) { 
		x = dx;
		y = dy;
	}
	w = abs(w);
	h = abs(h);
	//drawSprite(x >> 8, y >> 8, w, h, img);
	if (w <= 2) { h = 2 << 8; w = 0; }
	else { h = 0; w = 2 << 8; }
	while (pathnum != currentPath[img]) {
		drawSprite(path[pathnum][img].x >> 8, path[pathnum][img].y >> 8, 2, 2, 9);
		drawSprite(x >> 8, y >> 8, 2, 2, img);
		path[pathnum][img].x = x;
		x += w;
		path[pathnum][img].y = y;
		y += h;
		pathnum++;
		if (pathnum > 240 * 400) pathnum = 0;
	}
	path[pathnum][img].x = x;
	path[pathnum][img].y = y;
	drawSprite(x >> 8, y >> 8, 2, 2, img);
}
static void eraseOvershoot(Sprite sprite) {
	int img = sprite.image;
	int cx = path[currentPath[img]][img].x >> 8;
	int cy = path[currentPath[img]][img].y >> 8;
	int udx = sprite.x >> 8;
	int udy = sprite.y >> 8;
	if (cx == udx && cy == udy) return;
	int pathn = currentPath[img];
	while ((path[pathn][img].x >> 8) != udx && (path[pathn][img].y >> 8) != udy && pathn != pathPos[img]) {
		drawSprite(path[pathn][img].x >> 8, path[pathn][img].y >> 8, 2, 2, 9);
		pathn--;
		if (pathn < 0) pathn = 240 * 400;
	}
}
static void finishLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, Sprite msg, int img) {
	if ((sx >> 8) == (dx >> 8) && (sy >> 8) == (dy >> 8)) {
		drawSprite(sy,dy,2,2,img);
		return;
	}
	int udx = dx >> 8;
	int udy = dy >> 8;
	int x = sx >> 8;
	int y = sy >> 8;
	int w = udx - x;
	int h = udy - y;
	if (abs(w) > 100 || abs(h) > 100) return;



	//drawSprite(x >> 8, y >> 8, w, h, img);
	int pathn = currentPath[img] - 1;
	if (pathn < 0) pathn = 240 * 400;
	int prevx = path[pathn][img].x >> 8;
	int prevy = path[pathn][img].y >> 8;
	pathn--;
	if (pathn < 0) pathn = 240 * 400;
	int prevx2 = path[pathn][img].x >> 8;
	int prevy2 = path[pathn][img].y >> 8;
	pathn = currentPath[img];
	int i = 0;
	if (x != udx && y != udy) {
		int tx, ty;
		if (w < 0) tx = -2;
		else tx = 2;
		if (h < 0) ty = -2;
		else ty = 2;
	
		if ((prevx - prevx2 > 0 && w > 0) || (prevx - prevx2 < 0 && w < 0) || (prevy - prevy2 > 0 && h > 0) || (prevy - prevy2 < 0 && h < 0)) {//draw
			if (sprites[img].diag && x != udx && y != udy) {
				if (debugging) printf("\nOMG\n");
				pathn = currentPath[img];
				while (x != udx && y != udy && i < 40) {
					i++;
					drawSprite(x,y,2,2,9);
					pathn--;
					if (pathn < 0) pathn = 240 * 400;
					x = path[pathn][img].x >> 8;
					y = path[pathn][img].y >> 8;
				}
				pathn++;
				if (pathn > 240 * 400) pathn = 0;
				i = 0;
				if (x != udx) while (x != udx && i < 40) { i++; drawSprite(x,y,2,2,img); path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; pathn++; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0;  if (pathn > 240 * 400) pathn = 0; x += tx; }
				else while (y != udy && i < 40) { i++; drawSprite(x,y,2,2,img); path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; pathn++; if (pathn > 240 * 400) pathn = 0; y += ty; }
			}
			path[pathn][img].x = x << 8;
			path[pathn][img].y = y << 8;

		} 
		else { //erase
			if (debugging) printf("\n!!!!\n");
			if (prevx == prevx2) {
				while ((path[pathn][img].y >> 8) != udy && i < 20) { i++; drawSprite(path[pathn][img].x >> 8,path[pathn][img].y >> 8,2,2,9); pathn--; }
				x = path[pathn][img].x >> 8;
				y = path[pathn][img].y >> 8;
				i = 0;
				drawSprite(x,y,2,2,img);
				while ((path[pathn][img].x >> 8) != udx && i < 20) { i++; x += tx; pathn++; drawSprite(x,y,2,2,img); path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; if (pathn > 240 * 400) pathn = 0; }
				//if (pathn == currentPath[img]) currentPath[img]++;
				if (currentPath[img] > 240 * 400) currentPath[img] = 0;
			}
			else if (prevy == prevy2) {
				while ((path[pathn][img].x >> 8) != udx && i < 20) { i++; drawSprite(path[pathn][img].x >> 8,path[pathn][img].y >> 8,2,2,9); pathn--; }
				x = path[pathn][img].x >> 8;
				y = path[pathn][img].y >> 8;
				i = 0;
				drawSprite(x,y,2,2,img);
				while ((path[pathn][img].y >> 8) != udy && i < 20) { i++; y += ty; drawSprite(x,y,2,2,img); pathn++; path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; if (pathn > 240 * 400) pathn = 0; }
				//if (pathn == currentPath[img]) currentPath[img]++;
				if (currentPath[img] > 240 * 400) currentPath[img] = 0;
			} else if (sprites[img].diag) {
				if (debugging) printf("%sYEP%s\n",RED,WHITE);
			}
			drawSprite(dx,dy,2,2,img);
		}
		return;
	}


	if (w == 0) { 
		if (h < 0) h = -2; 
		else h = 2; 
		w = 0; 
	}
	else { 
		h = 0; 
		if (w < 0) w = -2; 
		else w = 2; 
	}

	if (w != 0 && h != 0) return;

	//Erase overshoot.
	dx = dx >> 8;
	dy = dy >> 8;
	if (x != udx && y != udy) return;

	i = 0;

	//Now fill in shortcomings.
	int c = rand() % 9;
	if (udx == prevx && udy == prevy) {
		if (debugging) {
			while (c == img) c = rand() % 9;
			printf("%s%d .. %d%s\n",textColors[c],udx,udy,WHITE);
			drawSprite(sx >> 8,sy >> 8,2,2,c);
			drawSprite(dx, dy, 2, 2, c);
		}
		return;
	}
	if (debugging) {
		while (c == img) c = rand() % 9;
		printf("%sok.%s\n",textColors[c],WHITE);
	}
	//drawSprite(sx,sy,2,2,c);
	while ((x != dx || y != dy) && (i < 4)) {
		i++;	

		path[currentPath[img]][img].y = (y << 8);
		path[currentPath[img]][img].x = (x << 8);
		drawSprite(x, y, 2, 2, img);
		currentPath[img]++;
		if (currentPath[img] > 240 * 400) currentPath[img] = 0;
		x += w;
		
		y += h;
		
	}
	path[currentPath[img]][img].y = (y << 8);
	path[currentPath[img]][img].x = (x << 8);
}
//---------------------------------------------------------------------------------
static void moveSprites() {
//---------------------------------------------------------------------------------
	int i;
	for(i = 0; i < num_bikes; i++) {
		if (sprites[i].dead || !timeDiff(i)) continue;
		if (i != myNum && sprites[i].diag) {
			if (sprites[i].diag == NORTHEAST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx * -1;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy * -1;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == SOUTHEAST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == SOUTHWEST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx * -1;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy * -1;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == NORTHWEST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy;
					sprites[i].dy = 0;
				}
			}
		}
		sprites[i].x += sprites[i].dx;
		sprites[i].y += sprites[i].dy;
		if(sprites[i].x < (2<<8)) sprites[i].x = (398) << 8;
		else if (sprites[i].x > ((398) << 8)) sprites[i].x = (2<<8);

		if(sprites[i].y < (2<<8)) sprites[i].y = (238 << 8);
		else if (sprites[i].y > (238 << 8)) sprites[i].y = (2<<8);

		frameTicks[i] = svcGetSystemTick();
		while (getLength(i) * .9 > sprites[i].length) {
			drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
			pathPos[i]++;
		}
		if (growth[i]) growth[i]--;
		else if (getLength(i) >= sprites[i].length) {
			drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
			pathPos[i]++;
		}
		currentPath[i]++;
		if (pathPos[i] > 400 * 240) pathPos[i] = 0;
		if (currentPath[i] > 400 * 240) currentPath[i] = 0;
		path[currentPath[i]][i].x = sprites[i].x;
		path[currentPath[i]][i].y = sprites[i].y;
		if (i == myNum) {
			u32 color1 = getColor(sprites[i].x >> 8, sprites[i].y >> 8);
			u32 color2 = getColor((sprites[i].x >> 8) + 1, (sprites[i].y >> 8) + 1);
			if (abs((sprites[i].x >> 8) - (apple.x >> 8)) <= 2 && abs((sprites[i].y >> 8) - (apple.y >> 8)) <= 2) {
				score[i]++;
				growth[i] += growthRate;
				sprites[i].length += growthRate;
				memset(replyScore,0,sizeof(replyScore[0]) * 10);
				moveApple();
			}
			else if (getLength(i) < 5) {} //don't die if game just started
			else if ((color1 != colors[8] && color2 != colors[8]) && (color1 > 0 || color2 > 0)) {
				dead = color1;
				dead2 = color2;
				sprites[i].dead = true;
				msg.sprite = sprites[i];
				UDSSend(msg); //dead
			}
		}
	}
}

//---------------------------------------------------------------------------------
static void sceneRender(void) {
//---------------------------------------------------------------------------------
	int i;
	// Update the uniforms
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);

	for(i = 0; i < num_bikes; i++) {
		if (i < actual_bikes) { 
			drawSprite( sprites[i].x >> 8, sprites[i].y >> 8, 2, 2, sprites[i].image);
			if ((path[currentPath[i]][i].x >> 8) != (sprites[i].x >> 8) || (path[currentPath[i]][i].y >> 8) != (sprites[i].y >> 8)) {
				currentPath[i]++;
				path[currentPath[i]][i].x = sprites[i].x;
				path[currentPath[i]][i].y = sprites[i].y;
			}
		}
		drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
	}

}
//---------------------------------------------------------------------------------
static void sceneExit(void) {
//---------------------------------------------------------------------------------

	// Free the shader program
	shaderProgramFree(&program);
	DVLB_Free(vshader_dvlb);
}
static SwkbdCallbackResult wrongName(void* user, const char** ppMessage, const char* text, size_t textlen)
{
  	int i = 0;
  	char lowertext[50];
  	strncpy(lowertext,text,sizeof(lowertext));
	while( lowertext[i] ) 
	{
	  putchar(tolower(lowertext[i]));
	  i++;
	}

	if (strstr(lowertext, "host"))
	{
		*ppMessage = "Just no.";
		return SWKBD_CALLBACK_CONTINUE;
	}

	return SWKBD_CALLBACK_OK;
}
void uds_test()
{
	memset(overwriteName,'\0',sizeof(overwriteName));
	ret=0;
	con_type=0;


	for (int i = 0; i < NUM_SPRITES; i++) {
		memset(sprites[i].username,'\0',sizeof(sprites[i].username));
	}
	u8 data_channel = 1;
	udsNetworkStruct networkstruct;
	udsNetworkScanInfo *networks = NULL;
	udsNetworkScanInfo *network = NULL;
	size_t total_networks = 0;

	u32 recv_buffer_size = UDS_DEFAULT_RECVBUFSIZE;
	u32 wlancommID = 0x783a9dab;//Unique ID, change this to your own.
	char *passphrase = "dandewsudssnake saadistheman";//Change this passphrase to your own. The input you use for the passphrase doesn't matter since it's a raw buffer.

	conntype = UDSCONTYPE_Client;

	size_t actual_size;
	u32 tmp=0;
	u32 pos;

	u8 appdata[0x14] = {0x69, 0x8a, 0x05, 0x5c};

	char tmpstr[256];

	strncpy((char*)&appdata[4], "Test appdata.", sizeof(appdata)-1);

	//printf("Successfully initialized.\n");

	size_t tmpbuf_size = 0x4000;
	u32 *tmpbuf = malloc(tmpbuf_size);
	if(tmpbuf==NULL)
	{
		printf("Failed to allocate tmpbuf for beacon data.\n");
		return;
	}
	int hosting = 0;
	int readyToJoin = 0;
	C3D_TexBind(0, &splash_tex);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
		C3D_FrameDrawOn(target);
		drawSprite(72,0,256,256,10);
	C3D_FrameEnd(0);
	gfxFlushBuffers();
	gfxSwapBuffers();

	printf("Hold A to host\nPress B to scan for a host.\nPress Y to change name.\nPress START to exit.\n");
	while (1) {
		gspWaitForVBlank();
		hidScanInput();

		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			drawSprite(72,0,256,256,10);
		C3D_FrameEnd(0);
		gfxFlushBuffers();
		gfxSwapBuffers();

		// Respond to user input
		u32 kDown = hidKeysDown();
		u32 kHeld = hidKeysHeld();
		if (kDown & KEY_START) return;
		if (kDown & KEY_L) { debugging = true; printf("Debugging turned on.\n"); }
		if (kDown & KEY_A) { hosting = 1; break; }
		else if (kDown & KEY_Y) {
			static SwkbdState swkbd;
			static char mybuf[20];
			static SwkbdStatusData swkbdStatus;
			static SwkbdLearningData swkbdLearning;
			SwkbdButton button = SWKBD_BUTTON_NONE;
			swkbdInit(&swkbd, SWKBD_TYPE_NORMAL, 3, -1);
			swkbdSetValidation(&swkbd, SWKBD_NOTEMPTY_NOTBLANK, 0, 0);
			swkbdSetFilterCallback(&swkbd, wrongName, NULL);
			swkbdSetInitialText(&swkbd, mybuf);
			swkbdSetHintText(&swkbd, "Please enter your name");
			swkbdSetButton(&swkbd, SWKBD_BUTTON_LEFT, "Cancel", false);
			
			swkbdSetButton(&swkbd, SWKBD_BUTTON_RIGHT, "Done", true);
			swkbdSetFeatures(&swkbd, SWKBD_PREDICTIVE_INPUT);
			SwkbdDictWord words[2];
			swkbdSetDictWord(&words[0], "lenny", "( ͡° ͜ʖ ͡°)");
			swkbdSetDictWord(&words[1], "shrug", "¯\\_(ツ)_/¯");
			swkbdSetDictionary(&swkbd, words, sizeof(words)/sizeof(SwkbdDictWord));
			static bool reload = false;
			swkbdSetStatusData(&swkbd, &swkbdStatus, reload, true);
			swkbdSetLearningData(&swkbd, &swkbdLearning, reload, true);
			reload = true;
			button = swkbdInputText(&swkbd, mybuf, sizeof(mybuf));
			if (button != SWKBD_BUTTON_NONE && strlen(mybuf) > 0) { 
				memset(overwriteName,'\0',sizeof(overwriteName));
				strncpy(overwriteName,mybuf,sizeof(overwriteName));
				printf("Welcome, %s\n", overwriteName);
			} else printf("Name set to default.\n");
		}
		else if((kDown & KEY_B) || (kHeld & KEY_B)) {
			printf("Scanning...\n");
			while (1) {
				gspWaitForVBlank();
				hidScanInput();

				kHeld = hidKeysHeld();
				kDown = hidKeysDown();
				if (!(kHeld & KEY_B)) break;
				total_networks = 0;
				memset(tmpbuf, 0, sizeof(tmpbuf_size));
				ret = udsScanBeacons(tmpbuf, tmpbuf_size, &networks, &total_networks, wlancommID, 0, NULL, false);

				if(total_networks) { network = &networks[0]; readyToJoin = 1; break; }
			}
			if (total_networks == 1) {
				if (network->network.total_nodes >= 8) {
					readyToJoin = false;
					printf("Only one room was found and it was full!\nPress A to go back to main menu\n");
					while (1) {
						gspWaitForVBlank();
						hidScanInput();
						kDown = hidKeysDown();
						if (kDown & KEY_A) break;
						if (kDown & KEY_START) return;
					}
				}
			}
			if (total_networks > 1) {
				int selected = 0;
				consoleClear();
				printf("Please choost a host by 3ds name:\n");
				while (1) {
					gspWaitForVBlank();
	
					network = &networks[0];

					if (debugging) printf("network: total nodes = %u.\n", (unsigned int)network->network.total_nodes);


					for(pos=0; pos<total_networks; pos++)
					{
						network = &networks[pos];
						if(!udsCheckNodeInfoInitialized(&network->nodes[0]))continue;
						if (network->network.total_nodes >= 8) continue;
						free(tmpbuf);
						tmpbuf = NULL;
						memset(tmpstr, 0, sizeof(tmpstr));

						ret = udsGetNodeInfoUsername(&network->nodes[0], tmpstr);
						if(R_FAILED(ret))
						{
							printf("udsGetNodeInfoUsername() returned 0x%08x.\n", (unsigned int)ret);
							CATASTROPHIC_FAILURE = true;
							free(networks);
							return;
						}

						if (pos == selected) printf("\x1b[%d;0H%s%s%s\n", (unsigned int)(pos + 1), YELLOW, tmpstr, WHITE);
						else printf("\x1b[%d;0H%s",(unsigned int)(pos + 1),tmpstr);
					}
					hidScanInput();
					kDown = hidKeysDown();
					if ((kDown & KEY_DUP) || (kDown & KEY_CPAD_UP)) selected--;
					if ((kDown & KEY_DDOWN) || (kDown & KEY_CPAD_DOWN)) selected++;
					if (kDown & KEY_A) { network = &networks[selected]; break; }
					if (selected < 0 || selected >= total_networks) selected = 0;
				}
			}
			consoleClear();
			if (readyToJoin) break;
			else printf("Hold A to host\nPress B to scan for a host.\nPress Y to change name.\nPress START to exit.\n");
		}

	}
	if(total_networks && !hosting)
	{
		free(tmpbuf);
		tmpbuf = NULL;

		if (debugging) printf("network: total nodes = %u.\n", (unsigned int)network->network.total_nodes);


		for(pos=0; pos<NUM_SPRITES; pos++)
		{
			if(!udsCheckNodeInfoInitialized(&network->nodes[pos]))continue;

			memset(tmpstr, 0, sizeof(tmpstr));

			ret = udsGetNodeInfoUsername(&network->nodes[pos], tmpstr);
			if(R_FAILED(ret))
			{
				printf("udsGetNodeInfoUsername() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				free(networks);
				return;
			}

			if (debugging) printf("node%u username: %s\n", (unsigned int)pos, tmpstr);
		}

		for(pos=0; pos<10; pos++)
		{
			ret = udsConnectNetwork(&network->network, passphrase, strlen(passphrase)+1, &bindctx, UDS_BROADCAST_NETWORKNODEID, conntype, data_channel, recv_buffer_size);
			if(R_FAILED(ret))
			{
				printf("udsConnectNetwork() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				return;
			}
			else
			{
				break;
			}
		}

		free(networks);

		if(pos==10)return;

		if (debugging) printf("Connected.\n");


		tmp = 0;
		ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
		if (debugging) printf("udsGetChannel() returned 0x%08x. channel = %u.\n", (unsigned int)ret, (unsigned int)tmp);
		if(R_FAILED(ret))
		{
			CATASTROPHIC_FAILURE = true;
			return;
		}
		con_type = 1;
		
	}
	if (hosting)
	{
		if (uds_enabled) {
			udsGenerateDefaultNetworkStruct(&networkstruct, wlancommID, 0, 8); //only have room for 8 players.

			printf("Creating the network...\n");
			ret = udsCreateNetwork(&networkstruct, passphrase, strlen(passphrase)+1, &bindctx, data_channel, recv_buffer_size);
			if(R_FAILED(ret))
			{
				printf("udsCreateNetwork() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				return;
			}

			tmp = 0;
			ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
			if (debugging) printf("udsGetChannel() returned 0x%08x. channel = %u.\n", (unsigned int)ret, (unsigned int)tmp);
			if(R_FAILED(ret))
			{
				udsDestroyNetwork();
				udsUnbind(&bindctx);
				CATASTROPHIC_FAILURE = true;
				return;
			}
		}
		con_type = 0;
		myNum = 0;
	}
	tmpbuf_size = UDS_DATAFRAME_MAXSIZE;
	tmpbuf = malloc(tmpbuf_size);
	if(tmpbuf==NULL)
	{
		printf("Failed to allocate tmpbuf for receiving data.\n");

		CATASTROPHIC_FAILURE = true;
		if (uds_enabled) {
			if(con_type)
			{
				udsDestroyNetwork();
			}
			else
			{
				udsDisconnectNetwork();
			}
			udsUnbind(&bindctx);
		}
		return;
	}
	if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
	{
		if (debugging) printf("Constatus event signaled.\n");
		ret=0;
		u32 pos;
		

		//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
		ret = udsGetConnectionStatus(&constatus);
		if(R_FAILED(ret))
		{
			printf("udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
			CATASTROPHIC_FAILURE = true;
			return;
		}
		else
		{
			if (debugging) {
				printf("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
				printf("1=0x%x\n", (unsigned int)constatus.unk_x4);
				printf("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
				printf("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
				for(pos=0; pos<(0x20>>2); pos++)printf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
				printf("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
				printf("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
				printf("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
			}
			myNode = constatus.cur_NetworkNodeID;
			sprites[myNum].node = myNode;
			memset(tmpstr, 0, sizeof(tmpstr));
			ret = udsGetNodeInformation(constatus.cur_NetworkNodeID,&tmpnode);
			ret = udsGetNodeInfoUsername(&tmpnode,&tmpstr);
			if (strlen(overwriteName) == 0) strncpy(myName,tmpstr,sizeof(myName));
			else strncpy(myName,overwriteName,sizeof(myName));

			if (!hosting) {
				myNum = constatus.total_nodes - 1;
				num_bikes = constatus.total_nodes;

				setSprites();
				if (debugging) printf("Sending request to join...\n");
				sprites[myNum].speed = 1111;
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 1111;
				UDSSend(msg);
				memset(replySprite,0,sizeof(replySprite[0]) * 10);
				lastSprite = svcGetSystemTick();
				while (1) {
					gspWaitForVBlank();
					gfxFlushBuffers();
					gfxSwapBuffers();
					hidScanInput();
					if (hidKeysDown() & KEY_START) { printf("ENDING...\n"); CATASTROPHIC_FAILURE = true; return; }
					if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
						if (debugging) printf("Resending request...\n");
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						sprites[myNum].node = myNode;
						msg.sprite = sprites[myNum]; 
						msg.sprite.speed = 1111; 
						UDSSend(msg);
						lastSprite = svcGetSystemTick();
					}
					memset(tmpbuf, 0, tmpbuf_size);
					actual_size = 0;
					src_NetworkNodeID = 0;
					if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
					if(R_FAILED(ret))
					{
						printf("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
						replay = false;
						CATASTROPHIC_FAILURE = true;
						return;
					}
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) printf("speed: %d image: %d myNum: %d\n",msg.sprite.speed, msg.sprite.image, myNum);
						if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; sprites[myNum] = msg.sprite; sprites[myNum].node = myNode; msg.sprite = sprites[myNum]; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; memset(replySprite,0,sizeof(replySprite[0]) * 10); break; } //joined game in score screen
						else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].dead = true; sprites[myNum].node = myNode; sprites[myNum].speed = 45; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); break; } // joined game in progress
						else if(msg.sprite.speed == 1211 && msg.sprite.image == myNum) break;
					}
				}
			}
		}

	}

	//printf("Press A to stop data transfer.\n");
	char quitName[50];
	memset(quitName,'\0',sizeof(quitName));
	C3D_TexBind(0, &spritesheet_tex);
	while (replay) {
		errorQuit = 0;
		if (num_bikes < 1) num_bikes = 1;
		for (int i = 0; i < num_bikes; i++) {
			score[i] = 0;
		}
		if (!inGame) setSprites();
		if (con_type == 0) { //hosting, wait for connection
			hidScanInput();
			u32 kDown = hidKeysDown();
			u32 kUp = hidKeysUp();
			u32 kHeld = hidKeysHeld();
			consoleClear();
			if (!connectionEstablished) printf("Waiting for connection...\nLet go of A to play by yourself.\n\n",textColors[7]);
			else printf("Preparing room...\n");
			while ((kHeld & KEY_A) && !(kUp & KEY_A)) {
				gspWaitForVBlank();
				hidScanInput();

				kHeld = hidKeysHeld();
				kDown = hidKeysDown();
				kUp = hidKeysUp();
				if(kDown & KEY_START) {
					udsDisconnectNetwork();
					udsUnbind(&bindctx);
					return;
				}
				if (kUp & KEY_A) break;
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					setSprites();
					connectionEstablished = true;
					
					ret = udsGetConnectionStatus(&constatus);
					ret = udsGetNodeInformation(0x1,&tmpnode);
					memset(sprites[0].username,'\0',sizeof(sprites[0].username));
					udsGetNodeInfoUsername(&tmpnode,&sprites[0].username);
					ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
					if (constatus.total_nodes >= num_bikes) {
						memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes].username));
						udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes].username);
						sprites[num_bikes].node = constatus.total_nodes;
						if (debugging) {
							printf("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
							printf("1=0x%x\n", (unsigned int)constatus.unk_x4);
							printf("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
							printf("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
							for(pos=0; pos<(0x20>>2); pos++)printf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
							printf("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
							printf("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
							printf("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
						}
						printf("%s%s has joined as %s%s\n",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
						num_bikes = constatus.total_nodes;
					}
					break;
				}
			}
			int i = 0;
			ret = 0;
			if (debugging) printf("Sending bike information");
			bool redo = true;
			lastSprite = svcGetSystemTick();
			lastChange = svcGetSystemTick();
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			memset(replyChange,0,sizeof(replyChange[0]) * 10);
			while (redo && num_bikes > 1) {
				for (i = 0; i < num_bikes; i++) {
					gspWaitForVBlank();
					msg.sprite = sprites[i];
					UDSResend(replySprite,msg);
				}
				if (!allReplied(replySprite)) lastSprite = svcGetSystemTick();
				if (!allReplied(replyChange)) lastChange = svcGetSystemTick();
				msg.sprite.image = 0;
				msg.sprite.speed = 66;
				msg.sprite.x = apple.x;
				msg.sprite.y = apple.y;
				UDSResend(replyChange,msg);
				while (1) {
					gspWaitForVBlank();
					hidScanInput();
					u32 kDown = hidKeysDown();
					if (kDown & KEY_START) {
						CATASTROPHIC_FAILURE = true;
						return;
					}
					memset(tmpbuf, 0, tmpbuf_size);
					actual_size = 0;
					src_NetworkNodeID = 0;

					if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
					{
						u32 pos;
						

						//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
						ret = udsGetConnectionStatus(&constatus);
						if(R_FAILED(ret))
						{
							printf("udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
							CATASTROPHIC_FAILURE = true;
							return;
						}
						else
						{
							if (constatus.total_nodes >= num_bikes) {
								if (debugging) {
									printf("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
									printf("1=0x%x\n", (unsigned int)constatus.unk_x4);
									printf("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
									printf("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
									for(pos=0; pos<(0x20>>2); pos++)printf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
									printf("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
									printf("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
									printf("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
								}
								ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
								if (constatus.total_nodes >= num_bikes) {
									memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes].username));
									udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes].username);
									if (!sprites[num_bikes].node) sprites[num_bikes].node = constatus.total_nodes;
									printf("%s%s has joined as %s%s\n",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
								}
							} else {
								printf("Lost one!\n");
							}
							num_bikes = constatus.total_nodes;

						}
					}
					if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
					if(R_FAILED(ret))
					{
						printf("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
						CATASTROPHIC_FAILURE = true;
						return;
					}
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) printf("speed: %d image: %d\n",msg.sprite.speed, msg.sprite.image);
						if (msg.sprite.speed == 100) replySprite[msg.sender] = true;
						else if (msg.sprite.speed == 777) {} //ignore
						else if (msg.sprite.speed == 123) {} //ignore
						else if (msg.sprite.speed == 66) replyChange[msg.sender] = true;
						else if (msg.sprite.speed == 1111) { if (debugging) printf("Accepting request to join...(%d)\n",msg.sender); sprites[msg.sender].node = msg.sprite.node; replyChange[msg.sender] = false; replySprite[msg.sender] = false; sprites[msg.sender].speed = 1211; msg.sprite = sprites[msg.sender]; UDSSend(msg); } 
						else if (msg.sprite.speed == 999) { CATASTROPHIC_FAILURE = true; return; } //player quit
					}
					if (allReplied(replySprite) && allReplied(replyChange)) {
						if (debugging) printf("Starting game...");
						redo = false;
						msg.sprite = sprites[myNum];
						msg.sprite.image = 0;
						msg.sprite.speed = 101;
						UDSSend(msg);
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						lastSprite = svcGetSystemTick();
						wakeup = true;
						break;
					} else if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 30 * lagMult()) {
						break;
					} else if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
						break;
					}
				}
				gspWaitForVBlank();
			}
			gspWaitForVBlank();
		} else if (!inGame) { //guest connection
			consoleClear();
			if (debugging) printf("\x1b[0;0HReceiving bike information...\n");
			printf("Loading...\nYou are %s%s%s!",textColors[myNum],colorNames[myNum],WHITE);
			memset(replySprite,true,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick();
			int oldspeed = 0;
			while (1) {
				gspWaitForVBlank();
				hidScanInput();
				u32 kDown = hidKeysDown();
				if (kDown & KEY_START) {
					return;
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
			
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					u32 pos;
					

					//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
					ret = udsGetConnectionStatus(&constatus);
					if(R_FAILED(ret))
					{
						printf("udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
						CATASTROPHIC_FAILURE = true;
						return;
					}
					else
					{
						if (debugging) {
							printf("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
							printf("1=0x%x\n", (unsigned int)constatus.unk_x4);
							printf("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
							printf("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
							for(pos=0; pos<(0x20>>2); pos++)printf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
							printf("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
							printf("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
							printf("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
						}
						if (!hosting) {
							myNum = constatus.cur_NetworkNodeID - 1;
							num_bikes = constatus.total_nodes;
							sprites[myNum].image = myNum;
							sprites[myNum].node = myNode;
							memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
							strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
							msg.sprite = sprites[myNum];
							msg.sprite.speed = 1111;
							UDSDirect(1,msg);
						}
					}
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
				//printf("tmpbuf_size: 0x%08x (0x%08x)\n",tmpbuf_size,sizeof(Message));
				if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
				if(R_FAILED(ret))
				{
					printf("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
					CATASTROPHIC_FAILURE = true;
					return;
				}
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (debugging) if (msg.sprite.speed != oldspeed) printf("image: %d speed: %d myNum: %d myNode: %d\n",msg.sprite.image, msg.sprite.speed, myNum, myNode);
					oldspeed = msg.sprite.speed;
					
					if (msg.sprite.speed == 123) {} //ignore
					else if (msg.sprite.speed == 777) {} //ignore
					else if (msg.sprite.speed == 555) { if (msg.sender == 0) UDSSend(msg); } //make sure host realizes we are waiting for him!
					else if (msg.sprite.speed == 1111) { sprites[msg.sprite.image] = msg.sprite; strncpy(sprites[msg.sprite.image].username,msg.sprite.username,sizeof(sprites[msg.sprite.image])); oldbikes--; } //ignore
					else if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; msg.sprite.speed = 45; sprites[myNum] = msg.sprite; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; break; } //joined game in score screen
					else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].speed = 45; sprites[myNum].node = myNode; sprites[myNum].dead = true; memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username)); strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username)); break; } // joined game in progress
					else if (msg.sprite.speed == 66) {
						if (msg.sender == 0) {
							apple.x = msg.sprite.x;
							apple.y = msg.sprite.y;
							UDSSend(msg);
						}
					} else if (msg.sprite.speed == 101) { if (msg.sender == 0) UDSSend(msg); break; }
					else if (msg.sender == 0 && (msg.sprite.speed == 45 || msg.sprite.speed == 1211)) {
						path[0][msg.sprite.image].x = msg.sprite.x;
						path[0][msg.sprite.image].y = msg.sprite.y;
						sprites[msg.sprite.image] = msg.sprite;
						sprites[msg.sprite.image].speed = 45;
						if (msg.sprite.image >= num_bikes - 1) {
							msg.sprite.speed = 100;
							UDSSend(msg);
						}
					}
				} 
			}
		}
		C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		gfxFlushBuffers();
		gfxSwapBuffers();
		C3D_RenderTargetSetClear(target, NULL, NULL, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		gfxFlushBuffers();
		gfxSwapBuffers();
		for (int i = 0; i < 10; i++) oldscore[i] = 0;
		bool olddead = sprites[myNum].dead;
		oldbikes = num_bikes;
		consoleClear();
		// Main loop
		for (int i = 0; i < num_bikes; i++) {
			frameTicks[i] = svcGetSystemTick();
		}
		int oldApplex = 0;
		int oldAppley = 0;
		int oldDx = 15;
		C3D_RenderTargetSetClear(target, NULL, NULL, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		UDSSent = svcGetSystemTick();
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replyScore,1,sizeof(replyScore[0]) * 10);
		if (myNum) memset(replyChange,1,sizeof(replyChange[0]) * 10);
		frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);
		if (!inGame && myNum != 0) memset(replySprite,1,sizeof(replySprite[0]) * 10);
		quit = -1;
		if (!inGame) actual_bikes = num_bikes;
		printScore();
		death = 0;
		int oldsender = 0;
		int oldspeed = 0;
		for (int i = actual_bikes; i < NUM_SPRITES; i++) {
			sprites[i].dead = true;
		}
		oldCPos.dx = 0;
		oldCPos.dy = 0;
		nextMove = NULL;
		while (aptMainLoop()) {
			if (everyoneElseIsDead() && sprites[myNum].dead) break;
			if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 3) {
				return;
			}
			if (myNum == 0) {
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					
					ret = udsGetConnectionStatus(&constatus);
					ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
					if (constatus.total_nodes >= num_bikes) {
						replyScore[msg.sender] = true;
						replyChange[msg.sender] = true;
						num_bikes = constatus.total_nodes;
					} else {
						errorQuit = svcGetSystemTick();
					}
				}
			}
			if (!wakeup) {
				if (!allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.image = myNum;
					msg.sprite.speed = 77;
					msg.sprite.x = apple.x;
					msg.sprite.y = apple.y;
					lastScore = svcGetSystemTick();
					UDSResend(replyScore,msg);
				}
				if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.image = myNum;
					msg.sprite.speed = 66;
					msg.sprite.x = apple.x;
					msg.sprite.y = apple.y;
					lastChange = svcGetSystemTick();
					UDSResend(replyChange,msg);
				}
				if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					if (sprites[myNum].speed == 1011) {
						memset(replySprite,1,sizeof(replySprite[0]) * 10);
					} else {
						sprites[myNum].node = myNode;
						memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
						strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
						msg.sprite = sprites[myNum];
						lastSprite = svcGetSystemTick();
						UDSResend(replySprite,msg);
					}
				}
			} else {
				if (!allReplied(replySprite) && svcGetSystemTick() -  lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.speed = 101;
					UDSResend(replySprite,msg);
					lastSprite = svcGetSystemTick();
				}
				if (allReplied(replySprite)) {
					wakeup = false;
				}
			}
			hidScanInput();

			// Respond to user input
			u32 kDown = hidKeysDown();
			u32 kHeld = hidKeysHeld();
			u32 kUp = hidKeysUp();
			circlePosition pos;
			hidCircleRead(&pos);

			//Read the CirclePad position
			if (kDown & KEY_START) {
				replay = false;
				return; // break in order to return to hbmenu
			}
			u32 msgtype = NULL;
			if ((abs(pos.dy) > 17 || abs(pos.dx) > 17) && !(oldCPos.dx == 0 && oldCPos.dy == 0)){
				float dvd = abs(pos.dy) > abs(pos.dx) ? abs(pos.dy) : abs(pos.dx) / abs(abs(pos.dy) - abs(pos.dx));
				if (dvd < 120 && dvd > 1) {
					if (pos.dy > 0 && pos.dx > 0) {
						sprites[myNum].diag = NORTHEAST;
						if (oldMove == MOVE_UP) kDown = KEY_CPAD_RIGHT;
						else if (oldMove == MOVE_RIGHT) kDown = KEY_CPAD_UP;
						else if (sprites[myNum].dx != 0) kDown = KEY_CPAD_UP;
						else kDown = KEY_CPAD_RIGHT;
					} else if (pos.dx < 0 && pos.dy < 0) {
						sprites[myNum].diag = SOUTHWEST;
						if (oldMove == MOVE_DOWN) kDown = KEY_CPAD_LEFT;
						else if (oldMove == MOVE_LEFT) kDown = KEY_CPAD_DOWN;
						else if (sprites[myNum].dx != 0) kDown = KEY_CPAD_DOWN;
						else kDown = KEY_CPAD_LEFT;
					} else if (pos.dx < 0 && pos.dy > 0) {
						sprites[myNum].diag = NORTHWEST;
						if (oldMove == MOVE_UP) kDown = KEY_CPAD_LEFT;
						else if (oldMove == MOVE_LEFT) kDown = KEY_CPAD_UP;
						else if (sprites[myNum].dx != 0) kDown = KEY_CPAD_UP;
						else kDown = KEY_CPAD_LEFT;
					} else if (pos.dx > 0 && pos.dy < 0) {
						sprites[myNum].diag = SOUTHEAST;
						if (oldMove == MOVE_DOWN) kDown = KEY_CPAD_RIGHT;
						else if (oldMove == MOVE_RIGHT) kDown = KEY_CPAD_DOWN;
						else if (sprites[myNum].dx != 0) kDown = KEY_CPAD_DOWN;
						else kDown = KEY_CPAD_RIGHT;
					} 
				} else if (pos.dx != oldCPos.dx || pos.dy != oldCPos.dy) {
					if (pos.dx < 0 && abs(pos.dx) > abs(pos.dy)) { if (oldDiag) msgtype = MOVE_LEFT; kDown = KEY_CPAD_LEFT; }
					else if (pos.dx > 0 && abs(pos.dx) > abs(pos.dy)) { if (oldDiag) msgtype = MOVE_RIGHT; kDown = KEY_CPAD_RIGHT; }
					else if (pos.dy < 0 && abs(pos.dy) > abs(pos.dx)) { if (oldDiag) msgtype = MOVE_DOWN; kDown = KEY_CPAD_DOWN; } 
					else if (pos.dy > 0 && abs(pos.dy) > abs(pos.dx)) { if (oldDiag) msgtype = MOVE_UP; kDown = KEY_CPAD_UP; }
					sprites[myNum].diag = 0;
				}
			} else if (oldDiag) {
				sprites[myNum].diag = 0;
				if (sprites[myNum].dx > 0) msgtype = MOVE_RIGHT;
				else if (sprites[myNum].dx < 0) msgtype = MOVE_LEFT;
				else if (sprites[myNum].dy > 0) msgtype = MOVE_UP;
				else if (sprites[myNum].dy < 0) msgtype = MOVE_DOWN;
			}

			oldCPos = pos;
			//if (debugging) printf("cpad: %03d %03d %d %f\n",pos.dx,pos.dy, oldMove, dvd);
			if (kDown & KEY_Y && !usedSpecial) {
				usedSpecial = true;
				memset(replyChange,0,sizeof(replyChange[0]) * 10);
				changeApple();
			}
			if (kDown & KEY_A || kHeld & KEY_A) sprites[myNum].speed = 15;
			else if (kUp & KEY_A) sprites[myNum].speed = 45;
			else if (kDown & KEY_B || kHeld & KEY_B) sprites[myNum].speed = 90;
			else if (kUp & KEY_B) sprites[myNum].speed = 45;
			int prevn = currentPath[myNum] - 1;
			if (prevn < 0) prevn = 240 * 400;
			if ((kDown & KEY_CPAD_UP || kDown & KEY_DUP || nextMove == MOVE_UP) && !sprites[myNum].dy) {
				if (kDown & KEY_DUP) sprites[myNum].diag = 0;
				if (path[prevn][myNum].x == sprites[myNum].x) nextMove = MOVE_UP;
				else {
					sprites[myNum].dx = 0;
					sprites[myNum].dy = bikeSpeed * -1;
					msgtype = MOVE_UP;
					nextMove = NULL;
				}
			} else if((kDown & KEY_CPAD_DOWN || kDown & KEY_DDOWN || nextMove == MOVE_DOWN)  && !sprites[myNum].dy) {
				if (kDown & KEY_DDOWN) sprites[myNum].diag = 0;
				if (path[prevn][myNum].x == sprites[myNum].x) nextMove = MOVE_DOWN;
				else {
					sprites[myNum].dx = 0;
					sprites[myNum].dy = bikeSpeed;
					msgtype = MOVE_DOWN;
					nextMove = NULL;
				}
			} else if ((kDown & KEY_CPAD_LEFT || kDown & KEY_DLEFT || nextMove & MOVE_LEFT)  && !sprites[myNum].dx) {
				if (kDown & KEY_DLEFT) sprites[myNum].diag = 0;
				if (path[prevn][myNum].y == sprites[myNum].y) nextMove = MOVE_LEFT;
				else {
					sprites[myNum].dx = bikeSpeed * -1;
					sprites[myNum].dy = 0;
					msgtype = MOVE_LEFT;
					nextMove = NULL;
				}
			} else if ((kDown & KEY_CPAD_RIGHT || kDown & KEY_DRIGHT || nextMove == MOVE_RIGHT)  && !sprites[myNum].dx) {
				if (kDown & KEY_DRIGHT) sprites[myNum].diag = 0;
				if (path[prevn][myNum].y == sprites[myNum].y) nextMove = MOVE_RIGHT;
				else {
					sprites[myNum].dx = bikeSpeed;
					sprites[myNum].dy = 0;
					msgtype = MOVE_RIGHT;
					nextMove = NULL;
				}
			}
			if (msgtype != NULL || oldDx != sprites[myNum].speed) {
				oldMove = msgtype;
				if (oldDiag != sprites[myNum].diag || !sprites[myNum].diag || oldDx != sprites[myNum].speed) {
					oldDiag = sprites[myNum].diag;
					sprites[myNum].node = myNode;
					strncpy(sprites[myNum].username,myName,sizeof(myName));
					msg.sprite = sprites[myNum];
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				oldDx = sprites[myNum].speed;
			}
			//send my sprite info
			//Message msg;
			

			//receive other sprite's info
			memset(tmpbuf, 0, tmpbuf_size);
			actual_size = 0;
			src_NetworkNodeID = 0;
			if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
			if(R_FAILED(ret))
			{
				printf("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				return;
			}
			if (wakeup) {
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (msg.sprite.speed == 101) {
						replySprite[msg.sender] = true;
					}
				}
			}
			for (int i = 0; i < num_bikes; i++) {
				if (score[i] != oldscore[i]) clearFlag = true;
			}
			if (sprites[myNum].dead && !olddead) clearFlag = true;
			if (oldbikes != num_bikes) { clearFlag = true; oldbikes = num_bikes; }
			if (clearFlag) {
				if (!debugging) consoleClear();
				printScore();
				for (int i = 0; i < num_bikes; i++) oldscore[i] = score[i];
					olddead = sprites[myNum].dead;
				clearFlag = false;
			}
			gfxFlushBuffers();
			gfxSwapBuffers();
			
			//Wait for VBlank
			gspWaitForVBlank();
			// Render the scene
			if (!wakeup) {
				C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
					C3D_FrameDrawOn(target);
					sceneRender();
					moveSprites();
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						//Message msg;
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) printf("sender: %d speed: %d diag: %d node: %d\n",msg.sender,msg.sprite.speed,msg.sprite.diag, msg.sprite.node);
						oldspeed = msg.sprite.speed;
						oldsender = msg.sender;
						if (msg.sprite.speed == 101 && msg.sender == 0) { UDSSend(msg); } //ignore.
						else if (msg.sprite.speed == 999) {
							errorQuit = 0;
							if (msg.sender == msg.sprite.node && msg.sender == msg.sprite.image) {
								for (int i = 0; i < num_bikes; i++) {
									if (sprites[i].node == msg.sprite.node) { quit = i; break; }
								}
								memset(quitName,'\0',sizeof(quitName));
								strncpy(quitName,msg.sprite.username,sizeof(quitName));
								
					
								for (int i = 0; i < num_bikes; i++) {
									sprites[i].dead = true;
								}
								msg.sprite.image = msg.sprite.node;
								msg.sprite.node = myNode;
								UDSDirect(msg.sprite.image,msg);
							}
						}
						else if (msg.sprite.speed == 1111) {
							sprites[msg.sprite.image] = msg.sprite;
							if (myNum == 0 && msg.sprite.image == msg.sender) {
								msg.sprite = sprites[msg.sprite.image];
								msg.sprite.image = actual_bikes;
								msg.sprite.speed = 1011;
								msg.sprite.dead = true;
								sprites[num_bikes] = msg.sprite;
								oldbikes = 0;
								UDSSend(msg);
							}
						}
						else if (msg.sprite.speed == 1011 && myNum != 0) {} // ignore
						else if (msg.sprite.speed == 66) { 
							if (msg.sprite.image == myNum) { if (msg.timestamp == lastChange) replyChange[msg.sender] = true; }
							else if (msg.sender == msg.sprite.image) { if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) updateApple(msg.sprite.x,msg.sprite.y); UDSSend(msg); }
						}
						else if (msg.sprite.speed == 77) { 
							if (msg.sprite.image == myNum) { if (msg.timestamp == lastScore) replyScore[msg.sender] = true; }
							else if (msg.sender == msg.sprite.image) { if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) setApple(msg.sprite.image, msg.sprite.x, msg.sprite.y); UDSSend(msg); }
						}
						else if (msg.sprite.image == myNum) { if (msg.sprite.speed == 1001) break; if (msg.timestamp == lastSprite) replySprite[msg.sender] = true; }
						else if (msg.sprite.speed == 1001) {} //ignore.
						else {
							
							
							if (msg.sprite.image > num_bikes) { 
								num_bikes = msg.sprite.image + 1; 
								for (int i = actual_bikes; i < NUM_SPRITES; i++) { 
									sprites[i].dead = true; 
								} 
								if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
								if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
								if (sprites[myNum].dead) { 
									sprites[myNum].image = myNum; 
									sprites[myNum].node = myNode; 
									msg.sprite = sprites[myNum]; 
									replySprite[num_bikes - 1] = false; 
									UDSSend(msg); 
								} 
							}
							if (msg.sprite.image == num_bikes) { 
								sprites[num_bikes].dead = true; 
								if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
								if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
								num_bikes++; 
								if (sprites[myNum].dead) { 
									printf("wtf...\n");
									sprites[myNum].image = myNum; 
									sprites[myNum].node = myNode; 
									msg.sprite = sprites[myNum]; 
									replySprite[num_bikes - 1] = false; 
									UDSSend(msg); 
								} 
							}
							if (msg.sender == msg.sprite.image) UDSSend(msg);
							int img = msg.sprite.image;
							if (msg.sprite.image < actual_bikes && msg.sender == msg.sprite.image) {
								
								if (abs(currentPath[img] - pathPos[img]) > 4) {
									u32 pathx = path[currentPath[img]][img].x >> 8;
									u32 pathy = path[currentPath[img]][img].y >> 8;
									u32 imgx = msg.sprite.x >> 8;
									u32 imgy = msg.sprite.y >> 8; 
									
									if (msg.sprite.dead) {
										eraseOvershoot(msg.sprite);
									}
									else finishLine(currentPath[img],pathx << 8, pathy << 8, imgx << 8, imgy << 8, msg.sprite, img);
								}
							}
							if (msg.sender == msg.sprite.image) sprites[msg.sprite.image] = msg.sprite;
							//drawSprite(sprites[img].x >> 8, sprites[img].y >> 8, 2, 2, img);
							if (everyoneElseIsDead()) {
								if (getHighestScore() == myNum && allReplied(replyScore)) { sprites[myNum].dead = true; msg.sprite = sprites[myNum]; UDSSend(msg); }
							}
						}
					}
					if (oldApplex != apple.x && oldAppley != apple.y) { 
						drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
						oldApplex = apple.x;
						oldAppley = apple.y;
					}
				C3D_FrameEnd(0);
				gfxFlushBuffers();
				gfxSwapBuffers();
			}
			if (everyoneElseIsDead()) {
				if (getHighestScore() == myNum && allReplied(replyScore)) { sprites[myNum].dead = true; msg.sprite = sprites[myNum]; UDSSend(msg); }
			}
			if (everyoneElseIsDead() && sprites[myNum].dead) break;
		}
		consoleClear();
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replyScore,0,sizeof(replyScore[0]) * 10);
		lastScore = 0;
		int oldQuit = 0;
		int numLeft = 0;
		errorQuit = 0;
		for (int i = 0; i < NUM_SPRITES; i++) {
			ready[i] = false;
		}
		joinedNum = 0;
		waitForFinish = 0;
		u64 readyLock = 0;
		readyLock = svcGetSystemTick();
		inGame = false;
		while (1) {
			gspWaitForVBlank();
			gfxFlushBuffers();
			gfxSwapBuffers();

			if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
				sprites[myNum].image = myNum;
				sprites[myNum].dead = true;
				sprites[myNum].node = myNode;
				msg.sprite = sprites[myNum];
				UDSResend(replySprite,msg);
			} //Be sure to still resend my death msg if someone hasn't gotten it
			if (allReplied(replyScore) && myNum == 0 && num_bikes > 1) { if (debugging) printf("Everyone got the message. Sending bike information.."); break; }
			if (waitForFinish != 0 && svcGetSystemTick() - waitForFinish > TICKS_PER_SEC * 4) break;
			if (itsATie()) printf("\x1b[0;0HIt's a TIE!                                   ");
			else if (getHighestScore() == myNum) printf("\x1b[0;0HA winner is YOU!                             ");
			else printf("\x1b[0;0HYou LOSE! %s%s wins the game!%s",textColors[getHighestScore()],sprites[getHighestScore()].username,WHITE);
			printf("\x1b[1;0HScore: ");
				for (int i = 0; i < NUM_SPRITES; i++) {
					if (i < num_bikes || i == 0) printf("%s%d ",textColors[i],score[i]);
					else printf("  ");
				}
			printf("\x1b[2;0H       ");
				for (int i = 0; i < NUM_SPRITES; i++) {
					if (i < num_bikes) {
						if (ready[i]) printf("%sR ",GREEN);
						else printf("%s- ",WHITE);
					} else printf("  ");
				}
			printf("\x1b[3;0H%sPress A if you're ready!\n",WHITE);
			printf("\x1b[4;0HPress START to quit.\n");
			if (numLeft >= 22) { consoleClear(); numLeft = 0; }
			if (num_bikes == 1) { numLeft++; num_bikes--; printf("\x1b[%d;0HEveryone has left the game!\n", numLeft + 5); }
			if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 123;
				//memset(replyChange,0,sizeof(replyChange[0]) * 10);
				UDSResend(replyChange,msg);
			}
			if (lastScore && !allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 30 * lagMult()) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 555;
				UDSResend(replyScore,msg);
				lastScore = svcGetSystemTick();
			}
			hidScanInput();
			u32 kDown = hidKeysDown();
			memset(tmpbuf, 0, tmpbuf_size);
			actual_size = 0;
			src_NetworkNodeID = 0;
			if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
			if(R_FAILED(ret))
			{
				printf("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				replay = false;
				return;
			}
			if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
			{
				//Message msg;
				memcpy(&msg,tmpbuf,sizeof(Message));
				if (debugging) {
					numLeft++;
					printf("\x1b[%d;0Hsender: %d, image: %d, speed: %d node: %d\n, %d",numLeft + 5,msg.sender,msg.sprite.image,msg.sprite.speed, msg.sprite.node);
				}
				if (msg.sprite.speed == 999) {
					if (msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
						memset(quitName,'\0',sizeof(quitName));
						strncpy(quitName,msg.sprite.username,sizeof(quitName));
						for (int i = 0; i < num_bikes; i++) {
							if (sprites[i].node == msg.sprite.node && i != oldQuit) { quit = i; oldQuit = quit; }
						}
						msg.sprite.image = msg.sprite.node;
						msg.sprite.node = myNode;
						UDSDirect(msg.sprite.image,msg);
					}
				}
				/*if (msg.sprite.speed == 999 && msg.sprite.image != quit) {
					if (msg.sender <= num_bikes) {
						lastQuit = msg.timestamp;
						quit = msg.sprite.image;
						quitNum = msg.sender;
						if (quit < myNum) myNum--;
						num_bikes--;
						replyChange--;
					}
				} //connection killed by guest*/
				else if (msg.sprite.speed == 1011) { } //ignore
				else if (msg.sprite.speed == 1111) {
					sprites[msg.sprite.image] = msg.sprite;
					sprites[msg.sprite.image].node = msg.sprite.node;
					if (joinedNum != msg.sprite.image) printf("\x1b[%d;0H%s%s has joined as %s%s\n",numLeft + 5,textColors[msg.sprite.image],msg.sprite.username,colorNames[msg.sprite.image],WHITE);
					joinedNum = msg.sprite.image;
					if (myNum == 0) {
						msg.sprite = sprites[msg.sprite.image];
						msg.sprite.dead = true;
						msg.sprite.speed = 1001;
						UDSSend(msg);
					}
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					sprites[myNum].node = myNode;
					memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				}
				else if (msg.sprite.speed == 123 && svcGetSystemTick() - readyLock > TICKS_PER_SEC) { if (!ready[msg.sender]) { numLeft++;  printf("\x1b[%d;0H%s%s%s is ready! Waiting on %d more...",numLeft + 5, textColors[msg.sender], msg.sprite.username, WHITE, notReadies() - 1); } ready[msg.sender] = true; if (msg.sprite.image != myNum) { msg.sprite.image = msg.sender; msg.sprite.speed = 777; UDSSend(msg); } }
				else if (msg.sprite.speed == 777 && svcGetSystemTick() - readyLock > TICKS_PER_SEC) {
					if (msg.sprite.image == myNum) replyChange[msg.sender] = true;
				} else if(msg.sprite.speed == 555) {
					if (msg.sender == 0) {
						UDSSend(msg); 
						break; 
					} else if (myNum == 0) {
						replyScore[msg.sender] = true;
					}
				} else {
					if (msg.sprite.image == myNum) replySprite[msg.sender] = true;
					else if (msg.sprite.image == msg.sender) {
						sprites[msg.sprite.image] = msg.sprite;
						UDSSend(msg);
					}
				}
			}
			if (allReady() && num_bikes > 1 && !lastScore) { 
				printf("\x1b[%d;0HStarting game....\n",numLeft + 6);  
				if (myNum == 0) { 
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 555;
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					UDSSend(msg);
					lastScore = svcGetSystemTick();
				}
			}


			if (kDown & KEY_B) { numLeft++; printf("\x1b[%d;0H%d",numLeft + 5, (svcGetSystemTick() - waitForFinish) / TICKS_PER_SEC); }
			if (kDown & KEY_SELECT) {
				consoleClear();
				numLeft = 0;
				for (int i = 0; i < num_bikes; i++) {
					numLeft++;
					printf("\x1b[%d;0HSprite %d",numLeft + 5, i);
					numLeft++;
					printf("\x1b[%d;0H  username: %s",numLeft + 5, sprites[i].username,numLeft + 5);
					numLeft++;
					printf("\x1b[%d;0H  image: %d",numLeft + 5, sprites[i].image,numLeft + 5);
				}
			}
			if (kDown & KEY_A && svcGetSystemTick() - readyLock > TICKS_PER_SEC) { 
				if (num_bikes <= 1) break; 
				if (!ready[myNum]) { 
					sprites[myNum].node = myNode; 
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username)); 
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 123; 
					lastChange = svcGetSystemTick(); 
					memset(replyChange,0,sizeof(replyChange[0]) * 10); 
					UDSSend(msg); 
					numLeft++; 
					printf("\x1b[%d;0H%s%s%s is ready! Waiting on %d more...",numLeft +5,textColors[myNum],sprites[myNum].username,WHITE,notReadies() - 1); 
				} 
				ready[myNum] = true;  
			}
			if (kDown & KEY_START) { return; }
			if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
			{
				readyLock = svcGetSystemTick();
				for (int i = 0; i < 10; i++) {
					ready[i] = false;
				}
				ret = udsGetConnectionStatus(&constatus);
				ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
				if (constatus.total_nodes >= num_bikes) {
					num_bikes = constatus.total_nodes;
					memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes - 1].username));
					udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes - 1].username);
					msg.sprite = sprites[num_bikes - 1];
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					memset(replyChange,1,sizeof(replyChange[0]) * 10);
					numLeft++;
				} else {
						numLeft++;
						if (quit < 0) {
							numLeft++;
							printf("\x1b[%d;0HA player has crashed...",numLeft + 5);
							errorQuit = svcGetSystemTick();
							while (1) {
								gspWaitForVBlank();
								gfxFlushBuffers();
								gfxSwapBuffers();
								hidScanInput();
								kDown = hidKeysDown();
								if (kDown & KEY_START) {
									CATASTROPHIC_FAILURE = true;
									return;
								}
								if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 4) {
									numLeft++;
									if (numLeft >= 23) { consoleClear(); numLeft = 0; }
									printf("\x1b[%d;0H%sError: unknown person left. Removing a color...%s",numLeft + 5,RED,WHITE);
									num_bikes = constatus.total_nodes;
									memset(replyChange,1,sizeof(replyChange[0]) * 10);
									memset(replySprite,1,sizeof(replySprite[0]) * 10);
									if (myNum >= num_bikes) {
										myNum = num_bikes - 1;
										printf("\x1b[%d;0H  You are now %s%s%s!",numLeft + 5,textColors[myNum],colorNames[myNum],WHITE);
									}
									errorQuit = 0;
									break;
								}
								memset(tmpbuf, 0, tmpbuf_size);
								actual_size = 0;
								src_NetworkNodeID = 0;
								if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
								if(R_FAILED(ret))
								{
									printf("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
									CATASTROPHIC_FAILURE = true;
									replay = false;
									return;
								}
								if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
								{

									memcpy(&msg,tmpbuf,sizeof(Message));
									if (msg.sprite.speed == 999 && msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
										joinedNum = 0;
										for (int i = 0; i < num_bikes; i++) {
											if (sprites[i].node == msg.sprite.node) { quit = i; break; }
										}
										if (quit < 0) {
											CATASTROPHIC_FAILURE = true;
											return;
										}
										memset(quitName,'\0',sizeof(quitName));
										strncpy(quitName,msg.sprite.username,sizeof(quitName));
										msg.sprite.image = msg.sprite.node;
										msg.sprite.node = myNode;
										UDSDirect(msg.sprite.image,msg);
										oldQuit = quit;
										numLeft++;
										if (numLeft + num_bikes - quit >= 23) { consoleClear(); numLeft = 0; }
										printf("\x1b[%d;0H%s%s has left the game.%s\n",numLeft + 5,textColors[quit],quitName,WHITE);
										if (quit > 0 && quit < num_bikes - 1) {
											if (quit < myNum) myNum--;
											for (int i = quit; i < num_bikes - 1; i++) {
												numLeft++;
												if (i == myNum) printf("\x1b[%d;0H  You are now %s%s%s!",numLeft + 5,textColors[myNum],colorNames[myNum],WHITE);
												else printf("\x1b[%d;0H  %s%s%s is now %s%s%s!",numLeft + 5, textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE);
												sprites[i] = sprites[i+1];
												sprites[i].image = i;
											}
										}
										num_bikes = constatus.total_nodes;
										memset(replyChange,1,sizeof(replyChange[0]) * 10);
										memset(replySprite,1,sizeof(replySprite[0]) * 10);
										quit = -1;
										oldQuit = -1;
										break;
									}
								}
							}
						}
						else {
							joinedNum = 0;
							if (numLeft + num_bikes - quit >= 23) { consoleClear(); numLeft = 0; }
							printf("\x1b[%d;0H%s%s has left the game.%s\n",numLeft + 5,textColors[quit],quitName,WHITE);
							if (quit > 0 && quit < num_bikes - 1) {
								if (quit < myNum) myNum--;
								for (int i = quit; i < num_bikes - 1; i++) {
									numLeft++;
									if (i == myNum) printf("\x1b[%d;0H  You are now %s%s%s!",numLeft + 5,textColors[myNum],colorNames[myNum],WHITE);
									else printf("\x1b[%d;0H  %s%s%s is now %s%s%s!",numLeft + 5, textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE);
									sprites[i] = sprites[i+1];
									sprites[i].image = i;
								}
								quit = -1;
							}
							oldQuit = -1;
							quit = -1;
						}
					/*int foundNum = -1;
					for (int i = 0; i < constatus.total_nodes; i++) {
						numLeft++;
						ret = udsGetNodeInformation(i,&tmpnode);
						udsGetNodeInfoUsername(&tmpnode,&sprites[i - 1].username);
						if (!strcmp(sprites[i].username,myname)) foundNum = i;
						printf("\x1b[%d;0H%s == %s? (%d)\n",numLeft + 5, sprites[i].username, myname,i);
					}
					if (foundNum == -1) myNum = constatus.total_nodes - 1;*/
					num_bikes = constatus.total_nodes;
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					memset(replyChange,1,sizeof(replyChange[0]) * 10);
					}
				}
			}
		}
	}
//---------------------------------------------------------------------------------
int main(int argc, char **argv) {
//---------------------------------------------------------------------------------
	// Initialize graphics
	gfxInitDefault();
	C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);

	// Output at 100% on the first pair of left and right channels.


	// Initialize the render target
	target = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	// Initialize the scene
	sceneInit();
	consoleInit(GFX_BOTTOM, NULL); //Print to bottom screen

	ret = 0;
	ret = udsInit(0x3000, NULL);//The sharedmem size only needs to be slightly larger than the total recv_buffer_size for all binds, with page-alignment.
	uds_enabled = true;
	if(R_FAILED(ret))
	{
		uds_enabled = false;
		if (ret == 0xc9411002) {
			printf("Wi-Fi must be turned on local play!\nBe sure you switch your wifi on\nFor old 3ds, its the switch on the right\n\nPress A or START to play offline.");
		}
		else {
			printf("udsInit failed: 0x%08x.\n\nPress A or START to play offline.", (unsigned int)ret);
		}
		while (1) {
			gspWaitForVBlank();
			gfxFlushBuffers();
			gfxSwapBuffers();
			hidScanInput();
			if (hidKeysDown() & KEY_START) break;
			if (hidKeysDown() & KEY_A) break;
		}
		consoleClear();
	}
	uds_test();
	size_t tmpbuf_size = 0x4000;
	u32 *tmpbuf = malloc(tmpbuf_size);
	size_t actual_size;
	u32 kDown;
	if (debugging) if (CATASTROPHIC_FAILURE) {
		printf("%sCATASTROPHIC_FAILURE\n",RED);
		while (1) {
			gspWaitForVBlank();
			gfxFlushBuffers();
			gfxSwapBuffers();
			hidScanInput();
			if (hidKeysDown() & KEY_START) break;
		}
	}
	if (uds_enabled) {

		if (myNum && !CATASTROPHIC_FAILURE) {
			sprites[myNum].node = myNode;
			memset(sprites[myNum].username,'/0',sizeof(sprites[myNum].username));
			strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
			sprites[myNum].image = myNode;
			sprites[myNum].node = myNode;
			msg.sprite = sprites[myNum];
			msg.sprite.speed = 999; 
			UDSSend(msg);
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick(); 
			if (debugging) printf("Sending quit message...\n");
			while (1) {
				gspWaitForVBlank();
				gfxFlushBuffers();
				gfxSwapBuffers();
				hidScanInput();
				kDown = hidKeysDown();
				if (kDown & KEY_START) {
					if (debugging) printf("...you stopped?\n");
					break;
				}
				if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					sprites[myNum].node = myNode;
					memset(sprites[myNum].username,'/0',sizeof(sprites[myNum].username));
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
					sprites[myNum].image = myNode;
					sprites[myNum].node = myNode;
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 999;
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
				if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
				if(R_FAILED(ret))
				{
					printf("udsPullPacket() returned 0x%08x.\nYou failed to leave the game. Press start.", (unsigned int)ret);
					replay = false;
					CATASTROPHIC_FAILURE = true;
					while (1) {
						gspWaitForVBlank();
						gfxFlushBuffers();
						gfxSwapBuffers();
						hidScanInput();
						kDown = hidKeysDown();
						if (kDown & KEY_START) break;
					}
					break;
				}
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (debugging) printf("image: %d sender: %d node: %d speed: %d\ntimestamp: 0x%08x mine: 0x%08x", msg.sprite.image, msg.sender, msg.sprite.node, msg.sprite.speed, (unsigned long) msg.timestamp, (unsigned long) lastSprite);
					if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.timestamp == lastSprite) { if (debugging) printf("%d leaving: %d\n",myNode,msg.sprite.node); replySprite[msg.sprite.node] = true; }
					int responded = 0;
					for (int i = 0; i <= NUM_SPRITES; i++) {
						if (i != myNode && replySprite[i]) responded++;
					}
					if (responded >= num_bikes - 1) {
						if (debugging) printf("You successfuly left.");
						break;
					}
				}
			}
		}
		if(!myNum)
		{
			udsDestroyNetwork();
		}
		else
		{
			udsDisconnectNetwork();
		}
		udsUnbind(&bindctx);
		udsExit();
	}
	if (!CATASTROPHIC_FAILURE) {
		if (debugging) printf("You were successfully were removed from the game.");
		if (debugging) {
			while (1) {
				gspWaitForVBlank();
				gfxFlushBuffers();
				gfxSwapBuffers();
				hidScanInput();
				kDown = hidKeysDown();
				if (kDown & KEY_START) break;
			}
		}
	}


	// Deinitialize the scene
	sceneExit();

	// Deinitialize graphics
	C3D_Fini();
	gfxExit();
	return 0;
}
