/*

	Simple demo of sprites using citro3d, lodepng and immediate mode.

	Citra doesn't yet emulate immediate mode so this is hw only.

*/

#include <3ds.h>
#include <citro3d.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <errno.h>
#include <stdarg.h>
#include <unistd.h>

#include "lodepng.h"

// These headers are generated by the build process
#include "vshader_shbin.h"
#include "textshader_shbin.h"

#include "bike_png.h"
#include "qrcode_png.h"

#define VERSION "0.1.5"

#define TICK "◯"
#define TICKS_PER_MS 268123
#define TICKS_PER_SEC 268123480
#define CLEAR_COLOR 0x000000FF

#define MOVE_UP 1
#define MOVE_DOWN 2
#define MOVE_LEFT 3
#define MOVE_RIGHT 4
#define TYPE_DEATH 5

#define NORTHEAST 1
#define SOUTHEAST 2
#define SOUTHWEST 3
#define NORTHWEST 4

#define ESC(x) "\x1b[" #x
#define RED     "!.r"
#define GREEN   "!.g"
#define YELLOW  "!.y"
#define BLUE    "!.b"
#define MAGENTA "!.m"
#define CYAN    "!.c"
#define ORANGE  "!.o"
#define DARKGREEN "!.d"
#define PINK "!.p"
#define WHITE "!.w"
#define BLACK "!.z"

// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO)

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGBA8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

#define NUM_SPRITES 10


#define SAMPLERATE 22050
#define SAMPLESPERBUF (SAMPLERATE / 30)
#define BYTESPERSAMPLE 4
#define TEXT_VTX_ARRAY_COUNT (4*1024)

typedef struct { float position[3]; float texcoord[2]; } textVertex_s;

static C3D_Tex* glyphSheets;
static textVertex_s* textVtxArray;
static int textVtxArrayPos = 0;

char consoleBuffer[30][100];
u32 colors[10] = { 0x000cff00, 0x00e4ff00, 0x00004eff, 0x00fc00ff, 0x0000fff0, 0x0025722c, 0x00ff9600, 0x00ff7f82, 0x00ffffff, 0x00000000 };
u64 waitForFinish = 0;
bool uds_enabled = false;
bool readyToStart = false;
bool debugging = false;
int numOptions = 7;
bool options[7] = {false,false,false,false,false,false,false};
char optionNames[7][20] = {"Boundaries kill", "Tron mode", "Disable Diagonals", "Disable A", "Disable B", "Disable Y", "No apple"};
static DVLB_s* vshader_dvlb;
static shaderProgram_s program;
static int uLoc_projection;
static C3D_Mtx projection;

static DVLB_s* textshader_dvlb;
static shaderProgram_s textprogram;
static int textuLoc_projection;
static C3D_Mtx textprojection;

int lastDead = 0;
char mystring[100];
bool cheats = false;
float oldpx = 0;
float oldpy = 0;
int diag = 0;
circlePosition oldCPos;
touchPosition touch;
int wakeup = false;
int myNode = 0;
bool CATASTROPHIC_FAILURE = false;
bool inGame = false;
u16 src_NetworkNodeID;
udsBindContext bindctx;
u64 errorQuit = 0;
bool clearFlag = true;
char myName[50];
char overwriteName[50];
int quit = -1;
u32 dead;
u32 dead2;
bool addedToGame = true;
u64 lastSent = 0;
u64 UDSSent = 0;
circlePosition cpos;

bool replay = true;
bool connectionEstablished = false;
udsConnectionStatus constatus;

bool qrcode = false;
int oldDiag = 0;
u32 nextMove = NULL;
u32 oldMove = NULL;
bool usedSpecial = false;
u32 death = 0;
int myNum = 0;
int growthRate = 40;
int growth[10] = {40,40,40,40,40,40,40,40,40,40};

u32 pathPos[10] = {0,0,0,0,0,0,0,0,0,0};
u32 currentPath[10] = {1,1,1,1,1,1,1,1,1,1};

bool ready[10] = {false, false, false, false, false, false, false, false, false, false};

int bikeSpeed = (2 << 8);
void fill_buffer(void* audioBuffer, size_t offset, size_t size, int frequency) {
	u32* dest = (u32*) audioBuffer;

	for (int i = 0; i < size; i++) {
		// This is a simple sine wave, with a frequency of `frequency` Hz, and an amplitude 30% of maximum.
		s16 sample = 0.3 * 0x7FFF * sin(frequency * (2 * M_PI) * (offset + i) / SAMPLERATE);

		// Stereo samples are interleaved: left and right channels.
		dest[i] = (sample << 16) | (sample & 0xffff);
	}

	DSP_FlushDataCache(audioBuffer, size);
}
//simple sprite struct
typedef struct {
	int x,y;			// screen co-ordinates 
	int dx, dy;			// velocity
	int image;
	int speed;
	int length;
	bool dead;
	int node;
	int diag;
	char username[50];
}Sprite;

typedef struct {
	int x, y;
}Path;

Path path[400 * 240][10];

typedef struct {
	int x, y;
}Apple;

typedef struct {
	Sprite sprite;
	u64 timestamp;
	int sender;
}Message;

u64 lastApple = 0;

int actual_bikes = 1;
Message sentMsg;
u64 lastScore;
u64 lastChange;
u64 lastSprite;
bool replyDead[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyChange[10] = {0,0,0,0,0,0,0,0,0,0};
bool replySprite[10] = {0,0,0,0,0,0,0,0,0,0};

udsNodeInfo tmpnode;
Result ret=0;


u32 gameOver = 0;
Apple apple;
Message msg;
udsConnectionType conntype;

int num_bikes = 1;
Sprite sprites[NUM_SPRITES];

u32 con_type = 0;


C3D_RenderTarget* target;
C3D_RenderTarget* target2;


u64 frameTicks[10];

int score[10] = {0,0,0,0,0,0,0,0,0,0};
int oldscore[10];

int joinedNum = 0;
int oldbikes;

u8* frameBuf;
static float printy = 10.0;
static float printx = 10.0;
int optionsToInt() {
    int ret = 0;
    int tmp;
    for (int i = 0; i < numOptions; i++) {
        tmp = options[i];
        ret |= tmp << (i);
    }
    return ret;
}
setOptions(unsigned int n) {
	for (unsigned int i = 0; i != numOptions; ++i)
	{
	  options[i] = n & 1;
	  n /= 2;
	}
}
static void screen_get_string_size_internal(float* width, float* height, const char* text, float scaleX, float scaleY, bool oneLine, bool wrap, float wrapX) {
    float w = 0;
    float h = 0;
    float lineWidth = 0;

    if(text != NULL) {
        h = scaleY * fontGetInfo()->lineFeed;

        const uint8_t* p = (const uint8_t*) text;
        const uint8_t* lastAlign = p;
        u32 code = 0;
        ssize_t units = -1;
        while(*p && (units = decode_utf8(&code, p)) != -1 && code > 0) {
            p += units;

            if(code == '\n' || (wrap && lineWidth + scaleX * fontGetCharWidthInfo(fontGlyphIndexFromCodePoint(code))->charWidth >= wrapX)) {
                lastAlign = p;

                if(lineWidth > w) {
                    w = lineWidth;
                }

                lineWidth = 0;

                if(oneLine) {
                    break;
                }

                h += scaleY * fontGetInfo()->lineFeed;
            }

            if(code != '\n') {
                u32 num = 1;
                if(code == '\t') {
                    code = ' ';
                    num = 4 - (p - units - lastAlign) % 4;

                    lastAlign = p;
                }

                lineWidth += (scaleX * fontGetCharWidthInfo(fontGlyphIndexFromCodePoint(code))->charWidth) * num;
            }
        }
    }

    if(width) {
        *width = lineWidth > w ? lineWidth : w;
    }

    if(height) {
        *height = h;
    }
}
void screen_get_string_size_wrap(float* width, float* height, const char* text, float scaleX, float scaleY, float wrapX) {
    screen_get_string_size_internal(width, height, text, scaleX, scaleY, false, true, wrapX);
}
static void setTextColor(u32 color)
{
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_RGB, GPU_CONSTANT, 0, 0);
	C3D_TexEnvSrc(env, C3D_Alpha, GPU_TEXTURE0, GPU_CONSTANT, 0);
	C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
	C3D_TexEnvFunc(env, C3D_RGB, GPU_REPLACE);
	C3D_TexEnvFunc(env, C3D_Alpha, GPU_MODULATE);
	C3D_TexEnvColor(env, color);
}

static void addTextVertex(float vx, float vy, float tx, float ty)
{
	textVertex_s* vtx = &textVtxArray[textVtxArrayPos++];
	vtx->position[0] = vx;
	vtx->position[1] = vy;
	vtx->position[2] = 0.5f;
	vtx->texcoord[0] = tx;
	vtx->texcoord[1] = ty;
}
static void renderText(float x, float y, float scaleX, float scaleY, bool baseline, const char* text)
{
	ssize_t  units;
	uint32_t code;

	// Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);
	BufInfo_Add(bufInfo, textVtxArray, sizeof(textVertex_s), 2, 0x10);

	const uint8_t* p = (const uint8_t*)text;
	float firstX = x;
	u32 flags = GLYPH_POS_CALC_VTXCOORD | (baseline ? GLYPH_POS_AT_BASELINE : 0);
	int lastSheet = -1;
	do
	{
		if (!*p) break;
		units = decode_utf8(&code, p);
		if (units == -1)
			break;
		p += units;
		if (code == '\n')
		{
			x = firstX;
			y += scaleY*fontGetInfo()->lineFeed;
		}
		else if (code > 0)
		{
			int glyphIdx = fontGlyphIndexFromCodePoint(code);
			fontGlyphPos_s data;
			fontCalcGlyphPos(&data, glyphIdx, flags, scaleX, scaleY);

			// Bind the correct texture sheet
			if (data.sheetIndex != lastSheet)
			{
				lastSheet = data.sheetIndex;
				C3D_TexBind(0, &glyphSheets[lastSheet]);
			}

			int arrayIndex = textVtxArrayPos;
			if ((arrayIndex+4) >= TEXT_VTX_ARRAY_COUNT)
				break; // We can't render more characters

			// Add the vertices to the array
			addTextVertex(x+data.vtxcoord.left,  y+data.vtxcoord.bottom, data.texcoord.left,  data.texcoord.bottom);
			addTextVertex(x+data.vtxcoord.right, y+data.vtxcoord.bottom, data.texcoord.right, data.texcoord.bottom);
			addTextVertex(x+data.vtxcoord.left,  y+data.vtxcoord.top,    data.texcoord.left,  data.texcoord.top);
			addTextVertex(x+data.vtxcoord.right, y+data.vtxcoord.top,    data.texcoord.right, data.texcoord.top);

			// Draw the glyph
			C3D_DrawArrays(GPU_TRIANGLE_STRIP, arrayIndex, 4);

			x += data.xAdvance;

		}
	} while (code > 0);
}
static void rText(float x, float y, float scaleX, float scaleY, bool baseline, const char* text) {
	setTextColor(0xffffffff); 
	char out[100];
	char sub[100];
	memset(out,'\0',sizeof(out));
	strncpy(out,text,sizeof(out));
	float height;
	float width;
	int i = 0;
	while (strstr(out,"!.") != NULL && i < 40) {
		i++;
		char *result = strstr(out,"!.");
		int position = result - out + 3;
		int substringLength = strlen(out) - position;
		out[position - 3] = '\0';
		renderText(x,y,.5f,.5f,true,out);
		screen_get_string_size_wrap(&width, &height, out, 0.5f, 0.5f, 320);
		x += width;
		if (out[position - 1] == 'r') setTextColor(0xff0000ff);
		else if(out[position - 1] == 'g') setTextColor(colors[0] | 0xff000000);
		else if(out[position - 1] == 'y') setTextColor(0xff00ffe4);
		else if(out[position - 1] == 'b') setTextColor(0xffff4e00);
		else if(out[position - 1] == 'm') setTextColor(0xffff00fc);
		else if(out[position - 1] == 'c') setTextColor(0xfff0ff00);
		else if(out[position - 1] == 'd') setTextColor(0xff2c7225);
		else if(out[position - 1] == 'o') setTextColor(0xff0096ff);
		else if(out[position - 1] == 'p') setTextColor(0xff827fff);
		else if(out[position - 1] == 'w') setTextColor(0xffffffff);
		else if(out[position - 1] == 'z') setTextColor(0xff000000);
		memset(sub,'\0',sizeof(sub));
		snprintf(sub,sizeof(sub),"%.*s",substringLength,out + position);
		result = strstr(sub,"!.");
		if (result != NULL) position = result - sub;
		else position = sizeof(sub);
		memset(out,'\0',sizeof(out));
		snprintf(out,sizeof(out),"%.*s",sizeof(sub) - position,sub + position);
		sub[position] = '\0';
		//sprintf("%.*s",substringLength,out + position);
		renderText(x, y, .5f, .5f, true, sub);
		screen_get_string_size_wrap(&width, &height, sub, 0.5f, 0.5f, 320);
		x += width;
	}
	renderText(x, y, .5f, .5f, true, out);
}
void drawText(int x, int y, u32 color, char *text) {

	//C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
		C3D_FrameDrawOn(target2);
		C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &textprojection);
		setTextColor(color); 
		renderText(10.0f, 10.0f, .5f, .5f, false, "Hello World - working text rendering!\n");
	//C3D_FrameEnd(0);
}
int consolei = 0;
myprintf(const char *format, ...) {
	if (strstr(format,"[") != NULL && format[0] == '\x1b') {
		char sub[100];
		memset(sub,'\0',sizeof(sub));
		char *result = strstr(format,"[");
		int position = result - format + 1;
		int substringLength = strlen(format) - position;
		snprintf(sub,sizeof(sub),"%.*s",substringLength,format + position);
		if (strstr(sub,";") != NULL) {
			char num[20];
			result = strstr(sub,";");
			position = result - sub;
			if (position > 2) return;
			memset(num,'\0',sizeof(num));
			snprintf(num,sizeof(num),"%.*s",position,sub);
			int n;
			sscanf(num,"%d",&n);
			if (n > 15 || n < 0) return;
			if (strstr(sub,"H") == NULL) return;
			result = strstr(sub,"H");
			position = result - sub + 1;
			memset(consoleBuffer[n],'\0',sizeof(consoleBuffer[n]));
			snprintf(consoleBuffer[n],sizeof(consoleBuffer[n]),"%.*s",strlen(sub) - position,sub + position);
			if (n > consolei && n < 14) consolei = n + 1;
			else if (n == consolei && n < 15) consolei++;
			return;
		} else return;
	}
	if (consolei >= 15) {
		for (int i = 0; i < 14; i++) {
			strncpy(consoleBuffer[i],consoleBuffer[i+1],sizeof(consoleBuffer[i]) - 1);
		}
		consolei = 15;
	}
	snprintf(consoleBuffer[consolei], sizeof(consoleBuffer[consolei]), "%s", format);
	if (consolei < 15) consolei += 1;
	return;
}
keepSConsole() {
	keepXConsole();
}
keepConsole() {
	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
	C3D_FrameDrawOn(target2);
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &textprojection);
	keepXConsole();
	C3D_FrameEnd(0);
}
keepXConsole() {
	printy = 10.0;
	setTextColor(0xffffffff); 
	float height;
	float width;
	textVtxArrayPos = 0;
	char out[100];
	char sub[100];
	memset(out,'\0',sizeof(out));
	for (int i = 0; i <= consolei; i++) {
		printx = 0.0;
		if (strlen(consoleBuffer[i]) > 0) {
			strncpy(out,consoleBuffer[i],sizeof(out));
			int i = 0;
			while (strstr(out,"!.") != NULL && i < 40) {
				i++;
				char *result = strstr(out,"!.");
				int position = result - out + 3;
				int substringLength = strlen(out) - position;
				out[position - 3] = '\0';
				renderText(printx,printy,.5f,.5f,true,out);
				screen_get_string_size_wrap(&width, &height, out, 0.5f, 0.5f, 320);
				printx += width;
				if (out[position - 1] == 'r') setTextColor(0xff0000ff);
				else if(out[position - 1] == 'g') setTextColor(colors[0] | 0xff000000);
				else if(out[position - 1] == 'y') setTextColor(0xff00ffe4);
				else if(out[position - 1] == 'b') setTextColor(0xffff4e00);
				else if(out[position - 1] == 'm') setTextColor(0xffff00fc);
				else if(out[position - 1] == 'c') setTextColor(0xfff0ff00);
				else if(out[position - 1] == 'd') setTextColor(0xff2c7225);
				else if(out[position - 1] == 'o') setTextColor(0xff0096ff);
				else if(out[position - 1] == 'p') setTextColor(0xff827fff);
				else if(out[position - 1] == 'w') setTextColor(0xffffffff);
				else if(out[position - 1] == 'z') setTextColor(0xff000000);
				memset(sub,'\0',sizeof(sub));
				snprintf(sub,sizeof(sub),"%.*s",substringLength,out + position);
				result = strstr(sub,"!.");
				if (result != NULL) position = result - sub;
				else position = sizeof(sub);
				memset(out,'\0',sizeof(out));
				snprintf(out,sizeof(out),"%.*s",sizeof(sub) - position,sub + position);
				sub[position] = '\0';
				//sprintf("%.*s",substringLength,out + position);
				renderText(printx, printy, .5f, .5f, true, sub);
				screen_get_string_size_wrap(&width, &height, sub, 0.5f, 0.5f, 320);
				printx += width;
			}
			renderText(printx, printy, .5f, .5f, true, out);
		}
		screen_get_string_size_wrap(NULL, &height, ".", 0.5f, 0.5f, 320);
		printy += height;
		if (printy > 320) break;
	}
}
myconsoleClear() {
	consolei = 0;
	memset(consoleBuffer,'\0',sizeof(consoleBuffer[0][0]) * 60 * 30);
	return;
}
int getLength(int num) {
	if (currentPath[num] < pathPos[num]) return ((400 * 240) - pathPos[num]) + currentPath[num];
	else return currentPath[num] - pathPos[num];
}

struct { float left, right, top, bottom; } images[12] = {
	{0.5f, 0.625f, 0.0f, 0.125f}, //bikes
	{0.625f, 0.75f, 0.0f, 0.125f},
	{0.75f, 0.875f, 0.0f, 0.125f},
	{0.875f, 1.0f, 0.0f, 0.125f},
	{0.5f, 0.625f, 0.125f, 0.25f},
	{0.625f, 0.75f, 0.125f, 0.25f},
	{0.75f, 0.875f, 0.125f, 0.25f},
	{0.875f, 1.0f, 0.125f, 0.25f},
	{0.5f, 0.75f, 0.25f, 0.5f}, //apple
	{0.75f, 1.0f, 0.25f, 0.5f}, //erase
	{0.0f, 0.5f, 0.0f, 0.5f}, //splash screen
	{0.0f, 1.0f, 0.0f, 1.0f}, //qrcode
};
char textColors[10][12] = {GREEN, YELLOW, BLUE, MAGENTA, CYAN, DARKGREEN, ORANGE, PINK, WHITE, WHITE};
char colorNames[10][12] = {"Green", "Yellow", "Blue", "Magenta", "Cyan", "Dark Green", "Orange", "Pink", "White", "Black"};

u32 getColor(int x, int y) {
	if (x > 400) x = 0;
	else if(x < 0) x = 400;
	if (y > 240) y = 0;
	else if (y < 0) y = 240;
	u32 offset = ((x * 240) - y + 239) * 3;
	return (u32) (frameBuf[offset] | frameBuf[offset + 1]  << 8 | frameBuf[offset  + 2] << 16);
}
//---------------------------------------------------------------------------------
void drawSprite( int x, int y, int width, int height, int image ) {
//---------------------------------------------------------------------------------
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, GPU_PRIMARY_COLOR, GPU_PRIMARY_COLOR);
    C3D_TexEnvOp(env, C3D_Both, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR);
    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
	u32 color = getColor(x,y);
	if (image < 10 && width < 100 && height < 100) if (image != 9 && color != colors[8] && color) return;
	float left = images[image].left;
	float right = images[image].right;
	float top = images[image].top;
	float bottom = images[image].bottom;

	// Draw a textured quad directly
	C3D_ImmDrawBegin(GPU_TRIANGLES);
		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
		C3D_ImmSendAttrib( left, top, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( left, bottom, 0.0f, 0.0f);

		C3D_ImmSendAttrib(x+width, y+height, 0.5f, 0.0f);
		C3D_ImmSendAttrib( right, bottom, 0.0f, 0.0f);


	C3D_ImmDrawEnd();

}


static C3D_Tex spritesheet_tex;
static C3D_Tex qrcode_tex;
static int lagMult() {
	if (num_bikes <= 2) return 1;
	return (num_bikes - 2);
}
u32 timeDiff(int num) {
	return (u32)((svcGetSystemTick() - frameTicks[num]) / TICKS_PER_MS / sprites[num].speed);
}
static void UDSResend(bool replied[], Message msg) {
	if (!uds_enabled) return;
	msg.sender = myNum;
	sentMsg = msg;
	ret=0;
	if (msg.sprite.speed == 77) msg.timestamp = lastScore;
	else if (msg.sprite.speed == 66) msg.timestamp = lastChange;
	else msg.timestamp = lastSprite;
	if(conntype!=UDSCONTYPE_Spectator)
	{
		if (debugging) {
			char replies[10];
			memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"replies: ");
			for (int i = 0; i < num_bikes; i++) {
				if (i == myNum) snprintf(replies,sizeof(replies),"-");
				else snprintf(replies,sizeof(replies),"%d",replied[i]);
				strcat(mystring,replies);
			}
			myprintf(mystring);
		}
		for (int i = 0; i < num_bikes; i++) {
			if (!replied[i] && i != myNum && sprites[i].node) {
				if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"resending to... %d: %d",i,sprites[i].node); myprintf(mystring); }
				ret = udsSendTo(sprites[i].node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
				if (UDS_CHECK_SENDTO_FATALERROR(ret))
				{
					if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"Error: UDSResend() returned 0x%08x.",(unsigned int)ret); myprintf(mystring); }
				}
			}
		}
	}
}

static bool allReplied(bool replied[]) {
	for (int i = 0; i < num_bikes; i++) {
		if (!replied[i] && i != myNum) return false;
	}
	return true;
}
static int UDSDirect(int node, Message msg) {
	msg.sender = myNum;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		if (debugging) { snprintf(mystring,sizeof(mystring),"direct to %d: img: %d speed: %d",node,msg.sprite.image,msg.sprite.speed); myprintf(mystring); }
		ret = udsSendTo(node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			snprintf(mystring,sizeof(mystring),"Error: UDSDirect() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			CATASTROPHIC_FAILURE = true;
			return 1;
		}
	}
	return 0;
}
static int UDSSend(Message msg) {
	if (!uds_enabled) return;
	msg.sender = myNum;
	if (debugging) { snprintf(mystring,sizeof(mystring),"sending speed: %d image: %d diag: %d",msg.sprite.speed,msg.sprite.image,msg.sprite.diag); myprintf(mystring); }
	if (msg.sprite.image == myNum && msg.sprite.speed == 77) { msg.timestamp = lastScore; }
	else if (msg.sprite.image == myNum && msg.sprite.speed == 66) { msg.timestamp = lastChange; }
	else if (msg.sprite.image == myNum) { msg.timestamp = lastSprite; }
	else if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.sprite.node == myNode) { msg.timestamp = lastSprite; msg.sender = myNode; }
	sentMsg = msg;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		ret = udsSendTo(UDS_BROADCAST_NETWORKNODEID, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			snprintf(mystring,sizeof(mystring),"Error: UDSSend() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			CATASTROPHIC_FAILURE = true;
			return 1;
		}
	}
	return 0;
}
bool itsATie() {
	int s = score[0];
	int winner = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] > s) { s = score[i]; winner = i; }
	}
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] == s && i != winner) return true;
	}
	return false;
}
int getHighestScore() {
	int highestScore = 0;
	if (itsATie()) return -1;
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] > highestScore) {
			highestScore = score[i];
			r = i;
		}
	}
	return r;
}
int theHighest() {
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (r < score[i]) r = score[i];
	}
	return r;
}
bool everyoneElseIsDead() {
	if (actual_bikes <= 1) {
		if (sprites[0].dead) return true;
		return false;
	}
	for (int i = 0; i < num_bikes; i++) {
		if (i != myNum && !sprites[i].dead) return false;
	}
	return true;
}
bool allReady() {
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) return false;
	}
	return true;
}
int notReadies() {
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) r++;
	}
	return r;
}
int getKiller(u32 color) {
	for (int i = 0; i < NUM_SPRITES; i++) {
		if (color == colors[i]) return i;
	}
	return 0;
}
bool hasCommonY(int num) {
	if (sprites[num].y < (1 << 8) || sprites[num].y > (398 << 8)) return true;
	if (abs((sprites[num].y >> 8) - (apple.y >> 8)) < 3) return true;
	for (int i = 0; i < num; i++) {
		if (abs((sprites[i].y >> 8) - (sprites[num].y >> 8)) < 3) return true;
	}
	return false;
}
static void setSprites() {
	srand(time(NULL));
	usedSpecial = false;
	memset(path, 0, sizeof(path[0][0]) * 240 * 400 * 10);
	apple.x = (rand() % (400 - 32)) << 8;
	apple.y = (rand() % (240 - 32)) << 8;
	for(int i = 0; i < NUM_SPRITES; i++) {
		//random place and speed
		sprites[i].x = (rand() % (400 - 32 )) << 8;
		sprites[i].y = (rand() % (240 - 32 )) << 8 ;
		while (hasCommonY(i)) {
			sprites[i].y = (rand() % (240 - 32 )) << 8 ;
		}
		sprites[i].dx = (2<<8);
		sprites[i].dy = 0;
		sprites[i].image = i;
		sprites[i].speed = 45;
		sprites[i].dead = false;
		sprites[i].diag = 0;

		memset(sprites[i].username,'\0',sizeof(sprites[i].username));
		path[0][i].x = sprites[i].x;
		path[0][i].y = sprites[i].y;

		if (!options[1]) sprites[i].length = 40;
		else sprites[i].length = 240 * 400;
		growth[i] = 0;
		currentPath[i] = 1;
		pathPos[i] = 0;

		if(rand() & 1)
			sprites[i].dx = -sprites[i].dx;
		if(rand() & 1)
			sprites[i].dy = -sprites[i].dy;
		if(options[0]) {
			if ((sprites[i].x >> 8) < 100) sprites[i].dx = abs(sprites[i].dx);
			if ((sprites[i].x >> 8) > 300 && sprites[i].dx) sprites[i].dx = abs(sprites[i].dx) * -1;
		}
	}
	if (options[6]) {
		apple.x = 500 << 8;
		apple.y = 500 << 8;
	}
}
static void changeApple() {
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 9);
	apple.x = (rand() % (400 - 32)) << 8;
	apple.y = (rand() % (240 - 32)) << 8;
	while (getColor(apple.x >> 8, apple.y >> 8)) {
		apple.x = (rand() % (400 - 32)) << 8;
		apple.y = (rand() % (240 - 32)) << 8;
	}
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 66;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
}
static void moveApple() {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = (rand() % (400 - 32)) << 8;
	apple.y = (rand() % (240 - 32)) << 8;
	while (getColor(apple.x >> 8, apple.y >> 8)) {
		apple.x = (rand() % (400 - 32)) << 8;
		apple.y = (rand() % (240 - 32)) << 8;
	}
	drawSprite(oldx >> 8, oldy >> 8, 2, 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 77;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
	usedSpecial = false;
}
static void updateApple(int x, int y) {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx >> 8, oldy >> 8, 2 , 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
}
static void setApple(int player, int x, int y) {
	if (abs(player) > num_bikes) return;
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx >> 8, oldy >> 8, 2 , 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	//score[player]++;
	growth[player] += growthRate;
	//sprites[player].length += growthRate;
	usedSpecial = false;
}
void print_constatus()
{
	ret=0;
	u32 pos;
	

	//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
	ret = udsGetConnectionStatus(&constatus);
	if(R_FAILED(ret))
	{
		myprintf("udsGetConnectionStatus() returned 0x%08x.", (unsigned int)ret);
		CATASTROPHIC_FAILURE = true;
		return;
	}
	else
	{
		if (debugging) {
			myprintf("constatus:\nstatus=0x%x", (unsigned int)constatus.status);
			myprintf("1=0x%x", (unsigned int)constatus.unk_x4);
			myprintf("cur_NetworkNodeID=0x%x", (unsigned int)constatus.cur_NetworkNodeID);
			myprintf("unk_xa=0x%x", (unsigned int)constatus.unk_xa);
			for(pos=0; pos<(0x20>>2); pos++)myprintf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
			myprintf("\ntotal_nodes=0x%x", (unsigned int)constatus.total_nodes);
			myprintf("max_nodes=0x%x", (unsigned int)constatus.max_nodes);
			myprintf("node_bitmask=0x%x", (unsigned int)constatus.total_nodes);
		}
	}
}
u64 debugLastSent;
u64 debugUDSSent;
//---------------------------------------------------------------------------------
static void sceneInit(void) {
//---------------------------------------------------------------------------------
	for (int i = 0; i < 30; i++) {
		memset(consoleBuffer[i],'\0',sizeof(consoleBuffer[i]));
	}
	memset(path,0,sizeof(path[0][0]) * 400 * 240 * 3);
	// Load the vertex shader, create a shader program and bind it
	vshader_dvlb = DVLB_ParseFile((u32*)vshader_shbin, vshader_shbin_len);
	shaderProgramInit(&program);
	shaderProgramSetVsh(&program, &vshader_dvlb->DVLE[0]);
	C3D_BindProgram(&program);

	// Get the location of the uniforms
	uLoc_projection = shaderInstanceGetUniformLocation(program.vertexShader, "projection");


	/*textshader_dvlb = DVLB_ParseFile((u32*)textshader_shbin, textshader_shbin_len);
	shaderProgramInit(&textprogram);
	shaderProgramSetVsh(&textprogram, &textshader_dvlb->DVLE[0]);
	C3D_BindProgram(&textprogram);

	// Get the location of the uniforms
	textuLoc_projection = shaderInstanceGetUniformLocation(textprogram.vertexShader, "textprojection");*/

	// Configure attributes for use with the vertex shader
	// Attribute format and element count are ignored in immediate mode
	C3D_AttrInfo* attrInfo = C3D_GetAttrInfo();
	AttrInfo_Init(attrInfo);
	AttrInfo_AddLoader(attrInfo, 0, GPU_FLOAT, 3); // v0=position
	AttrInfo_AddLoader(attrInfo, 1, GPU_FLOAT, 2); // v2=texcoord

	// Compute the projection matrix
	// Note: we're setting top to 240 here so origin is at top left.
	Mtx_OrthoTilt(&projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0, true);


	// Configure buffers
	C3D_BufInfo* bufInfo = C3D_GetBufInfo();
	BufInfo_Init(bufInfo);

	unsigned char* image;
	unsigned width, height;

	lodepng_decode32(&image, &width, &height, bike_png, bike_png_size);
	u8 *gpusrc = linearAlloc(width*height*4);

	// GX_DisplayTransfer needs input buffer in linear RAM
	u8* src=image; u8 *dst=gpusrc;

	// lodepng outputs big endian rgba so we need to convert
	for(int i = 0; i<width*height; i++) {
		int r = *src++;
		int g = *src++;
		int b = *src++;
		int a = *src++;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, width*height*4);

	// Load the texture and bind it to the first texture unit
	C3D_TexInit(&spritesheet_tex, width, height, GPU_RGBA8);

	// Convert image to 3DS tiled texture format
	GX_DisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(width,height), (u32*)spritesheet_tex.data, GX_BUFFER_DIM(width,height), TEXTURE_TRANSFER_FLAGS);
	gspWaitForPPF();

	C3D_TexSetFilter(&spritesheet_tex, GPU_LINEAR, GPU_NEAREST);
	C3D_TexBind(0, &spritesheet_tex);

	lodepng_decode32(&image, &width, &height, qrcode_png, qrcode_png_size);
	gpusrc = linearAlloc(width*height*4);

	// GX_DisplayTransfer needs input buffer in linear RAM
	src=image; dst=gpusrc;

	// lodepng outputs big endian rgba so we need to convert
	for(int i = 0; i<width*height; i++) {
		int r = *src++;
		int g = *src++;
		int b = *src++;
		int a = *src++;

		*dst++ = a;
		*dst++ = b;
		*dst++ = g;
		*dst++ = r;
	}

	// ensure data is in physical ram
	GSPGPU_FlushDataCache(gpusrc, width*height*4);

	// Load the texture and bind it to the first texture unit
	C3D_TexInit(&qrcode_tex, width, height, GPU_RGBA8);

	// Convert image to 3DS tiled texture format
	GX_DisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(width,height), (u32*)qrcode_tex.data, GX_BUFFER_DIM(width,height), TEXTURE_TRANSFER_FLAGS);
	gspWaitForPPF();

	C3D_TexSetFilter(&qrcode_tex, GPU_LINEAR, GPU_NEAREST);

	//C3D_TexBind(0, &qrcode_tex);
	free(image);
	linearFree(gpusrc);

	// Configure the first fragment shading substage to just pass through the texture color
	// See https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnv.xml for more insight
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, GPU_PRIMARY_COLOR, GPU_PRIMARY_COLOR);
    C3D_TexEnvOp(env, C3D_Both, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR, GPU_TEVOP_RGB_SRC_COLOR);
    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
	


	setSprites();
	// Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
	C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);

	Mtx_OrthoTilt(&textprojection, 0.0, 320.0, 240.0, 0.0, 0.0, 1.0, true);
	int i;
	TGLP_s* glyphInfo = fontGetGlyphInfo();
	glyphSheets = malloc(sizeof(C3D_Tex)*glyphInfo->nSheets);
	for (i = 0; i < glyphInfo->nSheets; i ++)
	{
		C3D_Tex* tex = &glyphSheets[i];
		tex->data = fontGetGlyphSheetTex(i);
		tex->fmt = glyphInfo->sheetFmt;
		tex->size = glyphInfo->sheetSize;
		tex->width = glyphInfo->sheetWidth;
		tex->height = glyphInfo->sheetHeight;
		tex->param = GPU_TEXTURE_MAG_FILTER(GPU_LINEAR) | GPU_TEXTURE_MIN_FILTER(GPU_LINEAR)
			| GPU_TEXTURE_WRAP_S(GPU_CLAMP_TO_EDGE) | GPU_TEXTURE_WRAP_T(GPU_CLAMP_TO_EDGE);
	}

	// Create the text vertex array
	textVtxArray = (textVertex_s*)linearAlloc(sizeof(textVertex_s)*TEXT_VTX_ARRAY_COUNT);

	frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);


}
static void printScore() {
	if (!options[6]) {
		memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[0;0HScore: ");
		char scores[12];
		for (int i = 0; i < num_bikes; i++) {
			snprintf(scores,sizeof(scores),"%s%d", textColors[i],score[i]);
			strcat(mystring,scores);
			if (i < num_bikes - 1) { snprintf(scores,sizeof(scores)," %s- ",WHITE); strcat(mystring,scores); }
		}
		myprintf(mystring);
	} else {
		memset(mystring,'\0',sizeof(mystring));
		snprintf(mystring,sizeof(mystring),"\x1b[0;0HAlive: ");
		char living[50];
		for (int i = 0; i < actual_bikes; i++) {
			if (!sprites[i].dead) {
				memset(living,'\0',sizeof(living));
				snprintf(living,sizeof(living),"%s%s%s",textColors[i],sprites[i].username,WHITE);
				strcat(mystring,living);
				if (i < actual_bikes - 1) strcat(mystring,", ");
			}
		}
		myprintf(mystring);
	}
	death = dead;
	if (!death) death = dead2;
	if (sprites[myNum].dead) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sYou are %sdead%s (%s%s%s)",WHITE,RED,WHITE,textColors[getKiller(death)],sprites[getKiller(death)].username,WHITE); myprintf(mystring); }
	else { 
		memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sYou are %salive%s! ",WHITE,GREEN,WHITE);
		myprintf(mystring);
		if (everyoneElseIsDead()) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[6;0HGet %d more points!",theHighest() - score[myNum] + 1); myprintf(mystring); }
	}
	if (!options[3]) {
		memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[2;0HHold %s%s to move Faster.",RED,WHITE);
		myprintf(mystring);
	}
	if (!options[4]) {
		memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[3;0HHold %s%s to move Slower.",YELLOW,WHITE);
		myprintf(mystring);
	}
	if (!options[5]) {
		memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[4;0HPress %s%s to teleport the apple once.",GREEN,WHITE);
		myprintf(mystring);
	}
	int x = 5;
	for (int i = actual_bikes; i < num_bikes; i++) {
		memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s has joined the game.",x + i - actual_bikes,textColors[i],sprites[i].username,WHITE);
		myprintf(mystring);
	}
	if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[5;0Hactual_bikes: %d mynum: %d %d",actual_bikes, myNum, num_bikes); myprintf(mystring); }
	//myprintf("\x1b[5;0Hdead: 0x%08x, 0x%08x",dead,dead2);
	//myprintf("\x1b[6;0Hnum_bikes: %d, myNum: %d",num_bikes,myNum);
	//myprintf("\x1b[7;0Hgrowth: %d length: %d (%d)",growth[myNum],sprites[myNum].length,getLength(myNum));
	//myprintf("\x1b[8;0HpathPos: %d currentPath: %d",pathPos[myNum],currentPath[myNum]);
}
static void drawLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, int img) {
	int w = (dx >> 8) - (sx >> 8);
	int h = (dy >> 8) - (sy >> 8);
	int x = sx;
	int y = sy;
	if (w < 0 || h < 0) { 
		x = dx;
		y = dy;
	}
	w = abs(w);
	h = abs(h);
	//drawSprite(x >> 8, y >> 8, w, h, img);
	if (w <= 2) { h = 2 << 8; w = 0; }
	else { h = 0; w = 2 << 8; }
	while (pathnum != currentPath[img]) {
		drawSprite(path[pathnum][img].x >> 8, path[pathnum][img].y >> 8, 2, 2, 9);
		drawSprite(x >> 8, y >> 8, 2, 2, img);
		path[pathnum][img].x = x;
		x += w;
		path[pathnum][img].y = y;
		y += h;
		pathnum++;
		if (pathnum > 240 * 400) pathnum = 0;
	}
	path[pathnum][img].x = x;
	path[pathnum][img].y = y;
	drawSprite(x >> 8, y >> 8, 2, 2, img);
}
static void eraseOvershoot(Sprite sprite) {
	int img = sprite.image;
	int cx = path[currentPath[img]][img].x >> 8;
	int cy = path[currentPath[img]][img].y >> 8;
	int udx = sprite.x >> 8;
	int udy = sprite.y >> 8;
	if (cx == udx && cy == udy) return;
	int pathn = currentPath[img];
	int i = 0;
	while ((path[pathn][img].x >> 8) != udx && (path[pathn][img].y >> 8) != udy && pathn != pathPos[img] && i < 40) {
		i++;
		drawSprite(path[pathn][img].x >> 8, path[pathn][img].y >> 8, 2, 2, 9);
		pathn--;
		if (pathn < 0) pathn = 240 * 400;
	}
}
static void finishLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, Sprite msg, int img) {
	if ((sx >> 8) == (dx >> 8) && (sy >> 8) == (dy >> 8)) {
		drawSprite(sy,dy,2,2,img);
		return;
	}
	int udx = dx >> 8;
	int udy = dy >> 8;
	int x = sx >> 8;
	int y = sy >> 8;
	int w = udx - x;
	int h = udy - y;
	if (abs(w) > 100 || abs(h) > 100) return;



	//drawSprite(x >> 8, y >> 8, w, h, img);
	int pathn = currentPath[img] - 1;
	if (pathn < 0) pathn = 240 * 400;
	int prevx = path[pathn][img].x >> 8;
	int prevy = path[pathn][img].y >> 8;
	pathn--;
	if (pathn < 0) pathn = 240 * 400;
	int prevx2 = path[pathn][img].x >> 8;
	int prevy2 = path[pathn][img].y >> 8;
	pathn = currentPath[img];
	int i = 0;
	if (x != udx && y != udy) {
		int tx, ty;
		if (w < 0) tx = -2;
		else tx = 2;
		if (h < 0) ty = -2;
		else ty = 2;
	
		if ((prevx - prevx2 > 0 && w > 0) || (prevx - prevx2 < 0 && w < 0) || (prevy - prevy2 > 0 && h > 0) || (prevy - prevy2 < 0 && h < 0)) {//draw
			if (sprites[img].diag && x != udx && y != udy) {
				if (debugging) myprintf("OMG");
				pathn = currentPath[img];
				while (x != udx && y != udy && i < 40) {
					i++;
					drawSprite(x,y,2,2,9);
					pathn--;
					if (pathn < 0) pathn = 240 * 400;
					x = path[pathn][img].x >> 8;
					y = path[pathn][img].y >> 8;
				}
				pathn++;
				if (pathn > 240 * 400) pathn = 0;
				i = 0;
				if (x != udx) while (x != udx && i < 40) { i++; drawSprite(x,y,2,2,img); path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; pathn++; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0;  if (pathn > 240 * 400) pathn = 0; x += tx; }
				else while (y != udy && i < 40) { i++; drawSprite(x,y,2,2,img); path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; pathn++; if (pathn > 240 * 400) pathn = 0; y += ty; }
			}
			path[pathn][img].x = x << 8;
			path[pathn][img].y = y << 8;

		} 
		else { //erase
			if (debugging) myprintf("!!!!");
			if (prevx == prevx2) {
				while ((path[pathn][img].y >> 8) != udy && i < 20) { i++; drawSprite(path[pathn][img].x >> 8,path[pathn][img].y >> 8,2,2,9); pathn--; }
				x = path[pathn][img].x >> 8;
				y = path[pathn][img].y >> 8;
				i = 0;
				drawSprite(x,y,2,2,img);
				while ((path[pathn][img].x >> 8) != udx && i < 20) { i++; x += tx; pathn++; drawSprite(x,y,2,2,img); path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; if (pathn > 240 * 400) pathn = 0; }
				//if (pathn == currentPath[img]) currentPath[img]++;
				if (currentPath[img] > 240 * 400) currentPath[img] = 0;
			}
			else if (prevy == prevy2) {
				while ((path[pathn][img].x >> 8) != udx && i < 20) { i++; drawSprite(path[pathn][img].x >> 8,path[pathn][img].y >> 8,2,2,9); pathn--; }
				x = path[pathn][img].x >> 8;
				y = path[pathn][img].y >> 8;
				i = 0;
				drawSprite(x,y,2,2,img);
				while ((path[pathn][img].y >> 8) != udy && i < 20) { i++; y += ty; drawSprite(x,y,2,2,img); pathn++; path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; if (pathn > 240 * 400) pathn = 0; }
				//if (pathn == currentPath[img]) currentPath[img]++;
				if (currentPath[img] > 240 * 400) currentPath[img] = 0;
			} else if (sprites[img].diag) {
				if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%sYEP%s",RED,WHITE); myprintf(mystring); }
			}
			drawSprite(dx,dy,2,2,img);
		}
		return;
	}


	if (w == 0) { 
		if (h < 0) h = -2; 
		else h = 2; 
		w = 0; 
	}
	else { 
		h = 0; 
		if (w < 0) w = -2; 
		else w = 2; 
	}

	if (w != 0 && h != 0) return;

	//Erase overshoot.
	dx = dx >> 8;
	dy = dy >> 8;
	if (x != udx && y != udy) return;

	i = 0;

	//Now fill in shortcomings.
	int c = rand() % 9;
	if (udx == prevx && udy == prevy) {
		if (debugging) {
			while (c == img) c = rand() % 9;
			memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%s%d .. %d%s",textColors[c],udx,udy,WHITE);
			myprintf(mystring);
			drawSprite(sx >> 8,sy >> 8,2,2,c);
			drawSprite(dx, dy, 2, 2, c);
		}
		return;
	}
	if (debugging) {
		while (c == img) c = rand() % 9;
		memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%sok.%s",textColors[c],WHITE);
		myprintf(mystring);
	}
	//drawSprite(sx,sy,2,2,c);
	while ((x != dx || y != dy) && (i < 4)) {
		i++;	

		path[currentPath[img]][img].y = (y << 8);
		path[currentPath[img]][img].x = (x << 8);
		drawSprite(x, y, 2, 2, img);
		currentPath[img]++;
		if (currentPath[img] > 240 * 400) currentPath[img] = 0;
		x += w;
		
		y += h;
		
	}
	path[currentPath[img]][img].y = (y << 8);
	path[currentPath[img]][img].x = (x << 8);
}
static void gameOptions() {
	myconsoleClear();
	char onOrOff[5];
	char selectedColor[5];
	int selected = 0;
	u32 kDown;
	while (1) {
		keepConsole();
		for (int i = 0; i < numOptions; i++) {
			if (options[i]) snprintf(onOrOff,sizeof(onOrOff),WHITE);
			else snprintf(onOrOff,sizeof(onOrOff),BLACK);
			if (selected == i) snprintf(selectedColor,sizeof(selectedColor),YELLOW);
			else snprintf(selectedColor,sizeof(selectedColor),WHITE);
			snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s%s%s",i,onOrOff,TICK,selectedColor,optionNames[i],WHITE);
			myprintf(mystring);
		}
		hidScanInput();
		kDown = hidKeysDown();
		if (kDown & KEY_DUP || kDown & KEY_CPAD_UP) selected--;
		else if (kDown & KEY_DDOWN || kDown & KEY_CPAD_DOWN) selected++;
		if (selected >= numOptions) selected = 0;
		else if (selected < 0) selected = numOptions - 1;
		if (kDown & KEY_A) {
			if (options[selected]) options[selected] = false;
			else options[selected] = true;
		}
		if (kDown & KEY_START || kDown & KEY_SELECT || kDown & KEY_B) break;
	}
}
//---------------------------------------------------------------------------------
static void moveSprites() {
//---------------------------------------------------------------------------------
	int i;
	for(i = 0; i < num_bikes; i++) {
		if (sprites[i].dead || !timeDiff(i)) continue;
		if (i != myNum && sprites[i].diag) {
			if (sprites[i].diag == NORTHEAST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx * -1;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy * -1;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == SOUTHEAST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == SOUTHWEST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx * -1;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy * -1;
					sprites[i].dy = 0;
				}
			} else if (sprites[i].diag == NORTHWEST) {
				if (sprites[i].dx) {
					sprites[i].dy = sprites[i].dx;
					sprites[i].dx = 0;
				} else {
					sprites[i].dx = sprites[i].dy;
					sprites[i].dy = 0;
				}
			}
		}
		sprites[i].x += sprites[i].dx;
		sprites[i].y += sprites[i].dy;
		if(sprites[i].x < (2<<8)) sprites[i].x = (398) << 8;
		else if (sprites[i].x > ((398) << 8)) sprites[i].x = (2<<8);

		if(sprites[i].y < (2<<8)) sprites[i].y = (238 << 8);
		else if (sprites[i].y > (238 << 8)) sprites[i].y = (2<<8);

		frameTicks[i] = svcGetSystemTick();
		while (getLength(i) * .9 > sprites[i].length) {
			drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
			pathPos[i]++;
		}
		if (growth[i]) growth[i]--;
		else if (getLength(i) >= sprites[i].length) {
			drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
			pathPos[i]++;
		}
		currentPath[i]++;
		if (pathPos[i] > 400 * 240) pathPos[i] = 0;
		if (currentPath[i] > 400 * 240) currentPath[i] = 0;
		path[currentPath[i]][i].x = sprites[i].x;
		path[currentPath[i]][i].y = sprites[i].y;
		if (i == myNum && !sprites[myNum].dead) {
			u32 color1 = getColor(sprites[i].x >> 8, sprites[i].y >> 8);
			u32 color2 = getColor((sprites[i].x >> 8) + 1, (sprites[i].y >> 8) + 1);
			if (svcGetSystemTick() - lastApple > TICKS_PER_MS * 15 * 6 * lagMult()) if (abs((sprites[i].x >> 8) - (apple.x >> 8)) <= 2 && abs((sprites[i].y >> 8) - (apple.y >> 8)) <= 2) {
				lastApple = svcGetSystemTick();
				score[i]++;
				growth[i] += growthRate;
				sprites[i].length += growthRate;
				memset(replyScore,0,sizeof(replyScore[0]) * 10);
				moveApple();
				if (debugging) myprintf("Got apple.");
			}
			else if (getLength(i) < 5) {} //don't die if game just started
			else if ((color1 != colors[8] && color2 != colors[8]) && (color1 > 0 || color2 > 0)) {
				dead = color1;
				dead2 = color2;
				lastDead = i;
				sprites[i].dead = true;
				msg.sprite = sprites[i];
				memset(replySprite,0,sizeof(replySprite[0]) * 10);
				lastSprite = svcGetSystemTick();
				UDSSend(msg); //dead
			}
		}
	}
}

//---------------------------------------------------------------------------------
static void sceneRender(void) {
//---------------------------------------------------------------------------------
	int i;
	// Update the uniforms
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);

	for(i = 0; i < num_bikes; i++) {
		if (i < actual_bikes) { 
			drawSprite( sprites[i].x >> 8, sprites[i].y >> 8, 2, 2, sprites[i].image);
			if ((path[currentPath[i]][i].x >> 8) != (sprites[i].x >> 8) || (path[currentPath[i]][i].y >> 8) != (sprites[i].y >> 8)) {
				currentPath[i]++;
				path[currentPath[i]][i].x = sprites[i].x;
				path[currentPath[i]][i].y = sprites[i].y;
			}
		}
		drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
	}

}
//---------------------------------------------------------------------------------
static void sceneExit(void) {
//---------------------------------------------------------------------------------

	// Free the shader program
	free(glyphSheets);
	shaderProgramFree(&program);
	DVLB_Free(vshader_dvlb);
	shaderProgramFree(&textprogram);
	DVLB_Free(textshader_dvlb);
}
static SwkbdCallbackResult wrongName(void* user, const char** ppMessage, const char* text, size_t textlen)
{

	if(strstr(text,"\x1b["))
	{
		*ppMessage = "Nope.";
		return SWKBD_CALLBACK_CONTINUE;
	}
	if(strstr(text, "!."))
	{
		*ppMessage = "Nice try.";
		return SWKBD_CALLBACK_CONTINUE;
	}
	if (strstr(text, "host"))
	{
		*ppMessage = "Just no.";
		return SWKBD_CALLBACK_CONTINUE;
	}

	return SWKBD_CALLBACK_OK;
}
void uds_test()
{
	memset(overwriteName,'\0',sizeof(overwriteName));
	ret=0;
	con_type=0;


	for (int i = 0; i < NUM_SPRITES; i++) {
		memset(sprites[i].username,'\0',sizeof(sprites[i].username));
	}
	u8 data_channel = 1;
	udsNetworkStruct networkstruct;
	udsNetworkScanInfo *networks = NULL;
	udsNetworkScanInfo *network = NULL;
	size_t total_networks = 0;

	u32 recv_buffer_size = UDS_DEFAULT_RECVBUFSIZE;
	u32 wlancommID = 0x783a9dab;//Unique ID, change this to your own.
	char *passphrase = "dandewsudssnake.1.5 saadistheman";//Change this passphrase to your own. The input you use for the passphrase doesn't matter since it's a raw buffer.

	conntype = UDSCONTYPE_Client;

	size_t actual_size;
	u32 tmp=0;
	u32 pos;

	u8 appdata[0x14] = {0x69, 0x8a, 0x05, 0x5c};

	char tmpstr[256];

	strncpy((char*)&appdata[4], "Test appdata.", sizeof(appdata)-1);

	//myprintf("Successfully initialized.\n");

	size_t tmpbuf_size = 0x4000;
	u32 *tmpbuf = malloc(tmpbuf_size);
	if(tmpbuf==NULL)
	{
		myprintf("Failed to allocate tmpbuf for beacon data.\n");
		return;
	}
	int hosting = 0;
	int readyToJoin = 0;

	//gspWaitForVBlank();
	//snprintf(mystring,sizeof(mystring),"\x1b[1;0H%sg %sy %sb %sm %sc %sdg %so %sp",GREEN, YELLOW, BLUE, MAGENTA, CYAN, DARKGREEN, ORANGE, PINK);
	//myprintf(mystring);
	memset(mystring,'\0',sizeof(mystring)); 
	snprintf(mystring,sizeof(mystring),"Version %s",VERSION);
	myprintf(mystring);
	myprintf("\x1b[2;0HHold  to host"); myprintf("Press  to scan for a host."); myprintf("Press  to change name."); myprintf("Press SELECT for game modes."); myprintf("Press START to exit.");
	bool ignoreB = false;
	while (aptMainLoop()) {
		hidScanInput();

		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			if (qrcode) C3D_TexBind(0, &qrcode_tex);
			else C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			if (qrcode) drawSprite(72,0,240,240,11);
			else drawSprite(72,0,256,256,10);
		C3D_FrameEnd(0);

		keepConsole();

		gfxFlushBuffers();
		gfxSwapBuffers();


		//myprintf("Version %s\n\nHold A to host\nPress B to scan for a host.\nPress Y to change name.\nPress X for QRCode to latest release.\nPress START to exit.\n",VERSION);
		// Respond to user input
		u32 kDown = hidKeysDown();
		u32 kHeld = hidKeysHeld();
		u32 kUp = hidKeysUp();
		if (kDown & KEY_START) return;
		if (kDown & KEY_SELECT) { gameOptions(); myconsoleClear(); ignoreB = true; snprintf(mystring,sizeof(mystring),"Version %s",VERSION); myprintf(mystring); myprintf("\x1b[2;0HHold  to host"); myprintf("Press  to scan for a host."); myprintf("Press  to change name."); myprintf("Press SELECT for game modes."); myprintf("Press START to exit."); }
		if (kDown & KEY_L) { debugging = true; myprintf("Debugging turned on."); }
		if (kDown & KEY_A) { hosting = 1; break; }
		if (kHeld & KEY_R && kDown & KEY_X) { cheats = true; myprintf("Move the apple with touchscreen!"); snprintf(overwriteName,sizeof(overwriteName),"Cheater"); }
		else if (kDown & KEY_X) qrcode = true;
		else if (kDown & KEY_Y) {
			if (strstr(overwriteName,"Cheater") == NULL) {
				static SwkbdState swkbd;
				static char mybuf[20];
				static SwkbdStatusData swkbdStatus;
				static SwkbdLearningData swkbdLearning;
				SwkbdButton button = SWKBD_BUTTON_NONE;
				swkbdInit(&swkbd, SWKBD_TYPE_NORMAL, 3, -1);
				swkbdSetValidation(&swkbd, SWKBD_NOTEMPTY_NOTBLANK, 0, 0);
				swkbdSetFilterCallback(&swkbd, wrongName, NULL);
				swkbdSetInitialText(&swkbd, mybuf);
				swkbdSetHintText(&swkbd, "Please enter your name");
				swkbdSetButton(&swkbd, SWKBD_BUTTON_LEFT, "Cancel", false);
				
				swkbdSetButton(&swkbd, SWKBD_BUTTON_RIGHT, "Done", true);
				swkbdSetFeatures(&swkbd, SWKBD_PREDICTIVE_INPUT);
				SwkbdDictWord words[2];
				swkbdSetDictWord(&words[0], "lenny", "( ͡° ͜ʖ ͡°)");
				swkbdSetDictWord(&words[1], "shrug", "¯\\_(ツ)_/¯");
				swkbdSetDictionary(&swkbd, words, sizeof(words)/sizeof(SwkbdDictWord));
				static bool reload = false;
				swkbdSetStatusData(&swkbd, &swkbdStatus, reload, true);
				swkbdSetLearningData(&swkbd, &swkbdLearning, reload, true);
				reload = true;
				button = swkbdInputText(&swkbd, mybuf, sizeof(mybuf));
				if (button != SWKBD_BUTTON_NONE && strlen(mybuf) > 0) { 
					memset(overwriteName,'\0',sizeof(overwriteName));
					strncpy(overwriteName,mybuf,sizeof(overwriteName));
					memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"Welcome, %s",overwriteName);
					myprintf(mystring);
				} else myprintf("Name set to default.");
			} else myprintf("You can't change your name with cheats enabled!");
		}
		else if (!ignoreB) if((kDown & KEY_B) || (kHeld & KEY_B)) {
			myprintf("Scanning...");
			while (1) {
				//gspWaitForVBlank();
				hidScanInput();

				keepConsole();
				kHeld = hidKeysHeld();
				kDown = hidKeysDown();
				if (!(kHeld & KEY_B)) break;
				total_networks = 0;
				memset(tmpbuf, 0, sizeof(tmpbuf_size));
				ret = udsScanBeacons(tmpbuf, tmpbuf_size, &networks, &total_networks, wlancommID, 0, NULL, false);

				if(total_networks) { network = &networks[0]; readyToJoin = 1; break; }
			}
			if (total_networks == 1) {
				if (network->network.total_nodes >= 8) {
					readyToJoin = false;
					myprintf("Only one room was found and it was full!");
					myprintf("Press A to go back to main menu");
					while (1) {
						//gspWaitForVBlank();
						hidScanInput();
						keepConsole();
						kDown = hidKeysDown();
						if (kDown & KEY_A) break;
						if (kDown & KEY_START) return;
					}
				}
			}
			if (total_networks > 1) {
				int selected = 0;
				myconsoleClear();
				myprintf("Please choost a host by 3ds name:");
				while (1) {
					//gspWaitForVBlank();
	
					network = &networks[0];
					keepConsole();
					if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"network: total nodes = %u.\n", (unsigned int)network->network.total_nodes); myprintf(mystring); }


					for(pos=0; pos<total_networks; pos++)
					{
						network = &networks[pos];
						if(!udsCheckNodeInfoInitialized(&network->nodes[0]))continue;
						if (network->network.total_nodes >= 8) continue;
						free(tmpbuf);
						tmpbuf = NULL;
						memset(tmpstr, 0, sizeof(tmpstr));

						ret = udsGetNodeInfoUsername(&network->nodes[0], tmpstr);
						if(R_FAILED(ret))
						{
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsGetNodeInfoUsername() returned 0x%08x.\n", (unsigned int)ret);
							myprintf(mystring);
							CATASTROPHIC_FAILURE = true;
							free(networks);
							return;
						}

						if (pos == selected) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s%s%s\n", (unsigned int)(pos + 1), YELLOW, tmpstr, WHITE); myprintf(mystring); }
						else { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%s",(unsigned int)(pos + 1),tmpstr); myprintf(mystring); }
					}
					hidScanInput();
					kDown = hidKeysDown();
					if ((kDown & KEY_DUP) || (kDown & KEY_CPAD_UP)) selected--;
					if ((kDown & KEY_DDOWN) || (kDown & KEY_CPAD_DOWN)) selected++;
					if (kDown & KEY_A) { network = &networks[selected]; break; }
					if (selected < 0 || selected >= total_networks) selected = 0;
				}
			}
			myconsoleClear();
			if (readyToJoin) break;
			else { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"Version %s",VERSION);myprintf(mystring);	myprintf("\x1b[2;0HHold  to host"); myprintf("Press  to scan for a host."); myprintf("Press  to change name."); myprintf("Press SELECT for game modes."); myprintf("Press START to exit."); }
		}
		if (kUp & KEY_B) ignoreB = false;

	}
	if(total_networks && !hosting)
	{
		free(tmpbuf);
		tmpbuf = NULL;

		if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"network: total nodes = %u.\n", (unsigned int)network->network.total_nodes); myprintf(mystring); }


		for(pos=0; pos<NUM_SPRITES; pos++)
		{
			if(!udsCheckNodeInfoInitialized(&network->nodes[pos]))continue;

			memset(tmpstr, 0, sizeof(tmpstr));

			ret = udsGetNodeInfoUsername(&network->nodes[pos], tmpstr);
			if(R_FAILED(ret))
			{
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsGetNodeInfoUsername() returned 0x%08x.\n", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				free(networks);
				return;
			}

			if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"node%u username: %s\n", (unsigned int)pos, tmpstr); myprintf(mystring); }
		}

		for(pos=0; pos<10; pos++)
		{
			ret = udsConnectNetwork(&network->network, passphrase, strlen(passphrase)+1, &bindctx, UDS_BROADCAST_NETWORKNODEID, conntype, data_channel, recv_buffer_size);
			if(R_FAILED(ret))
			{
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsConnectNetwork() returned 0x%08x.\n", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				return;
			}
			else
			{
				break;
			}
		}

		free(networks);

		if(pos==10)return;

		if (debugging) myprintf("Connected.\n");


		tmp = 0;
		ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
		if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsGetChannel() returned 0x%08x. channel = %u.\n", (unsigned int)ret, (unsigned int)tmp); myprintf(mystring); }
		if(R_FAILED(ret))
		{
			CATASTROPHIC_FAILURE = true;
			return;
		}
		con_type = 1;
		
	}
	if (hosting)
	{
		if (uds_enabled) {
			udsGenerateDefaultNetworkStruct(&networkstruct, wlancommID, 0, 8); //only have room for 8 players.

			myprintf("Creating the network...");
			ret = udsCreateNetwork(&networkstruct, passphrase, strlen(passphrase)+1, &bindctx, data_channel, recv_buffer_size);
			if(R_FAILED(ret))
			{
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsCreateNetwork() returned 0x%08x.\n", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				return;
			}

			tmp = 0;
			ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
			if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsGetChannel() returned 0x%08x. channel = %u.\n", (unsigned int)ret, (unsigned int)tmp); myprintf(mystring); }
			if(R_FAILED(ret))
			{
				udsDestroyNetwork();
				udsUnbind(&bindctx);
				CATASTROPHIC_FAILURE = true;
				return;
			}
		}
		con_type = 0;
		myNum = 0;
	}
	tmpbuf_size = UDS_DATAFRAME_MAXSIZE;
	tmpbuf = malloc(tmpbuf_size);
	if(tmpbuf==NULL)
	{
		myprintf("Failed to allocate tmpbuf for receiving data.");

		CATASTROPHIC_FAILURE = true;
		if (uds_enabled) {
			if(con_type)
			{
				udsDestroyNetwork();
			}
			else
			{
				udsDisconnectNetwork();
			}
			udsUnbind(&bindctx);
		}
		return;
	}
	if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
	{
		if (debugging) myprintf("Constatus event signaled.");
		ret=0;
		u32 pos;
		

		//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
		ret = udsGetConnectionStatus(&constatus);
		if(R_FAILED(ret))
		{
			memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.", (unsigned int)ret);
			myprintf(mystring);
			CATASTROPHIC_FAILURE = true;
			return;
		}
		else
		{
			if (debugging) {
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
				myprintf(mystring);
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"1=0x%x\n", (unsigned int)constatus.unk_x4);
				myprintf(mystring);
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
				myprintf(mystring);
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
				myprintf(mystring);
				for(pos=0; pos<(0x20>>2); pos++) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]); myprintf(mystring); } 
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
				myprintf(mystring);
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
				myprintf(mystring);
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
				myprintf(mystring);
			}
			myNode = constatus.cur_NetworkNodeID;
			sprites[myNum].node = myNode;
			memset(tmpstr, 0, sizeof(tmpstr));
			ret = udsGetNodeInformation(constatus.cur_NetworkNodeID,&tmpnode);
			ret = udsGetNodeInfoUsername(&tmpnode,&tmpstr);
			if (strlen(overwriteName) == 0) strncpy(myName,tmpstr,sizeof(myName));
			else strncpy(myName,overwriteName,sizeof(myName));

			if (!hosting) {
				myNum = constatus.total_nodes - 1;
				num_bikes = constatus.total_nodes;

				setSprites();
				if (debugging) myprintf("Sending request to join...");
				sprites[myNum].speed = 1111;
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 1111;
				UDSSend(msg);
				memset(replySprite,0,sizeof(replySprite[0]) * 10);
				lastSprite = svcGetSystemTick();
				while (1) {
					hidScanInput();
					keepConsole();
					if (hidKeysDown() & KEY_START) { myprintf("ENDING..."); CATASTROPHIC_FAILURE = true; return; }
					if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
						if (debugging) myprintf("Resending request...");
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						sprites[myNum].node = myNode;
						msg.sprite = sprites[myNum]; 
						msg.sprite.speed = 1111; 
						lastSprite = svcGetSystemTick();
						UDSSend(msg);
					}
					memset(tmpbuf, 0, tmpbuf_size);
					actual_size = 0;
					src_NetworkNodeID = 0;
					if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
					if(R_FAILED(ret))
					{
						memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
						myprintf(mystring);
						replay = false;
						CATASTROPHIC_FAILURE = true;
						return;
					}
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"speed: %d image: %d myNum: %d\n",msg.sprite.speed, msg.sprite.image, myNum); myprintf(mystring); }
						if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; sprites[myNum] = msg.sprite; sprites[myNum].node = myNode; msg.sprite = sprites[myNum]; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; memset(replySprite,0,sizeof(replySprite[0]) * 10); break; } //joined game in score screen
						else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].dead = true; sprites[myNum].node = myNode; sprites[myNum].speed = 45; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); break; } // joined game in progress
						else if(msg.sprite.speed == 1211 && msg.sprite.image == myNum) break;
					}
				}
			}
		}

	}

	C3D_TexBind(0, &spritesheet_tex);
	//myprintf("Press A to stop data transfer.\n");
	char quitName[50];
	memset(quitName,'\0',sizeof(quitName));
	C3D_TexBind(0, &spritesheet_tex);
	while (replay) {
		errorQuit = 0;
		if (num_bikes < 1) num_bikes = 1;
		for (int i = 0; i < num_bikes; i++) {
			score[i] = 0;
		}
		if (!inGame) setSprites();
		if (con_type == 0) { //hosting, wait for connection
			hidScanInput();
			u32 kDown = hidKeysDown();
			u32 kUp = hidKeysUp();
			u32 kHeld = hidKeysHeld();
			myconsoleClear();
			if (!connectionEstablished) {
				myprintf("Waiting for connection...");
				myprintf("Let go of A to play by yourself.");
			}
			else myprintf("Preparing room...");
			while ((kHeld & KEY_A) && !(kUp & KEY_A)) {
				keepConsole();
				hidScanInput();

				kHeld = hidKeysHeld();
				kDown = hidKeysDown();
				kUp = hidKeysUp();
				if(kDown & KEY_START) {
					udsDisconnectNetwork();
					udsUnbind(&bindctx);
					return;
				}
				if (kUp & KEY_A) break;
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					setSprites();
					connectionEstablished = true;
					
					ret = udsGetConnectionStatus(&constatus);
					ret = udsGetNodeInformation(0x1,&tmpnode);
					memset(sprites[0].username,'\0',sizeof(sprites[0].username));
					udsGetNodeInfoUsername(&tmpnode,&sprites[0].username);
					ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
					if (constatus.total_nodes >= num_bikes) {
						memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes].username));
						udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes].username);
						sprites[num_bikes].node = constatus.total_nodes;
						if (debugging) {
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
							myprintf(mystring);
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"1=0x%x\n", (unsigned int)constatus.unk_x4);
							myprintf(mystring);
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
							myprintf(mystring);
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
							myprintf(mystring);
							for(pos=0; pos<(0x20>>2); pos++) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]); myprintf(mystring); }
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
							myprintf(mystring);
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
							myprintf(mystring);
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
							myprintf(mystring);
						}
						memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s\n",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
						myprintf(mystring);
						num_bikes = constatus.total_nodes;
					}
					break;
				}
			}
			int i = 0;
			ret = 0;
			if (debugging) myprintf("Sending bike information");
			bool redo = true;
			lastSprite = svcGetSystemTick();
			lastChange = svcGetSystemTick();
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			memset(replyChange,0,sizeof(replyChange[0]) * 10);
			while (redo && num_bikes > 1) {
				for (i = 0; i < num_bikes; i++) {
					gspWaitForVBlank();
					msg.sprite = sprites[i];
					UDSResend(replySprite,msg);
				}
				if (!allReplied(replySprite)) lastSprite = svcGetSystemTick();
				if (!allReplied(replyChange)) lastChange = svcGetSystemTick();
				msg.sprite.image = 0;
				msg.sprite.speed = 66;
				msg.sprite.x = apple.x;
				msg.sprite.y = apple.y;
				msg.sprite.dx = optionsToInt();
				UDSResend(replyChange,msg);
				while (1) {
					hidScanInput();
					u32 kDown = hidKeysDown();
					if (kDown & KEY_START) {
						CATASTROPHIC_FAILURE = true;
						return;
					}
					memset(tmpbuf, 0, tmpbuf_size);
					actual_size = 0;
					src_NetworkNodeID = 0;

					if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
					{
						u32 pos;
						

						//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
						ret = udsGetConnectionStatus(&constatus);
						if(R_FAILED(ret))
						{
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
							myprintf(mystring);
							CATASTROPHIC_FAILURE = true;
							return;
						}
						else
						{
							if (constatus.total_nodes >= num_bikes) {
								if (debugging) {
									myprintf("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
									myprintf("1=0x%x\n", (unsigned int)constatus.unk_x4);
									myprintf("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
									myprintf("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
									for(pos=0; pos<(0x20>>2); pos++)myprintf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
									myprintf("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
									myprintf("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
									myprintf("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
								}
								ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
								if (constatus.total_nodes >= num_bikes) {
									memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes].username));
									udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes].username);
									if (!sprites[num_bikes].node) sprites[num_bikes].node = constatus.total_nodes;
									memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s\n",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
									myprintf(mystring);
								}
							} else {
								myprintf("Lost one!");
							}
							num_bikes = constatus.total_nodes;

						}
					}
					if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
					if(R_FAILED(ret))
					{
						memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
						myprintf(mystring);
						CATASTROPHIC_FAILURE = true;
						return;
					}
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"speed: %d image: %d\n",msg.sprite.speed, msg.sprite.image); myprintf(mystring); }
						if (msg.sprite.speed == 100) replySprite[msg.sender] = true;
						else if (msg.sprite.speed == 777) {} //ignore
						else if (msg.sprite.speed == 123) {} //ignore
						else if (msg.sprite.speed == 66) replyChange[msg.sender] = true;
						else if (msg.sprite.speed == 1111) { if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"Accepting request to join...(%d)\n",msg.sender); myprintf(mystring); } sprites[msg.sender].node = msg.sprite.node; replyChange[msg.sender] = false; replySprite[msg.sender] = false; sprites[msg.sender].speed = 1211; msg.sprite = sprites[msg.sender]; UDSSend(msg); } 
						else if (msg.sprite.speed == 999) { CATASTROPHIC_FAILURE = true; return; } //player quit
					}
					if (allReplied(replySprite) && allReplied(replyChange)) {
						if (debugging) myprintf("Starting game...");
						redo = false;
						msg.sprite = sprites[myNum];
						msg.sprite.image = 0;
						msg.sprite.speed = 101;
						UDSSend(msg);
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						lastSprite = svcGetSystemTick();
						wakeup = true;
						break;
					} else if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 30 * lagMult()) {
						break;
					} else if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
						break;
					}
				}
				gspWaitForVBlank();
			}
			gspWaitForVBlank();
		} else if (!inGame) { //guest connection
			myconsoleClear();
			if (debugging) myprintf("\x1b[0;0HReceiving bike information...\n");
			myprintf("Loading...");
			memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"You are %s%s%s!",textColors[myNum],colorNames[myNum],WHITE);
			myprintf(mystring);
			memset(replySprite,true,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick();
			int oldspeed = 0;
			while (1) {
				hidScanInput();
				u32 kDown = hidKeysDown();
				if (kDown & KEY_START) {
					return;
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
			
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					u32 pos;
					

					//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
					ret = udsGetConnectionStatus(&constatus);
					if(R_FAILED(ret))
					{
						memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
						myprintf(mystring);
						CATASTROPHIC_FAILURE = true;
						return;
					}
					else
					{
						if (debugging) {
							myprintf("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
							myprintf("1=0x%x\n", (unsigned int)constatus.unk_x4);
							myprintf("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
							myprintf("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
							for(pos=0; pos<(0x20>>2); pos++)myprintf("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
							myprintf("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
							myprintf("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
							myprintf("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
						}
						if (!hosting) {
							myNum = constatus.cur_NetworkNodeID - 1;
							num_bikes = constatus.total_nodes;
							sprites[myNum].image = myNum;
							sprites[myNum].node = myNode;
							memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
							strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
							msg.sprite = sprites[myNum];
							msg.sprite.speed = 1111;
							UDSDirect(1,msg);
						}
					}
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
				//myprintf("tmpbuf_size: 0x%08x (0x%08x)\n",tmpbuf_size,sizeof(Message));
				if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
				if(R_FAILED(ret))
				{
					memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
					myprintf(mystring);
					CATASTROPHIC_FAILURE = true;
					return;
				}
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (debugging) if (msg.sprite.speed != oldspeed) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"image: %d speed: %d myNum: %d myNode: %d\n",msg.sprite.image, msg.sprite.speed, myNum, myNode); myprintf(mystring); }
					oldspeed = msg.sprite.speed;
					
					if (msg.sprite.speed == 123) {} //ignore
					else if (msg.sprite.speed == 777) {} //ignore
					else if (msg.sprite.speed == 555) { if (msg.sender == 0) UDSSend(msg); } //make sure host realizes we are waiting for him!
					else if (msg.sprite.speed == 1111) { sprites[msg.sprite.image] = msg.sprite; strncpy(sprites[msg.sprite.image].username,msg.sprite.username,sizeof(sprites[msg.sprite.image])); oldbikes--; } //ignore
					else if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; msg.sprite.speed = 45; sprites[myNum] = msg.sprite; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; break; } //joined game in score screen
					else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].speed = 45; sprites[myNum].node = myNode; sprites[myNum].dead = true; memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username)); strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username)); break; } // joined game in progress
					else if (msg.sprite.speed == 66) {
						if (msg.sender == 0) {
							apple.x = msg.sprite.x;
							apple.y = msg.sprite.y;
							setOptions((unsigned int)msg.sprite.dx);
							UDSSend(msg);
						}
					} else if (msg.sprite.speed == 101) { if (msg.sender == 0) UDSSend(msg); break; }
					else if (msg.sender == 0 && (msg.sprite.speed == 45 || msg.sprite.speed == 1211)) {
						path[0][msg.sprite.image].x = msg.sprite.x;
						path[0][msg.sprite.image].y = msg.sprite.y;
						sprites[msg.sprite.image] = msg.sprite;
						sprites[msg.sprite.image].speed = 45;
						if (msg.sprite.image >= num_bikes - 1) {
							msg.sprite.speed = 100;
							UDSSend(msg);
						}
					}
				} 
			}
		}
		C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		gfxFlushBuffers();
		gfxSwapBuffers();
		C3D_RenderTargetSetClear(target, NULL, NULL, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		gfxFlushBuffers();
		gfxSwapBuffers();
		for (int i = 0; i < 10; i++) oldscore[i] = 0;
		bool olddead = sprites[myNum].dead;
		oldbikes = num_bikes;
		myconsoleClear();
		// Main loop
		for (int i = 0; i < num_bikes; i++) {
			frameTicks[i] = svcGetSystemTick();
		}
		int oldApplex = 0;
		int oldAppley = 0;
		int oldDx = 15;
		C3D_RenderTargetSetClear(target, NULL, NULL, 0);
		C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);
		UDSSent = svcGetSystemTick();
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replyScore,1,sizeof(replyScore[0]) * 10);
		if (myNum) memset(replyChange,1,sizeof(replyChange[0]) * 10);
		frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);
		if (!inGame && myNum != 0) memset(replySprite,1,sizeof(replySprite[0]) * 10);
		quit = -1;
		if (!inGame) actual_bikes = num_bikes;
		printScore();
		death = 0;
		int oldsender = 0;
		int oldspeed = 0;
		for (int i = actual_bikes; i < NUM_SPRITES; i++) {
			sprites[i].dead = true;
		}
		oldCPos.dx = 0;
		oldCPos.dy = 0;
		nextMove = NULL;
		C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target);
			C3D_TexBind(0, &spritesheet_tex);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
			if (options[0]) {
				drawSprite(0,0,1,238,7);
				drawSprite(0,0,400,1,7);
				drawSprite(398,0,1,238,7);
				drawSprite(0,238,396,1,7);
			}
			drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
		C3D_FrameEnd(0);
		lastDead = 0;
		while (aptMainLoop()) {
			if (everyoneElseIsDead() && sprites[myNum].dead) break;
			if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 3) {
				return;
			}
			if (myNum == 0) {
				if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
				{
					
					ret = udsGetConnectionStatus(&constatus);
					ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
					if (constatus.total_nodes >= num_bikes) {
						replyScore[msg.sender] = true;
						replyChange[msg.sender] = true;
						num_bikes = constatus.total_nodes;
					} else {
						errorQuit = svcGetSystemTick();
					}
				}
			}
			if (!wakeup) {
				if (!allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.image = myNum;
					msg.sprite.speed = 77;
					msg.sprite.dx = score[myNum];
					msg.sprite.x = apple.x;
					msg.sprite.y = apple.y;
					lastScore = svcGetSystemTick();
					UDSResend(replyScore,msg);
				}
				else if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.image = myNum;
					msg.sprite.speed = 66;
					msg.sprite.x = apple.x;
					msg.sprite.y = apple.y;
					lastChange = svcGetSystemTick();
					UDSResend(replyChange,msg);
				}
				if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					if (sprites[myNum].speed == 1011) {
						memset(replySprite,1,sizeof(replySprite[0]) * 10);
					} else {
						sprites[myNum].node = myNode;
						memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
						strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
						msg.sprite = sprites[myNum];
						lastSprite = svcGetSystemTick();
						UDSResend(replySprite,msg);
					}
				}
			} else {
				if (!allReplied(replySprite) && svcGetSystemTick() -  lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.speed = 101;
					UDSResend(replySprite,msg);
					lastSprite = svcGetSystemTick();
				}
				if (allReplied(replySprite)) {
					wakeup = false;
				}
			}
			hidScanInput();

			// Respond to user input
			u32 kDown = hidKeysDown();
			u32 kHeld = hidKeysHeld();
			u32 kUp = hidKeysUp();
			hidCircleRead(&cpos);

			//Read the touch screen coordinates
			hidTouchRead(&touch);

			float px = (float)touch.px / 312.0f;
			float py = (float)touch.py / 235.0f;
			px *= 400.0f;
			py *= 240.0f;

			//Read the CirclePad position
			if (kDown & KEY_START) {
				replay = false;
				return; // break in order to return to hbmenu
			}
			u32 msgtype = NULL;
			if (!options[2]) {
				if ((abs(cpos.dy) > 17 || abs(cpos.dx) > 17) && !(oldCPos.dx == 0 && oldCPos.dy == 0)){
					float dvd = abs(cpos.dy) > abs(cpos.dx) ? abs(cpos.dy) : abs(cpos.dx) / abs(abs(cpos.dy) - abs(cpos.dx));
					if (dvd < 120 && dvd > 1) {
						if (cpos.dy > 0 && cpos.dx > 0) {
							sprites[myNum].diag = NORTHEAST;
							if (oldMove == MOVE_UP) kDown |= KEY_CPAD_RIGHT;
							else if (oldMove == MOVE_RIGHT) kDown |= KEY_CPAD_UP;
							else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
							else kDown |= KEY_CPAD_RIGHT;
						} else if (cpos.dx < 0 && cpos.dy < 0) {
							sprites[myNum].diag = SOUTHWEST;
							if (oldMove == MOVE_DOWN) kDown |= KEY_CPAD_LEFT;
							else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_DOWN;
							else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_DOWN;
							else kDown |= KEY_CPAD_LEFT;
						} else if (cpos.dx < 0 && cpos.dy > 0) {
							sprites[myNum].diag = NORTHWEST;
							if (oldMove == MOVE_UP) kDown |= KEY_CPAD_LEFT;
							else if (oldMove == MOVE_LEFT) kDown |= KEY_CPAD_UP;
							else if (sprites[myNum].dx != 0) kDown |= KEY_CPAD_UP;
							else kDown |= KEY_CPAD_LEFT;
						} else if (cpos.dx > 0 && cpos.dy < 0) {
							sprites[myNum].diag = SOUTHEAST;
							if (oldMove == MOVE_DOWN) kDown = KEY_CPAD_RIGHT;
							else if (oldMove == MOVE_RIGHT) kDown = KEY_CPAD_DOWN;
							else if (sprites[myNum].dx != 0) kDown = KEY_CPAD_DOWN;
							else kDown |= KEY_CPAD_RIGHT;
						} 
					} else if (cpos.dx != oldCPos.dx || cpos.dy != oldCPos.dy) {
						if (cpos.dx < 0 && abs(cpos.dx) > abs(cpos.dy)) { if (oldDiag) msgtype = MOVE_LEFT; kDown |= KEY_CPAD_LEFT; }
						else if (cpos.dx > 0 && abs(cpos.dx) > abs(cpos.dy)) { if (oldDiag) msgtype = MOVE_RIGHT; kDown |= KEY_CPAD_RIGHT; }
						else if (cpos.dy < 0 && abs(cpos.dy) > abs(cpos.dx)) { if (oldDiag) msgtype = MOVE_DOWN; kDown |= KEY_CPAD_DOWN; } 
						else if (cpos.dy > 0 && abs(cpos.dy) > abs(cpos.dx)) { if (oldDiag) msgtype = MOVE_UP; kDown |= KEY_CPAD_UP; }
						sprites[myNum].diag = 0;
					}
				} else if (oldDiag) {
					sprites[myNum].diag = 0;
					if (sprites[myNum].dx > 0) msgtype = MOVE_RIGHT;
					else if (sprites[myNum].dx < 0) msgtype = MOVE_LEFT;
					else if (sprites[myNum].dy > 0) msgtype = MOVE_UP;
					else if (sprites[myNum].dy < 0) msgtype = MOVE_DOWN;
				}
			}
			oldCPos = cpos;
			//if (debugging) myprintf("cpad: %03d %03d %d %f\n",pos.dx,pos.dy, oldMove, dvd);
			if (!options[3]) {
				if (kDown & KEY_A || kHeld & KEY_A) sprites[myNum].speed = 15;
				else if (kUp & KEY_A) sprites[myNum].speed = 45;
			}
			if (!options[4]) {
				if (kDown & KEY_B || kHeld & KEY_B) sprites[myNum].speed = 90;
				else if (kUp & KEY_B) sprites[myNum].speed = 45;
			}
			int prevn = currentPath[myNum] - 1;
			if (prevn < 0) prevn = 240 * 400;
			if ((kDown & KEY_CPAD_UP || kDown & KEY_DUP || nextMove == MOVE_UP) && !sprites[myNum].dy) {
				if (kDown & KEY_DUP) sprites[myNum].diag = 0;
				if (path[prevn][myNum].x == sprites[myNum].x) nextMove = MOVE_UP;
				else {
					sprites[myNum].dx = 0;
					sprites[myNum].dy = bikeSpeed * -1;
					msgtype = MOVE_UP;
					nextMove = NULL;
				}
			} else if((kDown & KEY_CPAD_DOWN || kDown & KEY_DDOWN || nextMove == MOVE_DOWN)  && !sprites[myNum].dy) {
				if (kDown & KEY_DDOWN) sprites[myNum].diag = 0;
				if (path[prevn][myNum].x == sprites[myNum].x) nextMove = MOVE_DOWN;
				else {
					sprites[myNum].dx = 0;
					sprites[myNum].dy = bikeSpeed;
					msgtype = MOVE_DOWN;
					nextMove = NULL;
				}
			} else if ((kDown & KEY_CPAD_LEFT || kDown & KEY_DLEFT || nextMove & MOVE_LEFT)  && !sprites[myNum].dx) {
				if (kDown & KEY_DLEFT) sprites[myNum].diag = 0;
				if (path[prevn][myNum].y == sprites[myNum].y) nextMove = MOVE_LEFT;
				else {
					sprites[myNum].dx = bikeSpeed * -1;
					sprites[myNum].dy = 0;
					msgtype = MOVE_LEFT;
					nextMove = NULL;
				}
			} else if ((kDown & KEY_CPAD_RIGHT || kDown & KEY_DRIGHT || nextMove == MOVE_RIGHT)  && !sprites[myNum].dx) {
				if (kDown & KEY_DRIGHT) sprites[myNum].diag = 0;
				if (path[prevn][myNum].y == sprites[myNum].y) nextMove = MOVE_RIGHT;
				else {
					sprites[myNum].dx = bikeSpeed;
					sprites[myNum].dy = 0;
					msgtype = MOVE_RIGHT;
					nextMove = NULL;
				}
			}
			if (msgtype != NULL || oldDx != sprites[myNum].speed) {
				oldMove = msgtype;
				if (oldDiag != sprites[myNum].diag || !sprites[myNum].diag || oldDx != sprites[myNum].speed) {
					oldDiag = sprites[myNum].diag;
					sprites[myNum].node = myNode;
					strncpy(sprites[myNum].username,myName,sizeof(myName));
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					msg.sprite = sprites[myNum];
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				oldDx = sprites[myNum].speed;
			}
			//send my sprite info
			//Message msg;
			

			//receive other sprite's info
			memset(tmpbuf, 0, tmpbuf_size);
			actual_size = 0;
			src_NetworkNodeID = 0;
			if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
			if(R_FAILED(ret))
			{
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				return;
			}
			if (wakeup) {
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (msg.sprite.speed == 101) {
						replySprite[msg.sender] = true;
					}
				}
			}
			for (int i = 0; i < num_bikes; i++) {
				if (score[i] != oldscore[i]) clearFlag = true;
			}
			if (sprites[myNum].dead && !olddead) clearFlag = true;
			if (oldbikes != num_bikes) { clearFlag = true; oldbikes = num_bikes; }
			printScore();
			/*if (clearFlag) {
				//if (!debugging) myconsoleClear();
				printScore();
				for (int i = 0; i < num_bikes; i++) oldscore[i] = score[i];
					olddead = sprites[myNum].dead;
				clearFlag = false;
			}*/
			gfxFlushBuffers();
			gfxSwapBuffers();
			
			//Wait for VBlank
			//gspWaitForVBlank();
			// Render the scene
			if (!wakeup) {
				C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
					C3D_FrameDrawOn(target);
					C3D_TexBind(0, &spritesheet_tex);
					C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
					if (!options[5] && !options[6]) if (kDown & KEY_Y && !usedSpecial) {
						usedSpecial = true;
						memset(replyChange,0,sizeof(replyChange[0]) * 10);
						changeApple();
					}
					if (cheats && px && py) {
						drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 9);
						apple.x = (int)px;
						apple.y = (int)py;
						apple.x = apple.x << 8;
						apple.y = apple.y << 8;
						drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
						oldpx = px;
						oldpy = py;
					} else if (oldpx && oldpy) {
						oldpx = 0;
						oldpy = 0;
						msg.sprite.speed = 66;
						msg.sprite.x = apple.x;
						msg.sprite.y = apple.y;
						memset(replyChange,0,sizeof(replyChange[0]) * 10);
						UDSSend(msg);
					}
					sceneRender();
					moveSprites();
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						//Message msg;
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"sender: %d image: %d speed: %d diag: %d",msg.sender,msg.sprite.image, msg.sprite.speed,msg.sprite.diag); myprintf(mystring); }
						oldspeed = msg.sprite.speed;
						oldsender = msg.sender;
						if (msg.sprite.speed == 101 && msg.sender == 0) { UDSSend(msg); } //ignore.
						else if (msg.sprite.speed == 999) {
							errorQuit = 0;
							if (msg.sender == msg.sprite.node && msg.sender == msg.sprite.image) {
								for (int i = 0; i < num_bikes; i++) {
									if (sprites[i].node == msg.sprite.node) { quit = i; break; }
								}
								memset(quitName,'\0',sizeof(quitName));
								strncpy(quitName,msg.sprite.username,sizeof(quitName));
								
					
								for (int i = 0; i < num_bikes; i++) {
									sprites[i].dead = true;
								}
								msg.sprite.image = msg.sprite.node;
								msg.sprite.node = myNode;
								UDSDirect(msg.sprite.image,msg);
							}
						}
						else if (msg.sprite.speed == 1111) {
							sprites[msg.sprite.image] = msg.sprite;
							if (myNum == 0 && msg.sprite.image == msg.sender) {
								msg.sprite = sprites[msg.sprite.image];
								msg.sprite.image = actual_bikes;
								msg.sprite.speed = 1011;
								msg.sprite.dead = true;
								sprites[num_bikes] = msg.sprite;
								oldbikes = 0;
								UDSSend(msg);
							}
						}
						else if (msg.sprite.speed == 1011 && myNum != 0) {} // ignore
						else if (msg.sprite.speed == 66) { 
							if (msg.sprite.image == myNum) { if (msg.timestamp == lastChange) replyChange[msg.sender] = true; else if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"replyChange from %d: 0x%08x != 0x%08x",msg.sender,msg.timestamp,lastChange); myprintf(mystring); } }
							else if (msg.sender == msg.sprite.image) { UDSDirect(msg.sprite.node,msg); if (debugging) myprintf("changing apple..."); if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) updateApple(msg.sprite.x,msg.sprite.y); }
						}
						else if (msg.sprite.speed == 77) { 
							if (msg.sprite.image == myNum) { if (msg.timestamp == lastScore) replyScore[msg.sender] = true;  else if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"replyScore from %d: 0x%08x != 0x%08x",msg.sender,msg.timestamp,lastScore); myprintf(mystring); } }
							else if (msg.sender == msg.sprite.image) { UDSDirect(msg.sprite.node,msg); if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) { sprites[msg.sprite.image].length = msg.sprite.length; setApple(msg.sprite.image, msg.sprite.x, msg.sprite.y); } score[msg.sprite.image] = msg.sprite.dx; }
						}
						else if (msg.sprite.image == myNum) { if (msg.sprite.speed == 1001) break; if (msg.timestamp == lastSprite) replySprite[msg.sender] = true;  else if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"replySprite from %d: 0x%08x != 0x%08x",msg.sender,msg.timestamp,lastSprite); myprintf(mystring);} }
						else if (msg.sprite.speed == 1001) {} //ignore.
						else {
							
							
							if (msg.sprite.image > num_bikes) { 
								num_bikes = msg.sprite.image + 1; 
								for (int i = actual_bikes; i < NUM_SPRITES; i++) { 
									sprites[i].dead = true; 
								} 
								if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
								if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
								if (sprites[myNum].dead) { 
									sprites[myNum].image = myNum; 
									sprites[myNum].node = myNode; 
									msg.sprite = sprites[myNum]; 
									replySprite[num_bikes - 1] = false; 
									UDSSend(msg); 
								} 
							}
							if (msg.sprite.image == num_bikes) { 
								sprites[num_bikes].dead = true; 
								if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
								if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
								num_bikes++; 
								if (sprites[myNum].dead) { 
									myprintf("wtf...");
									sprites[myNum].image = myNum; 
									sprites[myNum].node = myNode; 
									msg.sprite = sprites[myNum]; 
									replySprite[num_bikes - 1] = false; 
									UDSSend(msg); 
								} 
							}
							if (msg.sender == msg.sprite.image) UDSDirect(msg.sprite.node,msg);
							int img = msg.sprite.image;
							if (msg.sprite.image < actual_bikes && msg.sender == msg.sprite.image) {
								
								if (abs(currentPath[img] - pathPos[img]) > 4) {
									u32 pathx = path[currentPath[img]][img].x >> 8;
									u32 pathy = path[currentPath[img]][img].y >> 8;
									u32 imgx = msg.sprite.x >> 8;
									u32 imgy = msg.sprite.y >> 8; 
									
									if (msg.sprite.dead) {
										lastDead = msg.sprite.image;
										eraseOvershoot(msg.sprite);
									}
									else finishLine(currentPath[img],pathx << 8, pathy << 8, imgx << 8, imgy << 8, msg.sprite, img);
								}
							}
							if (msg.sender == msg.sprite.image) sprites[msg.sprite.image] = msg.sprite;
							//drawSprite(sprites[img].x >> 8, sprites[img].y >> 8, 2, 2, img);
							if (everyoneElseIsDead()) {
								if (options[6] && !sprites[myNum].dead) {
									lastDead = myNum;
									sprites[myNum].dead = true;
									msg.sprite = sprites[myNum];
									memset(replySprite,0,sizeof(replySprite[0]) * 10);
									lastSprite = svcGetSystemTick();
									UDSSend(msg);
								}
								else if (getHighestScore() == myNum && allReplied(replyScore)) { lastDead = myNum; sprites[myNum].dead = true; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); lastSprite = svcGetSystemTick(); UDSSend(msg); }
							}
						}
					}
					if (oldApplex != apple.x && oldAppley != apple.y) { 
						drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
						oldApplex = apple.x;
						oldAppley = apple.y;
					}
				C3D_FrameEnd(0);
				gfxFlushBuffers();
				gfxSwapBuffers();
			}
			keepConsole();
			if (everyoneElseIsDead()) {
				if (options[6] && !sprites[myNum].dead) {
					lastDead = myNum;
					sprites[myNum].dead = true;
					msg.sprite = sprites[myNum];
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				else if (getHighestScore() == myNum && allReplied(replyScore)) { lastDead = myNum; sprites[myNum].dead = true; sprites[myNum].node = myNode; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); lastSprite = svcGetSystemTick(); UDSSend(msg); }
			}
			if (everyoneElseIsDead() && sprites[myNum].dead) break;
		}
		myconsoleClear();
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replyScore,0,sizeof(replyScore[0]) * 10);
		lastScore = 0;
		int oldQuit = 0;
		int numLeft = 0;
		errorQuit = 0;
		for (int i = 0; i < NUM_SPRITES; i++) {
			ready[i] = false;
		}
		joinedNum = 0;
		waitForFinish = 0;
		u64 readyLock = 0;
		readyLock = svcGetSystemTick();
		inGame = false;
		while (1) {
			C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
			C3D_FrameDrawOn(target2);
			C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &textprojection);
			myprintf("\x1b[2;0H ");
			keepSConsole();
			if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
				sprites[myNum].image = myNum;
				sprites[myNum].dead = true;
				sprites[myNum].node = myNode;
				msg.sprite = sprites[myNum];
				lastSprite = svcGetSystemTick();
				UDSResend(replySprite,msg);
			} //Be sure to still resend my death msg if someone hasn't gotten it
			if (!options[6]) {
				if (itsATie()) myprintf("\x1b[0;0HIt's a TIE!");
				else if (getHighestScore() == myNum) myprintf("\x1b[0;0HA winner is YOU!");
				else { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[0;0HYou LOSE! %s%s wins the game!%s",textColors[getHighestScore()],sprites[getHighestScore()].username,WHITE); myprintf(mystring); }
			} else {
				if (myNum == lastDead) myprintf("\x1b[0;0HA winner is YOU!!");
				else { snprintf(mystring,sizeof(mystring),"\x1b[0;0HYou LOSE! %s%s wins the game!%s",textColors[lastDead],sprites[lastDead].username,WHITE); myprintf(mystring); }
			}
			memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[1;0HScore: ");
			char scores[10];
			float widths[10];
			float h;
			char te[100];
			char k[10];
			memset(te,'\0',sizeof(te));
			snprintf(te,sizeof(te),"Score: ");
			memset(scores,'\0',sizeof(scores));
				for (int i = 0; i < NUM_SPRITES; i++) {
					memset(scores,'\0',sizeof(scores));
					memset(k,'\0',sizeof(k));
					if (i < num_bikes || i == 0) snprintf(scores,sizeof(scores),"%s%d ",textColors[i],score[i]);
					snprintf(k,sizeof(k),"%d ",score[i]);
					//else snprintf(scores,sizeof(scores),"  ");
					screen_get_string_size_wrap(&widths[i], &h, te, 0.5f, 0.5f, 320);
					strcat(mystring,scores);
					strcat(te,k);
				}
			myprintf(mystring);
			//memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[2;0H%sScore: ", BLACK);
				for (int i = 0; i < NUM_SPRITES; i++) {
					memset(scores,'\0',sizeof(scores));
					if (i < num_bikes) {
						if (ready[i]) snprintf(scores,sizeof(scores),"%sR",GREEN);
						else snprintf(scores,sizeof(scores),"%s-",WHITE);
						rText(widths[i],h * 2 + 10.0,.5f,.5f,true,scores);
					}
					//strcat(mystring,scores);
				}
			//myprintf(mystring);
			C3D_FrameEnd(0);
			if (allReplied(replyScore) && myNum == 0 && num_bikes > 1) { if (debugging) myprintf("Everyone got the message. Sending bike information.."); break; }
			if (waitForFinish != 0 && svcGetSystemTick() - waitForFinish > TICKS_PER_SEC * 4) break;
			memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[3;0H%sPress A if you're ready!",WHITE);
			myprintf(mystring);
			myprintf("\x1b[4;0HPress START to quit.");
			if (!myNum) myprintf("\x1b[5;0HPress SELECT to set game modes!");
			if (numLeft >= 15) { myconsoleClear(); numLeft = 0; }
			if (num_bikes == 1) { numLeft++; num_bikes--; memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"Everyone has left the game!"); myprintf(mystring); }
			if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 123;
				//memset(replyChange,0,sizeof(replyChange[0]) * 10);
				UDSResend(replyChange,msg);
			}
			if (lastScore && !allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 30 * lagMult()) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 555;
				UDSResend(replyScore,msg);
				lastScore = svcGetSystemTick();
			}
			hidScanInput();
			u32 kDown = hidKeysDown();
			memset(tmpbuf, 0, tmpbuf_size);
			actual_size = 0;
			src_NetworkNodeID = 0;
			if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
			if(R_FAILED(ret))
			{
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
				myprintf(mystring);
				CATASTROPHIC_FAILURE = true;
				replay = false;
				return;
			}
			if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
			{
				//Message msg;
				memcpy(&msg,tmpbuf,sizeof(Message));
				if (debugging) {
					numLeft++;
					memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"sender: %d, image: %d, speed: %d node: %d, %d",msg.sender,msg.sprite.image,msg.sprite.speed, msg.sprite.node);
					myprintf(mystring);
				}
				if (msg.sprite.speed == 999) {
					if (msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
						memset(quitName,'\0',sizeof(quitName));
						strncpy(quitName,msg.sprite.username,sizeof(quitName));
						for (int i = 0; i < num_bikes; i++) {
							if (sprites[i].node == msg.sprite.node && i != oldQuit) { quit = i; oldQuit = quit; }
						}
						msg.sprite.image = msg.sprite.node;
						msg.sprite.node = myNode;
						UDSDirect(msg.sprite.image,msg);
					}
				}
				/*if (msg.sprite.speed == 999 && msg.sprite.image != quit) {
					if (msg.sender <= num_bikes) {
						lastQuit = msg.timestamp;
						quit = msg.sprite.image;
						quitNum = msg.sender;
						if (quit < myNum) myNum--;
						num_bikes--;
						replyChange--;
					}
				} //connection killed by guest*/
				else if (msg.sprite.speed == 1011) { } //ignore
				else if (msg.sprite.speed == 1111) {
					sprites[msg.sprite.image] = msg.sprite;
					sprites[msg.sprite.image].node = msg.sprite.node;
					if (joinedNum != msg.sprite.image) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%s%s has joined as %s%s",textColors[msg.sprite.image],msg.sprite.username,colorNames[msg.sprite.image],WHITE); myprintf(mystring); }
					joinedNum = msg.sprite.image;
					if (myNum == 0) {
						sprites[myNum].node = myNode;
						msg.sprite = sprites[msg.sprite.image];
						msg.sprite.dead = true;
						msg.sprite.speed = 1001;
						UDSSend(msg);
					}
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					sprites[myNum].node = myNode;
					memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
					sprites[myNum].node = myNode;
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				}
				else if (msg.sprite.speed == 123 && svcGetSystemTick() - readyLock > TICKS_PER_SEC) { if (!ready[msg.sender]) { numLeft++;  memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%s%s%s is ready! Waiting on %d more...", textColors[msg.sender], msg.sprite.username, WHITE, notReadies() - 1); myprintf(mystring); } ready[msg.sender] = true; if (msg.sprite.image != myNum) { msg.sprite.image = msg.sender; msg.sprite.speed = 777; UDSSend(msg); } }
				else if (msg.sprite.speed == 777 && svcGetSystemTick() - readyLock > TICKS_PER_SEC) {
					if (msg.sprite.image == myNum) replyChange[msg.sender] = true;
				} else if(msg.sprite.speed == 555) {
					if (msg.sender == 0) {
						UDSSend(msg); 
						break; 
					} else if (myNum == 0) {
						replyScore[msg.sender] = true;
					}
				} else {
					if (msg.sprite.image == myNum) replySprite[msg.sender] = true;
					else if (msg.sprite.image == msg.sender) {
						sprites[msg.sprite.image] = msg.sprite;
						UDSSend(msg);
					}
				}
			}
			if (allReady() && num_bikes > 1 && !lastScore) { 
				memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"Starting game....");  
				myprintf(mystring);
				if (myNum == 0) { 
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 555;
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					UDSSend(msg);
				}
				lastScore = svcGetSystemTick();
			}


			if (kDown & KEY_B && debugging) { numLeft++; memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"\x1b[%d;0H%d",numLeft + 5, (svcGetSystemTick() - waitForFinish) / TICKS_PER_SEC); myprintf(mystring); }
			if (myNum == 0 && kDown & KEY_SELECT) {
				if (!ready[0]) { gameOptions(); myconsoleClear(); }
				else myprintf("Can't edit modes when you are ready!");
			}
			if (kDown & KEY_A && svcGetSystemTick() - readyLock > TICKS_PER_SEC) { 
				if (num_bikes <= 1) break; 
				if (!ready[myNum]) { 
					sprites[myNum].node = myNode; 
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username)); 
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 123; 
					lastChange = svcGetSystemTick(); 
					memset(replyChange,0,sizeof(replyChange[0]) * 10); 
					UDSSend(msg); 
					numLeft++; 
					memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%s%s%s is ready! Waiting on %d more...",textColors[myNum],sprites[myNum].username,WHITE,notReadies() - 1); 
					myprintf(mystring);
				} 
				ready[myNum] = true;  
			}
			if (kDown & KEY_START) { return; }
			if(uds_enabled && udsWaitConnectionStatusEvent(false, false))
			{
				readyLock = svcGetSystemTick();
				for (int i = 0; i < 10; i++) {
					ready[i] = false;
				}
				ret = udsGetConnectionStatus(&constatus);
				ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
				if (constatus.total_nodes >= num_bikes) {
					num_bikes = constatus.total_nodes;
					memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes - 1].username));
					udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes - 1].username);
					msg.sprite = sprites[num_bikes - 1];
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					memset(replyChange,1,sizeof(replyChange[0]) * 10);
					numLeft++;
				} else {
						numLeft++;
						if (quit < 0) {
							numLeft++;
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"A player has crashed...");
							myprintf(mystring);
							errorQuit = svcGetSystemTick();
							while (1) {
								keepConsole();
								gfxFlushBuffers();
								gfxSwapBuffers();
								hidScanInput();
								kDown = hidKeysDown();
								if (kDown & KEY_START) {
									CATASTROPHIC_FAILURE = true;
									return;
								}
								if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 4) {
									numLeft++;
									if (numLeft >= 15) { myconsoleClear(); numLeft = 0; }
									memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%sError: unknown person left. Removing a color...%s",RED,WHITE);
									myprintf(mystring);
									num_bikes = constatus.total_nodes;
									memset(replyChange,1,sizeof(replyChange[0]) * 10);
									memset(replySprite,1,sizeof(replySprite[0]) * 10);
									if (myNum >= num_bikes) {
										myNum = num_bikes - 1;
										memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE);
										myprintf(mystring);
									}
									errorQuit = 0;
									break;
								}
								memset(tmpbuf, 0, tmpbuf_size);
								actual_size = 0;
								src_NetworkNodeID = 0;
								if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
								if(R_FAILED(ret))
								{
									memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.", (unsigned int)ret);
									myprintf(mystring);
									CATASTROPHIC_FAILURE = true;
									replay = false;
									return;
								}
								if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
								{

									memcpy(&msg,tmpbuf,sizeof(Message));
									if (msg.sprite.speed == 999 && msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
										joinedNum = 0;
										for (int i = 0; i < num_bikes; i++) {
											if (sprites[i].node == msg.sprite.node) { quit = i; break; }
										}
										if (quit < 0) {
											CATASTROPHIC_FAILURE = true;
											return;
										}
										memset(quitName,'\0',sizeof(quitName));
										strncpy(quitName,msg.sprite.username,sizeof(quitName));
										msg.sprite.image = msg.sprite.node;
										msg.sprite.node = myNode;
										UDSDirect(msg.sprite.image,msg);
										oldQuit = quit;
										numLeft++;
										if (numLeft + num_bikes - quit >= 15) { myconsoleClear(); numLeft = 0; }
										memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%s%s has left the game.%s",textColors[quit],quitName,WHITE);
										myprintf(mystring);
										if (quit > 0 && quit < num_bikes - 1) {
											if (quit < myNum) myNum--;
											for (int i = quit; i < num_bikes - 1; i++) {
												numLeft++;
												if (i == myNum) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE); }
												else { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"  %s%s%s is now %s%s%s!", textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE); }
												myprintf(mystring);
												sprites[i] = sprites[i+1];
												sprites[i].image = i;
											}
										}
										num_bikes = constatus.total_nodes;
										memset(replyChange,1,sizeof(replyChange[0]) * 10);
										memset(replySprite,1,sizeof(replySprite[0]) * 10);
										quit = -1;
										oldQuit = -1;
										break;
									}
								}
							}
						}
						else {
							joinedNum = 0;
							if (numLeft + num_bikes - quit >= 15) { myconsoleClear(); numLeft = 0; }
							memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%s%s has left the game.%s",textColors[quit],quitName,WHITE);
							myprintf(mystring);
							if (quit > 0 && quit < num_bikes - 1) {
								if (quit < myNum) myNum--;
								for (int i = quit; i < num_bikes - 1; i++) {
									numLeft++;
									if (i == myNum) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"  You are now %s%s%s!",textColors[myNum],colorNames[myNum],WHITE); }
									else memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"  %s%s%s is now %s%s%s!", textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE);
									myprintf(mystring);
									sprites[i] = sprites[i+1];
									sprites[i].image = i;
								}
								quit = -1;
							}
							oldQuit = -1;
							quit = -1;
						}
					/*int foundNum = -1;
					for (int i = 0; i < constatus.total_nodes; i++) {
						numLeft++;
						ret = udsGetNodeInformation(i,&tmpnode);
						udsGetNodeInfoUsername(&tmpnode,&sprites[i - 1].username);
						if (!strcmp(sprites[i].username,myname)) foundNum = i;
						myprintf("\x1b[%d;0H%s == %s? (%d)\n",numLeft + 5, sprites[i].username, myname,i);
					}
					if (foundNum == -1) myNum = constatus.total_nodes - 1;*/
					num_bikes = constatus.total_nodes;
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					memset(replyChange,1,sizeof(replyChange[0]) * 10);
					}
				}
			}
		}
	}
//---------------------------------------------------------------------------------
int main(int argc, char **argv) {
//---------------------------------------------------------------------------------
	// Initialize graphics
	gfxInitDefault();
	C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);

	// Output at 100% on the first pair of left and right channels.


	// Initialize the render target
	target = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	target2 = C3D_RenderTargetCreate(240, 320, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target2, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target2, GFX_BOTTOM, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	Result res = fontEnsureMapped();

	if (R_FAILED(res))
		return 1;
	//consoleInit(GFX_BOTTOM, NULL); //Print to bottom screen
	// Initialize the scene
	sceneInit();

	ret = 0;
	ret = udsInit(0x3000, NULL);//The sharedmem size only needs to be slightly larger than the total recv_buffer_size for all binds, with page-alignment.
	uds_enabled = true;
	if(R_FAILED(ret))
	{
		uds_enabled = false;
		if (ret == 0xc9411002) {
			myprintf("Wi-Fi must be turned on local play!");
			myprintf("Be sure you switch your wifi on");
			myprintf("For old 3ds, its the switch on the right");
			myprintf("\x1b[6;0HPress A or START to play offline.");
		}
		else {
			memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsInit failed: 0x%08x.\n\nPress A or START to play offline.", (unsigned int)ret);
			myprintf(mystring);
		}
		while (1) {
			keepConsole();
			gfxFlushBuffers();
			gfxSwapBuffers();
			hidScanInput();
			if (hidKeysDown() & KEY_START) break;
			if (hidKeysDown() & KEY_A) break;
		}
		myconsoleClear();
	}
	uds_test();
	size_t tmpbuf_size = 0x4000;
	u32 *tmpbuf = malloc(tmpbuf_size);
	size_t actual_size;
	u32 kDown;
	if (debugging) if (CATASTROPHIC_FAILURE) {
		memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%sCATASTROPHIC_FAILURE",RED);
		myprintf(mystring);
		while (1) {
			keepConsole();
			gfxFlushBuffers();
			gfxSwapBuffers();
			hidScanInput();
			if (hidKeysDown() & KEY_START) break;
		}
	}
	if (uds_enabled) {

		if (myNum && !CATASTROPHIC_FAILURE) {
			sprites[myNum].node = myNode;
			memset(sprites[myNum].username,'/0',sizeof(sprites[myNum].username));
			strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
			sprites[myNum].image = myNode;
			sprites[myNum].node = myNode;
			msg.sprite = sprites[myNum];
			msg.sprite.speed = 999; 
			UDSSend(msg);
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick(); 
			if (debugging) myprintf("Sending quit message...");
			while (1) {
				keepConsole();
				gfxFlushBuffers();
				gfxSwapBuffers();
				hidScanInput();
				kDown = hidKeysDown();
				if (kDown & KEY_START) {
					if (debugging) myprintf("...you stopped?");
					break;
				}
				if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					sprites[myNum].node = myNode;
					memset(sprites[myNum].username,'/0',sizeof(sprites[myNum].username));
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
					sprites[myNum].image = myNode;
					sprites[myNum].node = myNode;
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 999;
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
				if (uds_enabled) ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
				if(R_FAILED(ret))
				{
					memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"udsPullPacket() returned 0x%08x.\nYou failed to leave the game. Press start.", (unsigned int)ret);
					myprintf(mystring);
					replay = false;
					CATASTROPHIC_FAILURE = true;
					while (1) {
						keepConsole();
						gfxFlushBuffers();
						gfxSwapBuffers();
						hidScanInput();
						kDown = hidKeysDown();
						if (kDown & KEY_START) break;
					}
					break;
				}
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"image: %d sender: %d node: %d speed: %d", msg.sprite.image, msg.sender, msg.sprite.node, msg.sprite.speed); myprintf(mystring); }
					if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.timestamp == lastSprite) { if (debugging) { memset(mystring,'\0',sizeof(mystring)); snprintf(mystring,sizeof(mystring),"%d leaving: %d",myNode,msg.sprite.node); myprintf(mystring); } replySprite[msg.sprite.node] = true; }
					int responded = 0;
					for (int i = 0; i <= NUM_SPRITES; i++) {
						if (i != myNode && replySprite[i]) responded++;
					}
					if (responded >= num_bikes - 1) {
						if (debugging) myprintf("You successfuly left.");
						break;
					}
				}
			}
		}
		if(!myNum)
		{
			udsDestroyNetwork();
		}
		else
		{
			udsDisconnectNetwork();
		}
		udsUnbind(&bindctx);
		udsExit();
	}
	if (!CATASTROPHIC_FAILURE) {
		if (debugging) myprintf("You were successfully were removed from the game.");
		if (debugging) {
			while (1) {
				keepConsole();
				gfxFlushBuffers();
				gfxSwapBuffers();
				hidScanInput();
				kDown = hidKeysDown();
				if (kDown & KEY_START) break;
			}
		}
	}


	// Deinitialize the scene
	sceneExit();

	// Deinitialize graphics
	C3D_Fini();
	gfxExit();
	return 0;
}
