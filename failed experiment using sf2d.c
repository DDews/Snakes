/*

	Simple demo of sprites using citro3d, lodepng and immediate mode.

	Citra doesn't yet emulate immediate mode so this is hw only.

*/


#include <stdio.h>
#include <string.h>
#include <math.h>
#include <3ds.h>
#include <sf2d.h>
#include <sftd.h>
#include <time.h>
#include <stdlib.h>
#include <malloc.h>
#include <errno.h>
#include <stdarg.h>
#include <unistd.h>
#include "FreeSans_ttf.h"

// These headers are generated by the build process


#define TICKS_PER_MS 268123
#define TICKS_PER_SEC 268123480
#define CLEAR_COLOR 0x000000FF

#define MOVE_UP 1
#define MOVE_DOWN 2
#define MOVE_LEFT 3
#define MOVE_RIGHT 4
#define TYPE_DEATH 5

// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGBA8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

#define NUM_SPRITES 10


#define SAMPLERATE 22050
#define SAMPLESPERBUF (SAMPLERATE / 30)
#define BYTESPERSAMPLE 4


extern const struct {
  unsigned int 	 width;
  unsigned int 	 height;
  unsigned int 	 bytes_per_pixel;
  unsigned char	 pixel_data[];
} bike_img;


sf2d_texture *tex1;
u64 waitForFinish = 0;

bool readyToStart = false;
bool debugging = false;

int wakeup = false;
int myNode = 0;
bool CATASTROPHIC_FAILURE = false;
bool inGame = false;
u16 src_NetworkNodeID;
udsBindContext bindctx;
u64 errorQuit = 0;
bool clearFlag = true;
char myName[50];
char overwriteName[50];
int quit = -1;
u32 dead;
u32 dead2;
bool addedToGame = true;
u64 lastSent = 0;
u64 UDSSent = 0;
u64 receivedTick;
ndspWaveBuf waveBuf[2];
bool replay = true;
bool connectionEstablished = false;
udsConnectionStatus constatus;

bool usedSpecial = false;
u32 death = 0;
int myNum = 0;
int growthRate = 40;
int growth[10] = {40,40,40,40,40,40,40,40,40,40};
int timeDx = 45;
u32 pathPos[10] = {0,0,0,0,0,0,0,0,0,0};
u32 currentPath[10] = {1,1,1,1,1,1,1,1,1,1};
u32* audioBuffer;
bool ready[10] = {false, false, false, false, false, false, false, false, false, false};
size_t stream_offset = 0;
int bikeSpeed = (2 << 8);

void __oldPrintF(const char *format, ...) {
	return;
}
void __oldConsoleClear() {
	return;
}
void fill_buffer(void* audioBuffer, size_t offset, size_t size, int frequency) {
	u32* dest = (u32*) audioBuffer;

	for (int i = 0; i < size; i++) {
		// This is a simple sine wave, with a frequency of `frequency` Hz, and an amplitude 30% of maximum.
		s16 sample = 0.3 * 0x7FFF * sin(frequency * (2 * M_PI) * (offset + i) / SAMPLERATE);

		// Stereo samples are interleaved: left and right channels.
		dest[i] = (sample << 16) | (sample & 0xffff);
	}

	DSP_FlushDataCache(audioBuffer, size);
}
//simple sprite struct
typedef struct {
	int x,y;			// screen co-ordinates 
	int dx, dy;			// velocity
	int image;
	int speed;
	int length;
	bool dead;
	int node;
	char username[50];
}Sprite;

typedef struct {
	int x, y;
}Path;

Path path[400 * 240][10];

typedef struct {
	int x, y;
}Apple;

typedef struct {
	Sprite sprite;
	u64 timestamp;
	int sender;
}Message;

int actual_bikes = 1;
Message sentMsg;
u64 lastScore;
u64 lastChange;
u64 lastSprite;
bool replyDead[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyScore[10] = {0,0,0,0,0,0,0,0,0,0};
bool replyChange[10] = {0,0,0,0,0,0,0,0,0,0};
bool replySprite[10] = {0,0,0,0,0,0,0,0,0,0};

udsNodeInfo tmpnode;
Result ret=0;

size_t debugSize = sizeof(Message);
u32 gameOver = 0;
Apple apple;
Message msg;
udsConnectionType conntype;

int num_bikes = 1;
Sprite sprites[NUM_SPRITES];

u32 con_type = 0;

u32 ready_given = 0;


u32 READY_FLAG = 1234567;
u64 frameTicks[10];
int oneplayer = 0;
int score[10] = {0,0,0,0,0,0,0,0,0,0};
int oldscore[10];
int frozen = -1;
int joinedNum = 0;
int oldbikes;

u8* frameBuf;
int getLength(int num) {
	if (currentPath[num] < pathPos[num]) return ((400 * 240) - pathPos[num]) + currentPath[num];
	else return currentPath[num] - pathPos[num];
}

struct { float left, right, top, bottom; } images[10] = {
	{0.0f, 0.25f, 0.0f, 0.25f}, //bikes
	{0.25f, 0.5f, 0.0f, 0.25f},
	{0.5f, 0.75f, 0.0f, 0.25f},
	{0.75f, 1.0f, 0.0f, 0.25f},
	{0.0f, 0.25f, 0.25f, 0.5f},
	{0.25f, 0.5f, 0.25f, 0.5f},
	{0.5f, 0.75f, 0.25f, 0.5f},
	{0.75f, 1.0f, 0.25f, 0.5f},
	{0.0f, 0.5f, 0.5f, 1.0f}, //apple
	{0.5f, 1.0f, 0.5f, 1.0f}, //erase
};
u32 colors[10] = { 0x000cff00, 0x00e4ff00, 0x00004eff, 0x00fc00ff, 0x0000fff0, 0x0025722c, 0x00ff9600, 0x00ff7f82, 0x00ffffff, 0x00000000 };
#define ESC(x) "\x1b[" #x
#define RED     ESC(31;1m)
#define GREEN   ESC(32;1m)
#define YELLOW  ESC(33;1m)
#define BLUE    ESC(34;1m)
#define MAGENTA ESC(35;1m)
#define CYAN    ESC(36;1m)
#define WHITE   ESC(37;1m)
char textColors[8][12] = {GREEN, YELLOW, BLUE, MAGENTA, CYAN, GREEN, YELLOW, RED};
char colorNames[8][12] = {"Green", "Yellow", "Blue", "Magenta", "Cyan", "Dark Green", "Orange", "Pink"};
bool fillBlock = false;
bool first = true;

u32 getColor(int x, int y) {
	return frameBuf[(x * 240) - y + 239];
	/*if (x > 400) x = 0;
	else if(x < 0) x = 400;
	if (y > 240) y = 0;
	else if (y < 0) y = 240;
	u32 offset = ((x * 240) - y + 239) * 3;
	return (u32) (frameBuf[offset] | frameBuf[offset + 1]  << 8 | frameBuf[offset  + 2] << 16);*/
}
void playSound() {
	if (waveBuf[fillBlock].status != NDSP_WBUF_PLAYING) {
		fill_buffer(waveBuf[fillBlock].data_pcm16, stream_offset, waveBuf[fillBlock].nsamples, 440);
		ndspChnWaveBufAdd(0, &waveBuf[fillBlock]);
		stream_offset += waveBuf[fillBlock].nsamples;
		fillBlock = !fillBlock;
	}
}
//---------------------------------------------------------------------------------
void drawSprite( int x, int y, int width, int height, int image ) {
//---------------------------------------------------------------------------------
	u32 color = getColor(x,y);
	if (image != 9 && color != colors[8] && color) return;
	float left = images[image].left;
	float right = images[image].right;
	float top = images[image].top;
	float bottom = images[image].bottom;

	// Draw a textured quad directly
	sf2d_start_frame(GFX_BOTTOM, GFX_LEFT);
		sf2d_draw_rectangle(x, y, 2, 2, colors[image]);
	sf2d_end_frame();

}


static int uLoc_projection;

static bool nextTo = false;


static int lagMult() {
	if (num_bikes <= 2) return 1;
	return (num_bikes - 2);
}
u32 timeDiff(int num) {
	return (u32)((svcGetSystemTick() - frameTicks[num]) / TICKS_PER_MS / sprites[num].speed);
}
static void UDSResend(bool replied[], Message msg) {
	msg.sender = myNum;
	sentMsg = msg;
	ret=0;
	if (msg.sprite.speed == 77) msg.timestamp = lastScore;
	else if (msg.sprite.speed == 66) msg.timestamp = lastChange;
	else msg.timestamp = lastSprite;
	if(conntype!=UDSCONTYPE_Spectator)
	{
		for (int i = 0; i < num_bikes; i++) {
			if (debugging) __oldPrintF("resending to... %d: %d\n",i,sprites[i].node);
			if (!replied[i] && i != myNum && sprites[i].node) {
				ret = udsSendTo(sprites[i].node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
				if (UDS_CHECK_SENDTO_FATALERROR(ret))
				{
					if (debugging) __oldPrintF("Error: UDSResend() returned 0x%08x.\n",(unsigned int)ret);
				}
			}
		}
	}
}
static bool allReplied(bool replied[]) {
	for (int i = 0; i < num_bikes; i++) {
		if (!replied[i] && i != myNum) return false;
	}
	return true;
}
static int UDSDirect(int node, Message msg) {
	msg.sender = myNum;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		ret = udsSendTo(node, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			__oldPrintF("Error: UDSSend() returned 0x%08x.\n", (unsigned int)ret);
			CATASTROPHIC_FAILURE = true;
			return 1;
		}
	}
	return 0;
}
static int UDSSend(Message msg) {
	msg.sender = myNum;
	if (debugging) __oldPrintF("sending speed: %d image: %d dead %d\n",msg.sprite.speed,msg.sprite.image,msg.sprite.dead);
	if (msg.sprite.image == myNum && msg.sprite.speed == 77) { memset(replySprite,0,sizeof(replyScore[0]) * 10); lastScore = svcGetSystemTick(); msg.timestamp = lastScore; }
	else if (msg.sprite.image == myNum && msg.sprite.speed == 66) { memset(replySprite,0,sizeof(replyScore[0]) * 10); lastChange = svcGetSystemTick(); msg.timestamp = lastChange; }
	else if (msg.sprite.image == myNum) { memset(replySprite,0,sizeof(replySprite[0]) * 10); lastSprite = svcGetSystemTick(); msg.timestamp = lastSprite; }
	else if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.sprite.node == myNode) { msg.timestamp = lastSprite; msg.sender = myNode; }
	sentMsg = msg;
	ret=0;
	if(conntype!=UDSCONTYPE_Spectator)//Spectators aren't allowed to send data.
	{
		ret = udsSendTo(UDS_BROADCAST_NETWORKNODEID, 1, UDS_SENDFLAG_Default, &msg, sizeof(msg));
		if(UDS_CHECK_SENDTO_FATALERROR(ret))
		{
			__oldPrintF("Error: UDSSend() returned 0x%08x.\n", (unsigned int)ret);
			CATASTROPHIC_FAILURE = true;
			return 1;
		}
	}
	return 0;
}
static int sendTick(u64 timestamp) {
	ret=0;
	ret = udsSendTo(UDS_BROADCAST_NETWORKNODEID, 1, UDS_SENDFLAG_Default, &timestamp, sizeof(timestamp));
	if (UDS_CHECK_SENDTO_FATALERROR(ret))
	{
		__oldPrintF("Error: sendTick() return 0x%08x.\n", (unsigned int)ret);
		return 1;
	}
}
bool itsATie() {
	int s = score[0];
	int winner = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] > s) { s = score[i]; winner = i; }
	}
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] == s && i != winner) return true;
	}
	return false;
}
int getHighestScore() {
	int highestScore = 0;
	if (itsATie()) return -1;
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (score[i] > highestScore) {
			highestScore = score[i];
			r = i;
		}
	}
	return r;
}
int theHighest() {
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (r < score[i]) r = score[i];
	}
	return r;
}
bool everyoneElseIsDead() {
	if (actual_bikes <= 1) {
		if (sprites[0].dead) return true;
		return false;
	}
	for (int i = 0; i < num_bikes; i++) {
		if (i != myNum && !sprites[i].dead) return false;
	}
	return true;
}
bool allReady() {
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) return false;
	}
	return true;
}
int notReadies() {
	int r = 0;
	for (int i = 0; i < num_bikes; i++) {
		if (!ready[i]) r++;
	}
	return r;
}
int getKiller(u32 color) {
	for (int i = 0; i < NUM_SPRITES; i++) {
		if (color == colors[i]) return i;
	}
	return 0;
}
bool hasCommonY(int num) {
	if (sprites[num].y < (1 << 8) || sprites[num].y > (398 << 8)) return true;
	if (abs((sprites[num].y >> 8) - (apple.y >> 8)) < 3) return true;
	for (int i = 0; i < num; i++) {
		if (abs((sprites[i].y >> 8) - (sprites[num].y >> 8)) < 3) return true;
	}
	return false;
}
static void setSprites() {
	first = true;
	srand(time(NULL));
	usedSpecial = false;
	memset(path, 0, sizeof(path[0][0]) * 240 * 400 * 10);
	for(int i = 0; i < NUM_SPRITES; i++) {
		//random place and speed
		apple.x = (rand() % (400 - 32)) << 8;
		apple.y = (rand() % (240 - 32)) << 8;
		sprites[i].x = (rand() % (400 - 32 )) << 8;
		sprites[i].y = (rand() % (240 - 32 )) << 8 ;
		while (hasCommonY(i)) {
			sprites[i].y = (rand() % (240 - 32 )) << 8 ;
		}
		sprites[i].dx = (2<<8);
		sprites[i].dy = 0;
		sprites[i].image = i;
		sprites[i].speed = 45;
		sprites[i].dead = false;

		memset(sprites[i].username,'\0',sizeof(sprites[i].username));
		path[0][i].x = sprites[i].x;
		path[0][i].y = sprites[i].y;

		sprites[i].length = 40;
		growth[i] = 0;
		currentPath[i] = 1;
		pathPos[i] = 0;

		if(rand() & 1)
			sprites[i].dx = -sprites[i].dx;
		if(rand() & 1)
			sprites[i].dy = -sprites[i].dy;
	}
}
static void changeApple() {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = (rand() % (400 - 32)) << 8;
	apple.y = (rand() % (240 - 32)) << 8;
	while (getColor(apple.x >> 8, apple.y >> 8)) {
		apple.x = (rand() % (400 - 32)) << 8;
		apple.y = (rand() % (240 - 32)) << 8;
	}
	drawSprite(oldx >> 8, oldy >> 8, 2, 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 66;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
}
static void moveApple() {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = (rand() % (400 - 32)) << 8;
	apple.y = (rand() % (240 - 32)) << 8;
	while (getColor(apple.x >> 8, apple.y >> 8)) {
		apple.x = (rand() % (400 - 32)) << 8;
		apple.y = (rand() % (240 - 32)) << 8;
	}
	drawSprite(oldx >> 8, oldy >> 8, 2, 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	msg.sprite = sprites[myNum];
	msg.sprite.image = myNum;
	msg.sprite.speed = 77;
	msg.sprite.x = apple.x;
	msg.sprite.y = apple.y;
	UDSSend(msg);
	usedSpecial = false;
}
static void updateApple(int x, int y) {
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx >> 8, oldy >> 8, 2 , 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
}
static void setApple(int player, int x, int y) {
	if (abs(player) > num_bikes) return;
	int oldx = apple.x;
	int oldy = apple.y;
	apple.x = x;
	apple.y = y;
	drawSprite(oldx >> 8, oldy >> 8, 2 , 2, 9);
	drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
	score[player]++;
	growth[player] += growthRate;
	sprites[player].length += growthRate;
	usedSpecial = false;
}
void print_constatus()
{
	ret=0;
	u32 pos;
	

	//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
	ret = udsGetConnectionStatus(&constatus);
	if(R_FAILED(ret))
	{
		__oldPrintF("udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
		CATASTROPHIC_FAILURE = true;
		return;
	}
	else
	{
		if (debugging) {
			__oldPrintF("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
			__oldPrintF("1=0x%x\n", (unsigned int)constatus.unk_x4);
			__oldPrintF("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
			__oldPrintF("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
			for(pos=0; pos<(0x20>>2); pos++)__oldPrintF("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
			__oldPrintF("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
			__oldPrintF("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
			__oldPrintF("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
		}
	}
}
u64 debugLastSent;
u64 debugUDSSent;
//---------------------------------------------------------------------------------
static void sceneInit(void) {
//---------------------------------------------------------------------------------

	memset(path,0,sizeof(path[0][0]) * 400 * 240 * 3);
	// Load the vertex shader, create a shader program and bind it
	srand(time(NULL));

	sf2d_init();
	sf2d_set_clear_color(RGBA8(0x40, 0x00, 0x00, 0x00));
	setSprites();
	// Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
	//frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);
}
static void printScore() {
	__oldPrintF("\x1b[0;0HScore: ");
		for (int i = 0; i < num_bikes; i++) {
			__oldPrintF("%s%d", textColors[i],score[i]);
			if (i < num_bikes - 1) __oldPrintF(" %s- ",WHITE);
		}
	death = dead;
	if (!death) death = dead2;
	if (sprites[myNum].dead) __oldPrintF("\x1b[1;0H%sYou are %sdead%s (%s%s%s)",WHITE,RED,WHITE,textColors[getKiller(death)],sprites[getKiller(death)].username,WHITE);
	else { 
		__oldPrintF("\x1b[1;0H%sYou are %salive%s! ",WHITE,GREEN,WHITE);
		if (everyoneElseIsDead()) __oldPrintF("\x1b[6;0HGet %d more points!",theHighest() - score[myNum] + 1);
	}
	__oldPrintF("\x1b[2;0HHold %sA%s to move Faster.",RED,WHITE);
	__oldPrintF("\x1b[3;0HHold %sB%s to move Slower.",YELLOW,WHITE);
	__oldPrintF("\x1b[4;0HPress %sY%s to teleport the apple once.",GREEN,WHITE);
	int x = 5;
	for (int i = actual_bikes; i < num_bikes; i++) {
		__oldPrintF("\x1b[%d;0H%s%s%s has joined the game. (%d.%d)",x + i - actual_bikes,textColors[i],sprites[i].username,WHITE, actual_bikes, num_bikes);
	}
	if (debugging) __oldPrintF("\x1b[5;0Hactual_bikes: %d mynum: %d %d",actual_bikes, myNum, num_bikes);
	//__oldPrintF("\x1b[5;0Hdead: 0x%08x, 0x%08x",dead,dead2);
	//__oldPrintF("\x1b[6;0Hnum_bikes: %d, myNum: %d",num_bikes,myNum);
	//__oldPrintF("\x1b[7;0Hgrowth: %d length: %d (%d)",growth[myNum],sprites[myNum].length,getLength(myNum));
	//__oldPrintF("\x1b[8;0HpathPos: %d currentPath: %d",pathPos[myNum],currentPath[myNum]);
}
static void drawLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, int img) {
	int w = (dx >> 8) - (sx >> 8);
	int h = (dy >> 8) - (sy >> 8);
	int x = sx;
	int y = sy;
	if (w < 0 || h < 0) { 
		x = dx;
		y = dy;
	}
	w = abs(w);
	h = abs(h);
	//drawSprite(x >> 8, y >> 8, w, h, img);
	if (w <= 2) { h = 2 << 8; w = 0; }
	else { h = 0; w = 2 << 8; }
	while (pathnum != currentPath[img]) {
		drawSprite(path[pathnum][img].x >> 8, path[pathnum][img].y >> 8, 2, 2, 9);
		drawSprite(x >> 8, y >> 8, 2, 2, img);
		path[pathnum][img].x = x;
		x += w;
		path[pathnum][img].y = y;
		y += h;
		pathnum++;
		if (pathnum > 240 * 400) pathnum = 0;
	}
	path[pathnum][img].x = x;
	path[pathnum][img].y = y;
	drawSprite(x >> 8, y >> 8, 2, 2, img);
}
static void eraseOvershoot(Sprite sprite) {
	int img = sprite.image;
	int cx = path[currentPath[img]][img].x >> 8;
	int cy = path[currentPath[img]][img].y >> 8;
	int udx = sprite.x >> 8;
	int udy = sprite.y >> 8;
	if (cx == udx && cy == udy) return;
	int pathn = currentPath[img];
	while ((path[pathn][img].x >> 8) != udx && (path[pathn][img].y >> 8) != udy && pathn != pathPos[img]) {
		drawSprite(path[pathn][img].x >> 8, path[pathn][img].y >> 8, 2, 2, 9);
		pathn--;
		if (pathn < 0) pathn = 240 * 400;
	}
}
static void finishLine(int pathnum,u32 sx, u32 sy, u32 dx, u32 dy, Sprite msg, int img) {
	if ((sx >> 8) == (dx >> 8) && (sy >> 8) == (dy >> 8)) {
		drawSprite(sy,dy,2,2,img);
		return;
	}
	int udx = dx >> 8;
	int udy = dy >> 8;
	int x = sx >> 8;
	int y = sy >> 8;
	int w = udx - x;
	int h = udy - y;
	if (abs(w) > 100 || abs(h) > 100) return;



	//drawSprite(x >> 8, y >> 8, w, h, img);
	int pathn = currentPath[img] - 1;
	if (pathn < 0) pathn = 240 * 400;
	int prevx = path[pathn][img].x >> 8;
	int prevy = path[pathn][img].y >> 8;
	pathn--;
	if (pathn < 0) pathn = 240 * 400;
	int prevx2 = path[pathn][img].x >> 8;
	int prevy2 = path[pathn][img].y >> 8;
	pathn = currentPath[img];
	int i = 0;
	if (x != udx && y != udy) {
		//__oldPrintF("\nYABADABADOO\n");
		int tx, ty;
		if (w < 0) tx = -2;
		else tx = 2;
		if (h < 0) ty = -2;
		else ty = 2;
		//if ((msg.dy != 0 && prevx == prevx2) || (msg.dx != 0 && prevy == prevy2)) { 
			if (prevx - prevx2 > 0 && w > 0 || prevx - prevx2 < 0 && w < 0 || prevy - prevy2 > 0 && h > 0 || prevy - prevy2 < 0 && h < 0) {//draw
				if (debugging) __oldPrintF("\nOMG\n");
				if (prevy == prevy2) while (x != udx && i < 20) { i++; x += tx; drawSprite(x,y,2,2,6); currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; path[currentPath[img]][img].x = x << 8; path[currentPath[img]][img].y = y << 8; }
				else if (prevx == prevx2) while (y != udy && i < 20) { i++; x += ty; drawSprite(x,y,2,2,6); currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; path[currentPath[img]][img].x = x << 8; path[currentPath[img]][img].y = y << 8; }
				currentPath[img]++;
			} 
			else { //erase
				if (debugging) __oldPrintF("\n!!!!\n");
				if (prevx == prevx2) {
					while ((path[pathn][img].y >> 8) != udy && i < 20) { i++; drawSprite(path[pathn][img].x >> 8,path[pathn][img].y >> 8,2,2,9); pathn--; }
					x = path[pathn][img].x >> 8;
					y = path[pathn][img].y >> 8;
					i = 0;
					drawSprite(x,y,2,2,img);
					while ((path[pathn][img].x >> 8) != udx && i < 20) { i++; x += tx; pathn++; drawSprite(x,y,2,2,img); path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; if (pathn > 240 * 400) pathn = 0; }
					//if (pathn == currentPath[img]) currentPath[img]++;
					if (currentPath[img] > 240 * 400) currentPath[img] = 0;
				}
				else if (prevy == prevy2) {
					while ((path[pathn][img].x >> 8) != udx && i < 20) { i++; drawSprite(path[pathn][img].x >> 8,path[pathn][img].y >> 8,2,2,9); pathn--; }
					x = path[pathn][img].x >> 8;
					y = path[pathn][img].y >> 8;
					i = 0;
					drawSprite(x,y,2,2,img);
					while ((path[pathn][img].y >> 8) != udy && i < 20) { i++; y += ty; drawSprite(x,y,2,2,img); pathn++; path[pathn][img].x = x << 8; path[pathn][img].y = y << 8; if (pathn >= currentPath[img]) currentPath[img]++; if (currentPath[img] > 240 * 400) currentPath[img] = 0; if (pathn > 240 * 400) pathn = 0; }
					//if (pathn == currentPath[img]) currentPath[img]++;
					if (currentPath[img] > 240 * 400) currentPath[img] = 0;
				}
				drawSprite(dx,dy,2,2,img);
			}
		//}
		return;
	}


	if (w == 0) { 
		if (h < 0) h = -2; 
		else h = 2; 
		w = 0; 
	}
	else { 
		h = 0; 
		if (w < 0) w = -2; 
		else w = 2; 
	}

	if (w != 0 && h != 0) return;

	//Erase overshoot.
	/*pathn = currentPath[img];
	if (h < 0) { while (path[pathn][img].y < dy) { drawSprite(path[pathn][img].x,path[pathn][img].y,2,2,4); pathn--; } return; }
	else if (h > 0) { while (path[pathn][img].y > dy) { drawSprite(path[pathn][img].x,path[pathn][img].y,2,2,4); pathn--; } return; }
	else if (w < 0) { while (path[pathn][img].x < dx) { drawSprite(path[pathn][img].x,path[pathn][img].y,2,2,4); pathn--; } return; }
	else if (w > 0) { while (path[pathn][img].x > dx) { drawSprite(path[pathn][img].x,path[pathn][img].y,2,2,4); pathn--; } return; }
	*/
	dx = dx >> 8;
	dy = dy >> 8;
	if (x != udx && y != udy) return;

	i = 0;

	//Now fill in shortcomings.
	int c = rand() % 9;
	if (udx == prevx && udy == prevy) {
		if (debugging) {
			while (c == img) c = rand() % 9;
			__oldPrintF("%s%d .. %d%s\n",textColors[c],udx,udy,WHITE);
			drawSprite(sx >> 8,sy >> 8,2,2,c);
			drawSprite(dx, dy, 2, 2, c);
		}
		return;
	}
	if (debugging) {
		while (c == img) c = rand() % 9;
		__oldPrintF("%sok.%s\n",textColors[c],WHITE);
	}
	//drawSprite(sx,sy,2,2,c);
	while ((x != dx || y != dy) && (i < 4)) {
		i++;	

		/*drawSprite(path[pathPos[img]][img].x >> 8,path[pathPos[img]][img].y >> 8,2,2,9);
		pathPos[img]++;
		if (pathPos[img] > 240 * 400) pathPos[img] = 0;
		*/
		path[currentPath[img]][img].y = (y << 8);
		path[currentPath[img]][img].x = (x << 8);
		drawSprite(x, y, 2, 2, img);
		currentPath[img]++;
		if (currentPath[img] > 240 * 400) currentPath[img] = 0;
		x += w;
		
		y += h;
		
	}
	path[currentPath[img]][img].y = (y << 8);
	path[currentPath[img]][img].x = (x << 8);
	/*drawSprite(path[pathPos[img]][img].x >> 8,path[pathPos[img]][img].y >> 8,2,2,9);
	pathPos[img]++;
	if (pathPos[img] > 240 * 400) pathPos[img] = 0;*/
	/*currentPath[img]++;
	if (currentPath[img] > 240 * 400) currentPath[img] = 0;
	path[currentPath[img]][img].x = (x << 8);
	path[currentPath[img]][img].y = (y << 8);*/
	//drawSprite(x, y, 2, 2, img);
}
//---------------------------------------------------------------------------------
static void moveSprites() {
//---------------------------------------------------------------------------------
	int i;
	for(i = 0; i < num_bikes; i++) {
		if (sprites[i].dead || !timeDiff(i)) continue;
		sprites[i].x += sprites[i].dx;
		sprites[i].y += sprites[i].dy;
		if(sprites[i].x < (2<<8)) sprites[i].x = (398) << 8;
		else if (sprites[i].x > ((398) << 8)) sprites[i].x = (2<<8);

		if(sprites[i].y < (2<<8)) sprites[i].y = (238 << 8);
		else if (sprites[i].y > (238 << 8)) sprites[i].y = (2<<8);

		frameTicks[i] = svcGetSystemTick();
		while (getLength(i) * .9 > sprites[i].length) {
			drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
			pathPos[i]++;
		}
		if (growth[i]) growth[i]--;
		else if (getLength(i) >= sprites[i].length) {
			drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
			pathPos[i]++;
		}
		currentPath[i]++;
		if (pathPos[i] > 400 * 240) pathPos[i] = 0;
		if (currentPath[i] > 400 * 240) currentPath[i] = 0;
		path[currentPath[i]][i].x = sprites[i].x;
		path[currentPath[i]][i].y = sprites[i].y;
		if (i == myNum) {
			u32 color1 = getColor(sprites[i].x >> 8, sprites[i].y >> 8);
			u32 color2 = getColor((sprites[i].x >> 8) + 1, (sprites[i].y >> 8) + 1);
			if (abs((sprites[i].x >> 8) - (apple.x >> 8)) <= 2 && abs((sprites[i].y >> 8) - (apple.y >> 8)) <= 2) {
				score[i]++;
				growth[i] += growthRate;
				sprites[i].length += growthRate;
				moveApple();
			}
			else if (getLength(i) < 5) {} //don't die if game just started
			else if ((color1 != colors[8] && color2 != colors[8]) && (color1 > 0 || color2 > 0)) {
				dead = color1;
				dead2 = color2;
				sprites[i].dead = true;
				msg.sprite = sprites[i];
				UDSSend(msg); //dead
			}
		}
	}
	frozen = -1;
}

//---------------------------------------------------------------------------------
static void sceneRender(void) {
//---------------------------------------------------------------------------------
	int i;
	// Update the uniforms
	//C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);

	for(i = 0; i < num_bikes; i++) {
		if (i < actual_bikes) { 
			drawSprite( sprites[i].x >> 8, sprites[i].y >> 8, 2, 2, sprites[i].image);
			if ((path[currentPath[i]][i].x >> 8) != (sprites[i].x >> 8) || (path[currentPath[i]][i].y >> 8) != (sprites[i].y >> 8)) {
				currentPath[i]++;
				path[currentPath[i]][i].x = sprites[i].x;
				path[currentPath[i]][i].y = sprites[i].y;
			}
		}
		drawSprite(path[pathPos[i]][i].x >> 8, path[pathPos[i]][i].y >> 8, 2, 2, 9);
	}

}
//---------------------------------------------------------------------------------
static void sceneExit(void) {
//---------------------------------------------------------------------------------

	
}
static SwkbdCallbackResult wrongName(void* user, const char** ppMessage, const char* text, size_t textlen)
{
	if (strstr(text, "host"))
	{
		*ppMessage = "Just no.";
		return SWKBD_CALLBACK_CONTINUE;
	}

	/*if (strstr(text, "brick"))
	{
		*ppMessage = "~Time to visit Brick City~";
		return SWKBD_CALLBACK_CLOSE;
	}*/

	return SWKBD_CALLBACK_OK;
}
void uds_test()
{


	memset(overwriteName,'\0',sizeof(overwriteName));
	ret=0;
	con_type=0;


	for (int i = 0; i < NUM_SPRITES; i++) {
		memset(sprites[i].username,'\0',sizeof(sprites[i].username));
	}
	u8 data_channel = 1;
	udsNetworkStruct networkstruct;
	udsNetworkScanInfo *networks = NULL;
	udsNetworkScanInfo *network = NULL;
	size_t total_networks = 0;

	u32 recv_buffer_size = UDS_DEFAULT_RECVBUFSIZE;
	u32 wlancommID = 0x783a9dab;//Unique ID, change this to your own.
	char *passphrase = "dandewsudstron saadbaigistheman";//Change this passphrase to your own. The input you use for the passphrase doesn't matter since it's a raw buffer.

	conntype = UDSCONTYPE_Client;

	u32 transfer_data, prev_transfer_data = 0;
	size_t actual_size;
	u32 tmp=0;
	u32 pos;

	u8 appdata[0x14] = {0x69, 0x8a, 0x05, 0x5c};
	u8 out_appdata[0x14];

	char tmpstr[256];

	strncpy((char*)&appdata[4], "Test appdata.", sizeof(appdata)-1);

	//printf("Successfully initialized.\n");

	size_t tmpbuf_size = 0x4000;
	u32 *tmpbuf = malloc(tmpbuf_size);
	if(tmpbuf==NULL)
	{
		__oldPrintF("Failed to allocate tmpbuf for beacon data.\n");
		return;
	}
	int hosting = 0;
	int readyToJoin = 0;
	sf2d_set_vblank_wait(0);
	sftd_init();
	sftd_font *font = sftd_load_font_mem(FreeSans_ttf, FreeSans_ttf_size);

	while (1) {
		hidScanInput();

		sf2d_start_frame(GFX_TOP, GFX_LEFT);
			sftd_draw_text(font, 10, 10,  RGBA8(0,   255, 255,   255), 20, "Hold A to host\nPress B to scan for a host.\nPress Y to change name.\nPress START to exit.\n");
		sf2d_end_frame();
		sf2d_start_frame(GFX_BOTTOM, GFX_LEFT);

			sftd_draw_text(font, 10, 10,  RGBA8(0,   255, 255,   255), 20, "Hold A to host\nPress B to scan for a host.\nPress Y to change name.\nPress START to exit.\n");

		sf2d_end_frame();
		sf2d_swapbuffers();
		// Respond to user input
		u32 kDown = hidKeysDown();
		u32 kHeld = hidKeysHeld();
		if (kDown & KEY_START) return;
		//if (kDown & KEY_L) { debugging = true; printf("Debugging turned on.\n"); }
		//if (kDown & KEY_A) { hosting = 1; break; }
		else if (kDown & KEY_Y) {
			static SwkbdState swkbd;
			static char mybuf[20];
			static SwkbdStatusData swkbdStatus;
			static SwkbdLearningData swkbdLearning;
			SwkbdButton button = SWKBD_BUTTON_NONE;
			swkbdInit(&swkbd, SWKBD_TYPE_NORMAL, 3, -1);
			swkbdSetValidation(&swkbd, SWKBD_NOTEMPTY_NOTBLANK, 0, 0);
			swkbdSetFilterCallback(&swkbd, wrongName, NULL);
			swkbdSetInitialText(&swkbd, mybuf);
			swkbdSetHintText(&swkbd, "Please enter your name");
			swkbdSetButton(&swkbd, SWKBD_BUTTON_LEFT, "Cancel", false);
			//swkbdSetButton(&swkbd, SWKBD_BUTTON_MIDDLE, "~Middle~", true);
			swkbdSetButton(&swkbd, SWKBD_BUTTON_RIGHT, "Done", true);
			swkbdSetFeatures(&swkbd, SWKBD_PREDICTIVE_INPUT);
			SwkbdDictWord words[2];
			swkbdSetDictWord(&words[0], "lenny", "( ͡° ͜ʖ ͡°)");
			swkbdSetDictWord(&words[1], "shrug", "¯\\_(ツ)_/¯");
			swkbdSetDictionary(&swkbd, words, sizeof(words)/sizeof(SwkbdDictWord));
			static bool reload = false;
			swkbdSetStatusData(&swkbd, &swkbdStatus, reload, true);
			swkbdSetLearningData(&swkbd, &swkbdLearning, reload, true);
			reload = true;
			button = swkbdInputText(&swkbd, mybuf, sizeof(mybuf));
			if (button != SWKBD_BUTTON_NONE && strlen(mybuf) > 0) { 
				memset(overwriteName,'\0',sizeof(overwriteName));
				utf32_to_utf8(overwriteName,L"( ͡° ͜ʖ ͡°)",sizeof(overwriteName));
				//strncpy(overwriteName,mybuf,sizeof(overwriteName));
				__oldPrintF("Welcome, %s\n", overwriteName);
			} else __oldPrintF("Name set to default.\n");
		}
		else if((kDown & KEY_B) || (kHeld & KEY_B)) {
			__oldPrintF("Scanning...\n");
			while (1) {
				sf2d_swapbuffers();
				hidScanInput();
				kHeld = hidKeysHeld();
				kDown = hidKeysDown();
				if (!(kHeld & KEY_B)) break;
				total_networks = 0;
				memset(tmpbuf, 0, sizeof(tmpbuf_size));
				ret = udsScanBeacons(tmpbuf, tmpbuf_size, &networks, &total_networks, wlancommID, 0, NULL, false);
				//printf("udsScanBeacons() returned 0x%08x.\ntotal_networks=%u.\n", (unsigned int)ret, (unsigned int)total_networks);

				if(total_networks) { network = &networks[0]; readyToJoin = 1; break; }
			}
			if (total_networks == 1) {
				if (network->network.total_nodes >= 8) {
					readyToJoin = false;
					__oldPrintF("Only one room was found and it was full!\nPress A to go back to main menu\n");
					while (1) {
						
						hidScanInput();
						kDown = hidKeysDown();
						if (kDown & KEY_A) break;
						if (kDown & KEY_START) return;
					}
				}
			}
			if (total_networks > 1) {
				int selected = 0;
				__oldConsoleClear();
				__oldPrintF("Please choost a host by 3ds name:\n");
				while (1) {
					sf2d_swapbuffers();//At this point you'd let the user select which network to connect to and optionally display the first node's username(the host), along with the parsed appdata if you want. For this example this just uses the first detected network and then displays the username of each node.
					//If appdata isn't enough, you can do what DLP does loading the icon data etc: connect to the network as a spectator temporarily for receiving broadcasted data frames.

					network = &networks[0];

					if (debugging) __oldPrintF("network: total nodes = %u.\n", (unsigned int)network->network.total_nodes);


					for(pos=0; pos<total_networks; pos++)
					{
						network = &networks[pos];
						if(!udsCheckNodeInfoInitialized(&network->nodes[0]))continue;
						if (network->network.total_nodes >= 8) continue;
						free(tmpbuf);
						tmpbuf = NULL;
						memset(tmpstr, 0, sizeof(tmpstr));

						ret = udsGetNodeInfoUsername(&network->nodes[0], tmpstr);
						if(R_FAILED(ret))
						{
							__oldPrintF("udsGetNodeInfoUsername() returned 0x%08x.\n", (unsigned int)ret);
							CATASTROPHIC_FAILURE = true;
							free(networks);
							return;
						}

						if (pos == selected) printf("\x1b[%d;0H%s%s%s\n", (unsigned int)(pos + 1), YELLOW, tmpstr, WHITE);
						else __oldPrintF("\x1b[%d;0H%s",(unsigned int)(pos + 1),tmpstr);
					}
					hidScanInput();
					kDown = hidKeysDown();
					if ((kDown & KEY_DUP) || (kDown & KEY_CPAD_UP)) selected--;
					if ((kDown & KEY_DDOWN) || (kDown & KEY_CPAD_DOWN)) selected++;
					if (kDown & KEY_A) { network = &networks[selected]; break; }
					if (selected < 0 || selected >= total_networks) selected = 0;
				}
			}
			__oldConsoleClear();
			if (readyToJoin) break;
			else __oldPrintF("Hold A to host\nPress B to scan for a host.\nPress Y to change name.\nPress START to exit.\n");
		}

	}
	if(total_networks && !hosting)
	{
		free(tmpbuf);
		tmpbuf = NULL;
		//At this point you'd let the user select which network to connect to and optionally display the first node's username(the host), along with the parsed appdata if you want. For this example this just uses the first detected network and then displays the username of each node.
		//If appdata isn't enough, you can do what DLP does loading the icon data etc: connect to the network as a spectator temporarily for receiving broadcasted data frames.


		if (debugging) __oldPrintF("network: total nodes = %u.\n", (unsigned int)network->network.total_nodes);


		for(pos=0; pos<NUM_SPRITES; pos++)
		{
			if(!udsCheckNodeInfoInitialized(&network->nodes[pos]))continue;

			memset(tmpstr, 0, sizeof(tmpstr));

			ret = udsGetNodeInfoUsername(&network->nodes[pos], tmpstr);
			if(R_FAILED(ret))
			{
				__oldPrintF("udsGetNodeInfoUsername() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				free(networks);
				return;
			}

			if (debugging) __oldPrintF("node%u username: %s\n", (unsigned int)pos, tmpstr);
		}

		//You can load appdata from the scanned beacon data here if you want.
		/*while (1) {
			gspWaitForVBlank();
			hidScanInput();
			if (hidKeysDown() & KEY_START) return;
			actual_size = 0;
			ret = udsGetNetworkStructApplicationData(&network->network, out_appdata, sizeof(out_appdata), &actual_size);
			if(R_FAILED(ret) || actual_size!=sizeof(out_appdata))
			{
				__oldPrintF("udsGetNetworkStructApplicationData() returned 0x%08x. out_appdata = 0x%08x actual_size = 0x%08x.\n", (unsigned int)ret, sizeof(out_appdata), actual_size);
			} else {
				break;
			}
		}

		memset(tmpstr, 0, sizeof(tmpstr));
		if(memcmp(out_appdata, appdata, 4)!=0)
		{
			__oldPrintF("The first 4-bytes of appdata is invalid.\n");
			free(networks);
			return;
		}

		strncpy(tmpstr, (char*)&out_appdata[4], sizeof(out_appdata)-5);
		__oldPrintF("String from network appdata: %s\n", (char*)&out_appdata[4]);
		*/
		for(pos=0; pos<10; pos++)
		{
			ret = udsConnectNetwork(&network->network, passphrase, strlen(passphrase)+1, &bindctx, UDS_BROADCAST_NETWORKNODEID, conntype, data_channel, recv_buffer_size);
			if(R_FAILED(ret))
			{
				__oldPrintF("udsConnectNetwork() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				return;
			}
			else
			{
				break;
			}
		}

		free(networks);

		if(pos==10)return;

		if (debugging) __oldPrintF("Connected.\n");


		tmp = 0;
		ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
		if (debugging) __oldPrintF("udsGetChannel() returned 0x%08x. channel = %u.\n", (unsigned int)ret, (unsigned int)tmp);
		if(R_FAILED(ret))
		{
			CATASTROPHIC_FAILURE = true;
			return;
		}

		//You can load the appdata with this once connected to the network, if you want.
		/*memset(out_appdata, 0, sizeof(out_appdata));
		actual_size = 0;
		ret = udsGetApplicationData(out_appdata, sizeof(out_appdata), &actual_size);
		if(R_FAILED(ret) || actual_size!=sizeof(out_appdata))
		{
			__oldPrintF("udsGetApplicationData() returned 0x%08x. actual_size = 0x%x.\n", (unsigned int)ret, actual_size);
			udsDisconnectNetwork();
			udsUnbind(&bindctx);
			return;
		}

		memset(tmpstr, 0, sizeof(tmpstr));
		if(memcmp(out_appdata, appdata, 4)!=0)
		{
			__oldPrintF("The first 4-bytes of appdata is invalid.\n");
			udsDisconnectNetwork();
			udsUnbind(&bindctx);
			return;
		}

		strncpy(tmpstr, (char*)&out_appdata[4], sizeof(out_appdata)-5);
		__oldPrintF("String from appdata: %s\n", (char*)&out_appdata[4]);
		*/
		con_type = 1;
		//myNum = 1;
	}
	if (hosting)
	{
		udsGenerateDefaultNetworkStruct(&networkstruct, wlancommID, 0, 8); //only have room for 8 players.

		__oldPrintF("Creating the network...\n");
		ret = udsCreateNetwork(&networkstruct, passphrase, strlen(passphrase)+1, &bindctx, data_channel, recv_buffer_size);
		if(R_FAILED(ret))
		{
			__oldPrintF("udsCreateNetwork() returned 0x%08x.\n", (unsigned int)ret);
			CATASTROPHIC_FAILURE = true;
			return;
		}

		/*ret = udsSetApplicationData(appdata, sizeof(appdata));//If you want to use appdata, you can set the appdata whenever you want after creating the network. If you need more space for appdata, you can set different chunks of appdata over time.
		if(R_FAILED(ret))
		{
			__oldPrintF("udsSetApplicationData() returned 0x%08x.\n", (unsigned int)ret);
			udsDestroyNetwork();
			udsUnbind(&bindctx);
			return;
		}*/

		tmp = 0;
		ret = udsGetChannel((u8*)&tmp);//Normally you don't need to use this.
		if (debugging) __oldPrintF("udsGetChannel() returned 0x%08x. channel = %u.\n", (unsigned int)ret, (unsigned int)tmp);
		if(R_FAILED(ret))
		{
			udsDestroyNetwork();
			udsUnbind(&bindctx);
			CATASTROPHIC_FAILURE = true;
			return;
		}

		con_type = 0;
		myNum = 0;
	}
	tmpbuf_size = UDS_DATAFRAME_MAXSIZE;
	tmpbuf = malloc(tmpbuf_size);
	if(tmpbuf==NULL)
	{
		__oldPrintF("Failed to allocate tmpbuf for receiving data.\n");

		CATASTROPHIC_FAILURE = true;
		if(con_type)
		{
			udsDestroyNetwork();
		}
		else
		{
			udsDisconnectNetwork();
		}
		udsUnbind(&bindctx);

		return;
	}
	if(udsWaitConnectionStatusEvent(false, false))
	{
		if (debugging) __oldPrintF("Constatus event signaled.\n");
		ret=0;
		u32 pos;
		

		//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
		ret = udsGetConnectionStatus(&constatus);
		if(R_FAILED(ret))
		{
			__oldPrintF("udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
			CATASTROPHIC_FAILURE = true;
			return;
		}
		else
		{
			if (debugging) {
				__oldPrintF("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
				__oldPrintF("1=0x%x\n", (unsigned int)constatus.unk_x4);
				__oldPrintF("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
				__oldPrintF("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
				for(pos=0; pos<(0x20>>2); pos++)__oldPrintF("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
				__oldPrintF("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
				__oldPrintF("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
				__oldPrintF("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
			}
			myNode = constatus.cur_NetworkNodeID;
			sprites[myNum].node = myNode;
			memset(tmpstr, 0, sizeof(tmpstr));
			ret = udsGetNodeInformation(constatus.cur_NetworkNodeID,&tmpnode);
			ret = udsGetNodeInfoUsername(&tmpnode,&tmpstr);
			if (strlen(overwriteName) == 0) strncpy(myName,tmpstr,sizeof(myName));
			else strncpy(myName,overwriteName,sizeof(myName));

			if (!hosting) {
				myNum = constatus.total_nodes - 1;
				num_bikes = constatus.total_nodes;

				setSprites();
				if (debugging) __oldPrintF("Sending request to join...\n");
				sprites[myNum].speed = 1111;
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 1111;
				UDSSend(msg);
				memset(replySprite,0,sizeof(replySprite[0]) * 10);
				lastSprite = svcGetSystemTick();
				while (1) {
					sf2d_swapbuffers();
					hidScanInput();
					if (hidKeysDown() & KEY_START) { __oldPrintF("ENDING...\n"); CATASTROPHIC_FAILURE = true; return; }
					if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
						if (debugging) __oldPrintF("Resending request...\n");
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						sprites[myNum].node = myNode;
						msg.sprite = sprites[myNum]; 
						msg.sprite.speed = 1111; 
						UDSSend(msg);
						lastSprite = svcGetSystemTick();
					}
					memset(tmpbuf, 0, tmpbuf_size);
					actual_size = 0;
					src_NetworkNodeID = 0;
					ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
					if(R_FAILED(ret))
					{
						__oldPrintF("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
						replay = false;
						CATASTROPHIC_FAILURE = true;
						return;
					}
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) __oldPrintF("speed: %d image: %d myNum: %d\n",msg.sprite.speed, msg.sprite.image, myNum);
						if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; sprites[myNum] = msg.sprite; sprites[myNum].node = myNode; msg.sprite = sprites[myNum]; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; memset(replySprite,0,sizeof(replySprite[0]) * 10); break; } //joined game in score screen
						else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].dead = true; sprites[myNum].node = myNode; sprites[myNum].speed = 45; msg.sprite = sprites[myNum]; memset(replySprite,0,sizeof(replySprite[0]) * 10); break; } // joined game in progress
						else if(msg.sprite.speed == 1211 && msg.sprite.image == myNum) break;
					}
				}
			}
		}

	}

	//__oldPrintF("Press A to stop data transfer.\n");
	char quitName[50];
	memset(quitName,'\0',sizeof(quitName));
	while (replay) {
		errorQuit = 0;
		if (num_bikes < 1) num_bikes = 1;
		for (int i = 0; i < num_bikes; i++) {
			score[i] = 0;
		}
		int oldJoin = 0;
		u32 joined = 0;
		if (!inGame) setSprites();
		if (con_type == 0) { //hosting, wait for connection
			hidScanInput();
			u32 kDown = hidKeysDown();
			u32 kUp = hidKeysUp();
			u32 kHeld = hidKeysHeld();
			__oldConsoleClear();
			if (!connectionEstablished) __oldPrintF("Waiting for connection...\nLet go of A to play by yourself.\n\n",textColors[7]);
			else __oldPrintF("Preparing room...\n");
			while ((kHeld & KEY_A) && !(kUp & KEY_A)) {
				sf2d_swapbuffers();
				hidScanInput();

				kHeld = hidKeysHeld();
				kDown = hidKeysDown();
				kUp = hidKeysUp();
				if(kDown & KEY_START) {
					udsDisconnectNetwork();
					udsUnbind(&bindctx);
					return;
				}
				if (kUp & KEY_A) break;
				if(udsWaitConnectionStatusEvent(false, false))
				{
					setSprites();
					connectionEstablished = true;
					
					ret = udsGetConnectionStatus(&constatus);
					ret = udsGetNodeInformation(0x1,&tmpnode);
					memset(sprites[0].username,'\0',sizeof(sprites[0].username));
					udsGetNodeInfoUsername(&tmpnode,&sprites[0].username);
					ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
					if (constatus.total_nodes >= num_bikes) {
						memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes].username));
						udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes].username);
						sprites[num_bikes].node = constatus.total_nodes;
						if (debugging) {
							__oldPrintF("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
							__oldPrintF("1=0x%x\n", (unsigned int)constatus.unk_x4);
							__oldPrintF("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
							__oldPrintF("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
							for(pos=0; pos<(0x20>>2); pos++)__oldPrintF("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
							__oldPrintF("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
							__oldPrintF("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
							__oldPrintF("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
						}
						__oldPrintF("%s%s has joined as %s%s\n",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
						num_bikes = constatus.total_nodes;
					}
					break;
				}
			}
			int i = 0;
			ret = 0;
			if (debugging) __oldPrintF("Sending bike information");
			bool redo = true;
			lastSprite = svcGetSystemTick();
			lastChange = svcGetSystemTick();
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			memset(replyChange,0,sizeof(replyChange[0]) * 10);
			while (redo && num_bikes > 1) {
				for (i = 0; i < num_bikes; i++) {
					sf2d_swapbuffers();
					msg.sprite = sprites[i];
					UDSResend(replySprite,msg);
				}
				if (!allReplied(replySprite)) lastSprite = svcGetSystemTick();
				if (!allReplied(replyChange)) lastChange = svcGetSystemTick();
				msg.sprite.image = 0;
				msg.sprite.speed = 66;
				msg.sprite.x = apple.x;
				msg.sprite.y = apple.y;
				UDSResend(replyChange,msg);
				int badPacket = 0;
				while (1) {
					sf2d_swapbuffers();
					hidScanInput();
					u32 kDown = hidKeysDown();
					if (kDown & KEY_START) {
						CATASTROPHIC_FAILURE = true;
						return;
					}
					memset(tmpbuf, 0, tmpbuf_size);
					actual_size = 0;
					src_NetworkNodeID = 0;

					if(udsWaitConnectionStatusEvent(false, false))
					{
						u32 pos;
						

						//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
						ret = udsGetConnectionStatus(&constatus);
						if(R_FAILED(ret))
						{
							__oldPrintF("udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
							CATASTROPHIC_FAILURE = true;
							return;
						}
						else
						{
							if (constatus.total_nodes >= num_bikes) {
								if (debugging) {
									__oldPrintF("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
									__oldPrintF("1=0x%x\n", (unsigned int)constatus.unk_x4);
									__oldPrintF("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
									__oldPrintF("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
									for(pos=0; pos<(0x20>>2); pos++)__oldPrintF("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
									__oldPrintF("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
									__oldPrintF("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
									__oldPrintF("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
								}
								ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
								if (constatus.total_nodes >= num_bikes) {
									memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes].username));
									udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes].username);
									if (!sprites[num_bikes].node) sprites[num_bikes].node = constatus.total_nodes;
									__oldPrintF("%s%s has joined as %s%s\n",textColors[num_bikes],sprites[num_bikes].username,colorNames[num_bikes],WHITE);
								}
							} else {
								__oldPrintF("Lost one!\n");
							}
							num_bikes = constatus.total_nodes;

						}
					}
					ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
					if(R_FAILED(ret))
					{
						__oldPrintF("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
						CATASTROPHIC_FAILURE = true;
						return;
					}
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) __oldPrintF("speed: %d image: %d\n",msg.sprite.speed, msg.sprite.image);
						if (msg.sprite.speed == 100) replySprite[msg.sender] = true;
						else if (msg.sprite.speed == 777) {} //ignore
						else if (msg.sprite.speed == 123) {} //ignore
						else if (msg.sprite.speed == 66) replyChange[msg.sender] = true;
						else if (msg.sprite.speed == 1111) { if (debugging) __oldPrintF("Accepting request to join...(%d)\n",msg.sender); sprites[msg.sender].node = msg.sprite.node; replyChange[msg.sender] = false; replySprite[msg.sender] = false; sprites[msg.sender].speed = 1211; msg.sprite = sprites[msg.sender]; UDSSend(msg); } 
						else if (msg.sprite.speed == 999) { CATASTROPHIC_FAILURE = true; return; } //player quit
					}
					if (allReplied(replySprite) && allReplied(replyChange)) {
						if (debugging) __oldPrintF("Starting game...");
						redo = false;
						msg.sprite = sprites[myNum];
						msg.sprite.image = 0;
						msg.sprite.speed = 101;
						UDSSend(msg);
						memset(replySprite,0,sizeof(replySprite[0]) * 10);
						lastSprite = svcGetSystemTick();
						wakeup = true;
						break;
					} else if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 30 * lagMult()) {
						break;
					} else if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
						break;
					}
				}
				sf2d_swapbuffers();
			}
			sf2d_swapbuffers();
		} else if (!inGame) { //guest connection
			__oldConsoleClear();
			if (debugging) __oldPrintF("\x1b[0;0HReceiving bike information...\n");
			__oldPrintF("Loading...\nYou are %s%s%s!",textColors[myNum],colorNames[myNum],WHITE);
			int badPacket = 0;
			u32 data_received = 0;
			memset(replySprite,true,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick();
			int oldspeed = 0;
			while (1) {
				sf2d_swapbuffers();
				hidScanInput();
				u32 kDown = hidKeysDown();
				if (kDown & KEY_START) {
					return;
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
			
				if(udsWaitConnectionStatusEvent(false, false))
				{
					u32 pos;
					

					//By checking the output of udsGetConnectionStatus you can check for nodes (including the current one) which just (dis)connected, etc.
					ret = udsGetConnectionStatus(&constatus);
					if(R_FAILED(ret))
					{
						__oldPrintF("udsGetConnectionStatus() returned 0x%08x.\n", (unsigned int)ret);
						CATASTROPHIC_FAILURE = true;
						return;
					}
					else
					{
						if (debugging) {
							__oldPrintF("constatus:\nstatus=0x%x\n", (unsigned int)constatus.status);
							__oldPrintF("1=0x%x\n", (unsigned int)constatus.unk_x4);
							__oldPrintF("cur_NetworkNodeID=0x%x\n", (unsigned int)constatus.cur_NetworkNodeID);
							__oldPrintF("unk_xa=0x%x\n", (unsigned int)constatus.unk_xa);
							for(pos=0; pos<(0x20>>2); pos++)__oldPrintF("%u=0x%x ", (unsigned int)pos+3, (unsigned int)constatus.unk_xc[pos]);
							__oldPrintF("\ntotal_nodes=0x%x\n", (unsigned int)constatus.total_nodes);
							__oldPrintF("max_nodes=0x%x\n", (unsigned int)constatus.max_nodes);
							__oldPrintF("node_bitmask=0x%x\n", (unsigned int)constatus.total_nodes);
						}
						if (!hosting) {
							myNum = constatus.cur_NetworkNodeID - 1;
							num_bikes = constatus.total_nodes;
							sprites[myNum].image = myNum;
							sprites[myNum].node = myNode;
							memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
							strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
							msg.sprite = sprites[myNum];
							msg.sprite.speed = 1111;
							UDSDirect(1,msg);
						}
					}
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
				//__oldPrintF("tmpbuf_size: 0x%08x (0x%08x)\n",tmpbuf_size,sizeof(Message));
				ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
				if(R_FAILED(ret))
				{
					__oldPrintF("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
					CATASTROPHIC_FAILURE = true;
					return;
				}
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (debugging) if (msg.sprite.speed != oldspeed) __oldPrintF("image: %d speed: %d myNum: %d myNode: %d\n",msg.sprite.image, msg.sprite.speed, myNum, myNode);
					oldspeed = msg.sprite.speed;
					
					if (msg.sprite.speed == 123) {} //ignore
					else if (msg.sprite.speed == 777) {} //ignore
					else if (msg.sprite.speed == 555) { if (msg.sender == 0) UDSSend(msg); } //make sure host realizes we are waiting for him!
					else if (msg.sprite.speed == 1111) { sprites[msg.sprite.image] = msg.sprite; strncpy(sprites[msg.sprite.image].username,msg.sprite.username,sizeof(sprites[msg.sprite.image])); oldbikes--; } //ignore
					else if(msg.sprite.speed == 1001 && msg.sprite.image == myNum) { inGame = true; msg.sprite.speed = 45; sprites[myNum] = msg.sprite; for (int i = 0; i < num_bikes; i++) sprites[i].dead = true; break; } //joined game in score screen
					else if(msg.sprite.speed == 1011) { inGame = true; actual_bikes = msg.sprite.image; sprites[myNum] = msg.sprite; sprites[myNum].image = myNum; sprites[myNum].speed = 45; sprites[myNum].node = myNode; sprites[myNum].dead = true; memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username)); strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username)); break; } // joined game in progress
					else if (msg.sprite.speed == 66) {
						if (msg.sender == 0) {
							apple.x = msg.sprite.x;
							apple.y = msg.sprite.y;
							UDSSend(msg);
						}
					} else if (msg.sprite.speed == 101) { if (msg.sender == 0) UDSSend(msg); break; }
					else if (msg.sender == 0 && (msg.sprite.speed == 45 || msg.sprite.speed == 1211)) {
						path[0][msg.sprite.image].x = msg.sprite.x;
						path[0][msg.sprite.image].y = msg.sprite.y;
						sprites[msg.sprite.image] = msg.sprite;
						sprites[msg.sprite.image].speed = 45;
						if (msg.sprite.image >= num_bikes - 1) {
							msg.sprite.speed = 100;
							UDSSend(msg);
						}
					}
				} 
			}
		}
		for (int i = 0; i < 10; i++) oldscore[i] = 0;
		bool olddead = sprites[myNum].dead;
		u32 olddead1 = false;
		u32 olddead2 = false;
		oldbikes = num_bikes;
		__oldConsoleClear();
		// Main loop
		for (int i = 0; i < num_bikes; i++) {
			frameTicks[i] = svcGetSystemTick();
		}
		int oldApplex = 0;
		int oldAppley = 0;
		int oldDx = 15;
		UDSSent = svcGetSystemTick();
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replyScore,1,sizeof(replyScore[0]) * 10);
		if (myNum) memset(replyChange,1,sizeof(replyChange[0]) * 10);
		frameBuf = gfxGetFramebuffer(GFX_TOP, GFX_LEFT, NULL, NULL);
		if (!inGame && myNum != 0) memset(replySprite,1,sizeof(replySprite[0]) * 10);
		quit = -1;
		if (!inGame) actual_bikes = num_bikes;
		printScore();
		death = 0;
		int oldsender = 0;
		int oldspeed = 0;
		for (int i = actual_bikes; i < NUM_SPRITES; i++) {
			sprites[i].dead = true;
		}
		while (aptMainLoop()) {
			if (everyoneElseIsDead() && sprites[myNum].dead) break;
			if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 3) {
				return;
			}
			if (myNum == 0) {
				if(udsWaitConnectionStatusEvent(false, false))
				{
					
					ret = udsGetConnectionStatus(&constatus);
					ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
					if (constatus.total_nodes >= num_bikes) {
						replyScore[msg.sender] = true;
						replyChange[msg.sender] = true;
						num_bikes = constatus.total_nodes;
					} else {
						errorQuit = svcGetSystemTick();
					}
				}
			}
			if (!wakeup) {
				if (!allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.image = myNum;
					msg.sprite.speed = 77;
					msg.sprite.x = apple.x;
					msg.sprite.y = apple.y;
					lastScore = svcGetSystemTick();
					UDSResend(replyScore,msg);
				}
				if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.image = myNum;
					msg.sprite.speed = 66;
					msg.sprite.x = apple.x;
					msg.sprite.y = apple.y;
					lastChange = svcGetSystemTick();
					UDSResend(replyChange,msg);
				}
				if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					if (sprites[myNum].speed == 1011) {
						memset(replySprite,1,sizeof(replySprite[0]) * 10);
					} else {
						sprites[myNum].node = myNode;
						memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
						strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
						msg.sprite = sprites[myNum];
						lastSprite = svcGetSystemTick();
						UDSResend(replySprite,msg);
					}
				}
			} else {
				if (!allReplied(replySprite) && svcGetSystemTick() -  lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					msg.sprite = sprites[myNum];
					msg.sprite.speed = 101;
					UDSResend(replySprite,msg);
					lastSprite = svcGetSystemTick();
				}
				if (allReplied(replySprite)) {
					wakeup = false;
				}
			}
			hidScanInput();

			// Respond to user input
			u32 kDown = hidKeysDown();
			u32 kHeld = hidKeysHeld();
			u32 kUp = hidKeysUp();
			u32 msgtype = NULL;
			if (kDown & KEY_START) {
				replay = false;
				return; // break in order to return to hbmenu
			}
			if (kDown & KEY_Y && !usedSpecial) {
				usedSpecial = true;
				changeApple();
			}
			if (kDown & KEY_A || kHeld & KEY_A) sprites[myNum].speed = 15;
			else if (kUp & KEY_A) sprites[myNum].speed = 45;
			else if (kDown & KEY_B || kHeld & KEY_B) sprites[myNum].speed = 90;
			else if (kUp & KEY_B) sprites[myNum].speed = 45;
			int prevn = currentPath[myNum] - 1;
			if (prevn < 0) prevn = 240 * 400;
			if ((kDown & KEY_CPAD_UP || kDown & KEY_DUP) && !sprites[myNum].dy && path[prevn][myNum].x != sprites[myNum].x) {
				sprites[myNum].dx = 0;
				sprites[myNum].dy = bikeSpeed * -1;
				msgtype = MOVE_UP;
			} else if((kDown & KEY_CPAD_DOWN || kDown & KEY_DDOWN) && !sprites[myNum].dy && path[prevn][myNum].x != sprites[myNum].x) {
				sprites[myNum].dx = 0;
				sprites[myNum].dy = bikeSpeed;
				msgtype = MOVE_DOWN;
			} else if ((kDown & KEY_CPAD_LEFT || kDown & KEY_DLEFT) && !sprites[myNum].dx && path[prevn][myNum].y != sprites[myNum].y) {
				sprites[myNum].dx = bikeSpeed * -1;
				sprites[myNum].dy = 0;
				msgtype = MOVE_LEFT;
			} else if ((kDown & KEY_CPAD_RIGHT || kDown & KEY_DRIGHT) && !sprites[myNum].dx && path[prevn][myNum].y != sprites[myNum].y) {
				sprites[myNum].dx = bikeSpeed;
				sprites[myNum].dy = 0;
				msgtype = MOVE_RIGHT;
			}
			if (msgtype != NULL || oldDx != sprites[myNum].speed) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(myName));
				msg.sprite = sprites[myNum];
				lastSprite = svcGetSystemTick();
				UDSSend(msg);
				oldDx = sprites[myNum].speed;
			}
			//send my sprite info
			//Message msg;
			

			//receive other sprite's info
			memset(tmpbuf, 0, tmpbuf_size);
			actual_size = 0;
			src_NetworkNodeID = 0;
			ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
			if(R_FAILED(ret))
			{
				__oldPrintF("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				return;
			}
			if (wakeup) {
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (msg.sprite.speed == 101) {
						replySprite[msg.sender] = true;
					}
				}
			}
			/*if (memcmp(score,oldscore,sizeof(score))) {
				__oldConsoleClear();
				memcpy(&oldscore,score, sizeof(score));
				printScore();
			}*/
			for (int i = 0; i < num_bikes; i++) {
				if (score[i] != oldscore[i]) clearFlag = true;
			}
			if (sprites[myNum].dead && !olddead) clearFlag = true;
			if (oldbikes != num_bikes) { clearFlag = true; oldbikes = num_bikes; }
			if (clearFlag) {
				if (!debugging) __oldConsoleClear();
				printScore();
				for (int i = 0; i < num_bikes; i++) oldscore[i] = score[i];
					olddead = sprites[myNum].dead;
				clearFlag = false;
			}
			sf2d_swapbuffers();
			
			//Wait for VBlank
			// Render the scene
			if (!wakeup) {
				
					sceneRender();
					moveSprites();
					if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
					{
						//Message msg;
						memcpy(&msg,tmpbuf,sizeof(Message));
						if (debugging) __oldPrintF("sender: %d speed: %d image: %d node: %d\n",msg.sender,msg.sprite.speed,msg.sprite.image, msg.sprite.node);
						oldspeed = msg.sprite.speed;
						oldsender = msg.sender;
						if (msg.sprite.speed == 101 && msg.sender == 0) { UDSSend(msg); } //ignore.
						else if (msg.sprite.speed == 999) {
							errorQuit = 0;
							if (msg.sender == msg.sprite.node && msg.sender == msg.sprite.image) {
								for (int i = 0; i < num_bikes; i++) {
									if (sprites[i].node == msg.sprite.node) { quit = i; break; }
								}
								memset(quitName,'\0',sizeof(quitName));
								strncpy(quitName,msg.sprite.username,sizeof(quitName));
								//num_bikes--;
								first = false;
								for (int i = 0; i < num_bikes; i++) {
									sprites[i].dead = true;
								}
								msg.sprite.image = msg.sprite.node;
								msg.sprite.node = myNode;
								UDSDirect(msg.sprite.image,msg);
							}
						}
						else if (msg.sprite.speed == 1111) {
							sprites[msg.sprite.image] = msg.sprite;
							if (myNum == 0 && msg.sprite.image == msg.sender) {
								oldJoin = msg.sprite.image;
								msg.sprite = sprites[msg.sprite.image];
								msg.sprite.image = actual_bikes;
								msg.sprite.speed = 1011;
								msg.sprite.dead = true;
								sprites[num_bikes] = msg.sprite;
								oldbikes = 0;
								UDSSend(msg);
							}
						}
						else if (msg.sprite.speed == 1011 && myNum != 0) {} // ignore
						else if (msg.sprite.speed == 66) { 
							if (msg.sprite.image == myNum) { if (msg.timestamp == lastChange) replyChange[msg.sender] = true; }
							else if (msg.sender == msg.sprite.image) { if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) updateApple(msg.sprite.x,msg.sprite.y); UDSSend(msg); }
						}
						else if (msg.sprite.speed == 77) { 
							if (msg.sprite.image == myNum) { if (msg.timestamp == lastScore) replyScore[msg.sender] = true; }
							else if (msg.sender == msg.sprite.image) { if (!(msg.sprite.x == apple.x && msg.sprite.y == apple.y)) setApple(msg.sprite.image, msg.sprite.x, msg.sprite.y); UDSSend(msg); }
						}
						else if (msg.sprite.image == myNum) { if (msg.sprite.speed == 1001) break; if (msg.timestamp == lastSprite) replySprite[msg.sender] = true; }
						else if (msg.sprite.speed == 1001) {} //ignore.
						else {
							
							//if (msg.sender >= actual_bikes) msg.sprite.dead = true;
							if (msg.sprite.image > num_bikes) { 
								if (myNum) joined++; 
								num_bikes = msg.sprite.image + 1; 
								for (int i = actual_bikes; i < NUM_SPRITES; i++) { 
									sprites[i].dead = true; 
								} 
								if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
								if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
								if (sprites[myNum].dead) { 
									sprites[myNum].image = myNum; 
									sprites[myNum].node = myNode; 
									msg.sprite = sprites[myNum]; 
									replySprite[num_bikes - 1] = false; 
									UDSSend(msg); 
								} 
							}
							if (msg.sprite.image == num_bikes) { 
								if (myNum) joined++; 
								sprites[num_bikes].dead = true; 
								if (allReplied(replyScore)) memset(replyScore,1,sizeof(replyScore[0]) * 10); 
								if (allReplied(replyChange)) memset(replyChange,1,sizeof(replyChange[0]) * 10); 
								num_bikes++; 
								if (sprites[myNum].dead) { 
									__oldPrintF("wtf...\n");
									sprites[myNum].image = myNum; 
									sprites[myNum].node = myNode; 
									msg.sprite = sprites[myNum]; 
									replySprite[num_bikes - 1] = false; 
									UDSSend(msg); 
								} 
							}
							if (msg.sender == msg.sprite.image) UDSSend(msg);
							int img = msg.sprite.image;
							if (msg.sprite.image < actual_bikes && msg.sender == msg.sprite.image) {
								//if ((sprites[img].x >> 8) != (msg.sprite.x >> 8) || (sprites[img].y >> 8) != (msg.sprite.y >> 8)) drawSprite(sprites[img].x >> 8, sprites[img].y >> 8, 2, 2, 9);
								if (abs(currentPath[img] - pathPos[img]) > 4) {
									u32 pathx = path[currentPath[img]][img].x >> 8;
									u32 pathy = path[currentPath[img]][img].y >> 8;
									u32 imgx = msg.sprite.x >> 8;
									u32 imgy = msg.sprite.y >> 8; 
									//if ((pathx != imgx && pathy == imgy) || (pathy != imgy && pathx == imgx)) finishLine(currentPath[img],pathx << 8, pathy << 8, imgx << 8, imgy << 8, img);
									if (msg.sprite.dead) {
										eraseOvershoot(msg.sprite);
									}
									else finishLine(currentPath[img],pathx << 8, pathy << 8, imgx << 8, imgy << 8, msg.sprite, img);
									/*
									int pathnum = currentPath[img];
									while (abs(currentPath[img] - pathnum) < 40 && (path[pathnum][img].x >> 8) != imgx && (path[pathnum][img].y >> 8) != imgy) {
										//drawSprite(path[pathnum][img].x >> 8, path[pathnum][img].y >> 8, 2, 2, 9);
										pathnum--;
										if (pathnum < 0) pathnum = 400 * 240;
									}
									pathx = path[pathnum][img].x >> 8;
									pathy = path[pathnum][img].y >> 8;
									imgx = msg.sprite.x >> 8;
									imgy = msg.sprite.y >> 8;
									if (abs(pathx - imgx) > 200) {
										u32 newx;
										if (abs(400 - pathx) < 100) newx = 400;
										else newx = 0;
										//drawLine(pathnum,path[pathnum][img].x,path[pathnum][img].y,newx,msg.sprite.y, img);
										//drawLine(pathnum,newx,msg.sprite.y,msg.sprite.x,msg.sprite.y, img);
									}
									else if(abs(pathy - imgy) > 120) {
										u32 newy;
										if (abs(240 - pathy) < 60) newy = 240;
										else newy = 0;
										//drawLine(pathnum,path[pathnum][img].x,path[pathnum][img].y,msg.sprite.x,newy, img);
										//drawLine(pathnum,msg.sprite.x, newy,msg.sprite.x,msg.sprite.y, img);
									} else {
										//drawLine(pathnum,path[pathnum][img].x,path[pathnum][img].y,msg.sprite.x,msg.sprite.y,img);
									}*/
								}
							}
							if (msg.sender == msg.sprite.image) sprites[msg.sprite.image] = msg.sprite;
							//drawSprite(sprites[img].x >> 8, sprites[img].y >> 8, 2, 2, img);
							if (everyoneElseIsDead()) {
								if (getHighestScore() == myNum && allReplied(replyScore)) { sprites[myNum].dead = true; msg.sprite = sprites[myNum]; UDSSend(msg); }
							}
						}
					}
					if (oldApplex != apple.x && oldAppley != apple.y) { 
						drawSprite(apple.x >> 8, apple.y >> 8, 2, 2, 8);
						oldApplex = apple.x;
						oldAppley = apple.y;
					}
				sf2d_swapbuffers();
			}
			if (everyoneElseIsDead()) {
				if (getHighestScore() == myNum && allReplied(replyScore)) { sprites[myNum].dead = true; msg.sprite = sprites[myNum]; UDSSend(msg); }
			}
			if (everyoneElseIsDead() && sprites[myNum].dead) break;
		}
		__oldConsoleClear();
		memset(replyChange,1,sizeof(replyChange[0]) * 10);
		memset(replyScore,0,sizeof(replyScore[0]) * 10);
		lastScore = 0;
		int oldQuit = 0;
		bool said = false;
		int numLeft = 0;
		u64 lastQuit = 0;
		int realNum = myNum;
		int quitNum = 0;
		errorQuit = 0;
		for (int i = 0; i < NUM_SPRITES; i++) {
			ready[i] = false;
		}
		joinedNum = 0;
		waitForFinish = 0;
		u64 readyLock = 0;
		readyLock = svcGetSystemTick();
		inGame = false;
		while (1) {
			sf2d_swapbuffers();

			if (!allReplied(replySprite) && svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
				sprites[myNum].image = myNum;
				sprites[myNum].dead = true;
				sprites[myNum].node = myNode;
				msg.sprite = sprites[myNum];
				UDSResend(replySprite,msg);
			} //Be sure to still resend my death msg if someone hasn't gotten it
			if (allReplied(replyScore) && myNum == 0 && num_bikes > 1) { if (debugging) __oldPrintF("Everyone got the message. Sending bike information.."); break; }
			if (waitForFinish != 0 && svcGetSystemTick() - waitForFinish > TICKS_PER_SEC * 4) break;
			if (itsATie()) __oldPrintF("\x1b[0;0HIt's a TIE!                                   ");
			else if (getHighestScore() == myNum) __oldPrintF("\x1b[0;0HA winner is YOU!                             ");
			else __oldPrintF("\x1b[0;0HYou LOSE! %s%s wins the game!%s",textColors[getHighestScore()],sprites[getHighestScore()].username,WHITE);
			__oldPrintF("\x1b[1;0HScore: ");
				for (int i = 0; i < NUM_SPRITES; i++) {
					if (i < num_bikes || i == 0) __oldPrintF("%s%d ",textColors[i],score[i]);
					else __oldPrintF("  ");
				}
			__oldPrintF("\x1b[2;0H       ");
				for (int i = 0; i < NUM_SPRITES; i++) {
					if (i < num_bikes) {
						if (ready[i]) __oldPrintF("%sR ",GREEN);
						else __oldPrintF("%s- ",WHITE);
					} else __oldPrintF("  ");
				}
			__oldPrintF("\x1b[3;0H%sPress A if you're ready!\n",WHITE);
			__oldPrintF("\x1b[4;0HPress START to quit.\n");
			if (numLeft >= 22) { __oldConsoleClear(); numLeft = 0; }
			/*if (quit > 0 && oldQuit != quit && myNum == 0) { 
				numLeft++; 
				__oldPrintF("\x1b[%d;0H%s%s has left the game!%s\n",numLeft + 5,textColors[quit],sprites[quit].username,WHITE);
				oldQuit = quit;
				if (quit < num_bikes - 1) {
					for (int i = quit; i < num_bikes - 1; i++) {
						numLeft++;
						__oldPrintF("\x1b[%d;0H%s%s%s is now %s%s%s!",numLeft + 5, textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE);
						sprites[i] = sprites[i+1];
					}
					//memset(sprites[num_bikes].username,0,strlen(sprites[num_bikes].username));
				}
				ret = udsGetConnectionStatus(&constatus);
				num_bikes = constatus.total_nodes;
				replyChange = num_bikes - 1;
				replySprite = num_bikes - 1;
			}*/
			if (num_bikes == 1) { numLeft++; num_bikes--; __oldPrintF("\x1b[%d;0HEveryone has left the game!\n", numLeft + 5); }
			if (!allReplied(replyChange) && svcGetSystemTick() - lastChange > TICKS_PER_MS * 15 * 30 * lagMult()) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 123;
				//memset(replyChange,0,sizeof(replyChange[0]) * 10);
				UDSResend(replyChange,msg);
			}
			if (lastScore && !allReplied(replyScore) && svcGetSystemTick() - lastScore > TICKS_PER_MS * 15 * 30 * lagMult()) {
				sprites[myNum].node = myNode;
				strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
				msg.sprite = sprites[myNum];
				msg.sprite.speed = 555;
				UDSResend(replyScore,msg);
				lastScore = svcGetSystemTick();
			}
			hidScanInput();
			u32 kDown = hidKeysDown();
			memset(tmpbuf, 0, tmpbuf_size);
			actual_size = 0;
			src_NetworkNodeID = 0;
			ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
			if(R_FAILED(ret))
			{
				__oldPrintF("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
				CATASTROPHIC_FAILURE = true;
				replay = false;
				return;
			}
			if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
			{
				//Message msg;
				memcpy(&msg,tmpbuf,sizeof(Message));
				if (debugging) {
					numLeft++;
					__oldPrintF("\x1b[%d;0Hsender: %d, image: %d, speed: %d node: %d\n, %d",numLeft + 5,msg.sender,msg.sprite.image,msg.sprite.speed, msg.sprite.node);
				}
				if (msg.sprite.speed == 999) {
					if (msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
						memset(quitName,'\0',sizeof(quitName));
						strncpy(quitName,msg.sprite.username,sizeof(quitName));
						for (int i = 0; i < num_bikes; i++) {
							if (sprites[i].node == msg.sprite.node && i != oldQuit) { quit = i; oldQuit = quit; }
						}
						msg.sprite.image = msg.sprite.node;
						msg.sprite.node = myNode;
						UDSDirect(msg.sprite.image,msg);
					}
				}
				/*if (msg.sprite.speed == 999 && msg.sprite.image != quit) {
					if (msg.sender <= num_bikes) {
						lastQuit = msg.timestamp;
						quit = msg.sprite.image;
						quitNum = msg.sender;
						if (quit < myNum) myNum--;
						num_bikes--;
						replyChange--;
					}
				} //connection killed by guest*/
				else if (msg.sprite.speed == 1011) { } //ignore
				else if (msg.sprite.speed == 1111) {
					sprites[msg.sprite.image] = msg.sprite;
					sprites[msg.sprite.image].node = msg.sprite.node;
					if (joinedNum != msg.sprite.image) __oldPrintF("\x1b[%d;0H%s%s has joined as %s%s\n",numLeft + 5,textColors[msg.sprite.image],msg.sprite.username,colorNames[msg.sprite.image],WHITE);
					joinedNum = msg.sprite.image;
					if (myNum == 0) {
						msg.sprite = sprites[msg.sprite.image];
						msg.sprite.dead = true;
						msg.sprite.speed = 1001;
						UDSSend(msg);
					}
					memset(replySprite,0,sizeof(replySprite[0]) * 10);
					sprites[myNum].node = myNode;
					memset(sprites[myNum].username,'\0',sizeof(sprites[myNum].username));
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
					msg.sprite = sprites[myNum];
					UDSSend(msg);
				}
				else if (msg.sprite.speed == 123 && svcGetSystemTick() - readyLock > TICKS_PER_SEC) { if (!ready[msg.sender]) { numLeft++;  __oldPrintF("\x1b[%d;0H%s%s%s is ready! Waiting on %d more...",numLeft + 5, textColors[msg.sender], msg.sprite.username, WHITE, notReadies() - 1); } ready[msg.sender] = true; if (msg.sprite.image != myNum) { msg.sprite.image = msg.sender; msg.sprite.speed = 777; UDSSend(msg); } }
				else if (msg.sprite.speed == 777 && svcGetSystemTick() - readyLock > TICKS_PER_SEC) {
					if (msg.sprite.image == myNum) replyChange[msg.sender] = true;
				} else if(msg.sprite.speed == 555) {
					if (msg.sender == 0) {
						UDSSend(msg); 
						break; 
					} else if (myNum == 0) {
						replyScore[msg.sender] = true;
					}
				} else {
					if (msg.sprite.image == myNum) replySprite[msg.sender] = true;
					else if (msg.sprite.image == msg.sender) {
						sprites[msg.sprite.image] = msg.sprite;
						UDSSend(msg);
					}
				}
			}
			if (allReady() && num_bikes > 1 && !lastScore) { 
				__oldPrintF("\x1b[%d;0HStarting game....\n",numLeft + 6);  
				if (myNum == 0) { 
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 555;
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					UDSSend(msg);
					lastScore = svcGetSystemTick();
				}
			}


			if (kDown & KEY_B) { numLeft++; __oldPrintF("\x1b[%d;0H%f",numLeft + 5, (svcGetSystemTick() - waitForFinish) / TICKS_PER_SEC); }
			if (kDown & KEY_SELECT) {
				__oldConsoleClear();
				numLeft = 0;
				for (int i = 0; i < num_bikes; i++) {
					numLeft++;
					__oldPrintF("\x1b[%d;0HSprite %d",numLeft + 5, i);
					numLeft++;
					__oldPrintF("\x1b[%d;0H  username: %s",numLeft + 5, sprites[i].username,numLeft + 5);
					numLeft++;
					__oldPrintF("\x1b[%d;0H  image: %d",numLeft + 5, sprites[i].image,numLeft + 5);
				}
			}
			if (kDown & KEY_A && svcGetSystemTick() - readyLock > TICKS_PER_SEC) { 
				if (num_bikes <= 1) break; 
				if (!ready[myNum]) { 
					sprites[myNum].node = myNode; 
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username)); 
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 123; 
					lastChange = svcGetSystemTick(); 
					memset(replyChange,0,sizeof(replyChange[0]) * 10); 
					UDSSend(msg); 
					numLeft++; 
					__oldPrintF("\x1b[%d;0H%s%s%s is ready! Waiting on %d more...",numLeft +5,textColors[myNum],sprites[myNum].username,WHITE,notReadies() - 1); 
				} 
				ready[myNum] = true;  
			}
			if (kDown & KEY_START) { return; }
			if(udsWaitConnectionStatusEvent(false, false))
			{
				readyLock = svcGetSystemTick();
				for (int i = 0; i < 10; i++) {
					ready[i] = false;
				}
				ret = udsGetConnectionStatus(&constatus);
				ret = udsGetNodeInformation(constatus.total_nodes,&tmpnode);
				if (constatus.total_nodes >= num_bikes) {
					num_bikes = constatus.total_nodes;
					memset(sprites[num_bikes].username,'\0',sizeof(sprites[num_bikes - 1].username));
					udsGetNodeInfoUsername(&tmpnode,&sprites[num_bikes - 1].username);
					msg.sprite = sprites[num_bikes - 1];
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					memset(replyChange,1,sizeof(replyChange[0]) * 10);
					numLeft++;
				} else {
						numLeft++;
						if (quit < 0) {
							numLeft++;
							__oldPrintF("\x1b[%d;0HA player has crashed...",numLeft + 5);
							errorQuit = svcGetSystemTick();
							while (1) {
								sf2d_swapbuffers();
								hidScanInput();
								kDown = hidKeysDown();
								if (kDown & KEY_START) {
									CATASTROPHIC_FAILURE = true;
									return;
								}
								if (errorQuit != 0 && svcGetSystemTick() - errorQuit > TICKS_PER_SEC * 4) {
									numLeft++;
									if (numLeft >= 23) { __oldConsoleClear(); numLeft = 0; }
									__oldPrintF("\x1b[%d;0H%sError: unknown person left. Removing a color...%s",numLeft + 5,RED,WHITE);
									num_bikes = constatus.total_nodes;
									memset(replyChange,1,sizeof(replyChange[0]) * 10);
									memset(replySprite,1,sizeof(replySprite[0]) * 10);
									if (myNum >= num_bikes) {
										myNum = num_bikes - 1;
										__oldPrintF("\x1b[%d;0H  You are now %s%s%s!",numLeft + 5,textColors[myNum],colorNames[myNum],WHITE);
									}
									errorQuit = 0;
									break;
								}
								memset(tmpbuf, 0, tmpbuf_size);
								actual_size = 0;
								src_NetworkNodeID = 0;
								ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
								if(R_FAILED(ret))
								{
									__oldPrintF("udsPullPacket() returned 0x%08x.\n", (unsigned int)ret);
									CATASTROPHIC_FAILURE = true;
									replay = false;
									return;
								}
								if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
								{

									memcpy(&msg,tmpbuf,sizeof(Message));
									if (msg.sprite.speed == 999 && msg.sender == msg.sprite.node && msg.sprite.image == msg.sprite.node) {
										joinedNum = 0;
										for (int i = 0; i < num_bikes; i++) {
											if (sprites[i].node == msg.sprite.node) { quit = i; break; }
										}
										if (quit < 0) {
											CATASTROPHIC_FAILURE = true;
											return;
										}
										memset(quitName,'\0',sizeof(quitName));
										strncpy(quitName,msg.sprite.username,sizeof(quitName));
										msg.sprite.image = msg.sprite.node;
										msg.sprite.node = myNode;
										UDSDirect(msg.sprite.image,msg);
										oldQuit = quit;
										numLeft++;
										if (numLeft + num_bikes - quit >= 23) { __oldConsoleClear(); numLeft = 0; }
										__oldPrintF("\x1b[%d;0H%s%s has left the game.%s\n",numLeft + 5,textColors[quit],quitName,WHITE);
										if (quit > 0 && quit < num_bikes - 1) {
											if (quit < myNum) myNum--;
											for (int i = quit; i < num_bikes - 1; i++) {
												numLeft++;
												if (i == myNum) __oldPrintF("\x1b[%d;0H  You are now %s%s%s!",numLeft + 5,textColors[myNum],colorNames[myNum],WHITE);
												else __oldPrintF("\x1b[%d;0H  %s%s%s is now %s%s%s!",numLeft + 5, textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE);
												sprites[i] = sprites[i+1];
												sprites[i].image = i;
											}
										}
										num_bikes = constatus.total_nodes;
										memset(replyChange,1,sizeof(replyChange[0]) * 10);
										memset(replySprite,1,sizeof(replySprite[0]) * 10);
										quit = -1;
										oldQuit = -1;
										break;
									}
								}
							}
						}
						else {
							joinedNum = 0;
							if (numLeft + num_bikes - quit >= 23) { __oldConsoleClear(); numLeft = 0; }
							__oldPrintF("\x1b[%d;0H%s%s has left the game.%s\n",numLeft + 5,textColors[quit],quitName,WHITE);
							if (quit > 0 && quit < num_bikes - 1) {
								if (quit < myNum) myNum--;
								for (int i = quit; i < num_bikes - 1; i++) {
									numLeft++;
									if (i == myNum) __oldPrintF("\x1b[%d;0H  You are now %s%s%s!",numLeft + 5,textColors[myNum],colorNames[myNum],WHITE);
									else __oldPrintF("\x1b[%d;0H  %s%s%s is now %s%s%s!",numLeft + 5, textColors[i + 1], sprites[i+1].username,WHITE, textColors[i],colorNames[i],WHITE);
									sprites[i] = sprites[i+1];
									sprites[i].image = i;
								}
								quit = -1;
							}
							oldQuit = -1;
							quit = -1;
							joined = 0;
						}
					/*int foundNum = -1;
					for (int i = 0; i < constatus.total_nodes; i++) {
						numLeft++;
						ret = udsGetNodeInformation(i,&tmpnode);
						udsGetNodeInfoUsername(&tmpnode,&sprites[i - 1].username);
						if (!strcmp(sprites[i].username,myname)) foundNum = i;
						__oldPrintF("\x1b[%d;0H%s == %s? (%d)\n",numLeft + 5, sprites[i].username, myname,i);
					}
					if (foundNum == -1) myNum = constatus.total_nodes - 1;*/
					if (joined) joined = 1;
					num_bikes = constatus.total_nodes;
					memset(replyScore,0,sizeof(replyScore[0]) * 10);
					memset(replyChange,1,sizeof(replyChange[0]) * 10);
					}
				}
			}
		}
	}
//---------------------------------------------------------------------------------
int main() {
//---------------------------------------------------------------------------------

	// Initialize the scene
	sceneInit();
	//consoleInit(GFX_BOTTOM, NULL); //Print to bottom screen
	ret = 0;
	ret = udsInit(0x3000, NULL);//The sharedmem size only needs to be slightly larger than the total recv_buffer_size for all binds, with page-alignment.
	if(R_FAILED(ret))
	{
		sftd_init();
	sftd_font *font = sftd_load_font_mem(FreeSans_ttf, FreeSans_ttf_size);

	const char *someText = "Font drawing on the top screen! Text wraps after 300 pixels... Lorem ipsum dolor sit amet, consetetur sadipscing elit.";
	int textWidth = 0;
	int textHeight = 0;

	while (aptMainLoop()) {

		hidScanInput();
		if (hidKeysDown() & KEY_START) break;

		sf2d_start_frame(GFX_TOP, GFX_LEFT);

			sftd_draw_textf(font, 10, 10,  RGBA8(0,   255, 0,   255), 20, "udsinit failed: 0x%08x.\n", (unsigned int)ret);

		sf2d_end_frame();

		sf2d_start_frame(GFX_BOTTOM, GFX_LEFT);

			sftd_draw_textf(font, 10, 10,  RGBA8(0,   255, 0,   255), 20, "udsinit failed: 0x%08x.\n", (unsigned int)ret);

		sf2d_end_frame();

		sf2d_swapbuffers();
	}

	sftd_free_font(font);
	sftd_fini();

	sf2d_fini();
	return 0;
	}
	else
	{
		uds_test();
		size_t tmpbuf_size = 0x4000;
		u32 *tmpbuf = malloc(tmpbuf_size);
		size_t actual_size;
		u32 kDown;
		if (debugging) if (CATASTROPHIC_FAILURE) {
			__oldPrintF("%sCATASTROPHIC_FAILURE\n",RED);
			while (1) {
				sf2d_swapbuffers();
				hidScanInput();
				if (hidKeysDown() & KEY_START) break;
			}
		}
		if (myNum && !CATASTROPHIC_FAILURE) {
			sprites[myNum].node = myNode;
			memset(sprites[myNum].username,'/0',sizeof(sprites[myNum].username));
			strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
			sprites[myNum].image = myNode;
			sprites[myNum].node = myNode;
			msg.sprite = sprites[myNum];
			msg.sprite.speed = 999; 
			UDSSend(msg);
			memset(replySprite,0,sizeof(replySprite[0]) * 10);
			lastSprite = svcGetSystemTick(); 
			if (debugging) __oldPrintF("Sending quit message...\n");
			while (1) {
				sf2d_swapbuffers();
				hidScanInput();
				kDown = hidKeysDown();
				if (kDown & KEY_START) {
					if (debugging) __oldPrintF("...you stopped?\n");
					break;
				}
				if (svcGetSystemTick() - lastSprite > TICKS_PER_MS * 15 * 6 * lagMult()) {
					sprites[myNum].node = myNode;
					memset(sprites[myNum].username,'/0',sizeof(sprites[myNum].username));
					strncpy(sprites[myNum].username,myName,sizeof(sprites[myNum].username));
					sprites[myNum].image = myNode;
					sprites[myNum].node = myNode;
					msg.sprite = sprites[myNum]; 
					msg.sprite.speed = 999;
					lastSprite = svcGetSystemTick();
					UDSSend(msg);
				}
				memset(tmpbuf, 0, tmpbuf_size);
				actual_size = 0;
				src_NetworkNodeID = 0;
				ret = udsPullPacket(&bindctx, tmpbuf, tmpbuf_size, &actual_size, &src_NetworkNodeID);
				if(R_FAILED(ret))
				{
					__oldPrintF("udsPullPacket() returned 0x%08x.\nYou failed to leave the game. Press start.", (unsigned int)ret);
					replay = false;
					CATASTROPHIC_FAILURE = true;
					while (1) {
						sf2d_swapbuffers();
						hidScanInput();
						kDown = hidKeysDown();
						if (kDown & KEY_START) break;
					}
					break;
				}
				if(actual_size >= sizeof(Message))//If no data frame is available, udsPullPacket() will return actual_size=0.
				{
					memcpy(&msg,tmpbuf,sizeof(Message));
					if (debugging) __oldPrintF("image: %d sender: %d node: %d speed: %d\ntimestamp: 0x%08x mine: 0x%08x", msg.sprite.image, msg.sender, msg.sprite.node, msg.sprite.speed, (unsigned long) msg.timestamp, (unsigned long) lastSprite);
					if (msg.sprite.speed == 999 && msg.sprite.image == myNode && msg.timestamp == lastSprite) { __oldPrintF("%d leaving: %d\n",myNode,msg.sprite.node); replySprite[msg.sprite.node] = true; }
					int responded = 0;
					for (int i = 0; i <= NUM_SPRITES; i++) {
						if (i != myNode && replySprite[i]) responded++;
					}
					if (responded >= num_bikes - 1) {
						if (debugging) __oldPrintF("You successfuly left.");
						break;
					}
				}
			}

		}

		if(!myNum)
		{
			udsDestroyNetwork();
		}
		else
		{
			udsDisconnectNetwork();
		}
		udsUnbind(&bindctx);
		udsExit();
		if (!CATASTROPHIC_FAILURE) {
			if (debugging) __oldPrintF("You were successfully were removed from the game.");
			if (debugging) {
				while (1) {
					sf2d_swapbuffers();
					hidScanInput();
					kDown = hidKeysDown();
					if (kDown & KEY_START) break;
				}
			}
		}
	}


	sf2d_fini();
	// Deinitialize the scene
	sceneExit();

	// Deinitialize graphics
	return 0;
}
